<!-- 
	=============================================================================
	輕小說閱讀器 - 基於Vue.js的單頁應用程式
	=============================================================================
	這是一個現代化的輕小說閱讀器應用程式，展示了前端開發的多種重要技術：
	- HTML5語義化標籤和無障礙設計
	- CSS自定義屬性(CSS變數)和主題切換
	- 響應式設計和移動端優化
	- Vue.js 3組件式開發和狀態管理
	- 本地存儲和用戶偏好記憶
	- 現代JavaScript(ES6+)和異步編程
	=============================================================================
-->

<!-- DOCTYPE宣告：告訴瀏覽器這是HTML5文檔
	- 必須放在文檔最開始，沒有結束標籤
	- HTML5的DOCTYPE比舊版本簡潔許多
	- 確保瀏覽器以標準模式解析文檔，避免怪異模式
-->
<!DOCTYPE html>

<!-- html根元素：整個網頁的容器
	- lang屬性指定文檔的主要語言，對SEO和無障礙性很重要
	- zh-TW表示繁體中文(台灣)，幫助搜索引擎和屏幕閱讀器
	- 瀏覽器會根據lang屬性提供相應的功能(如拼寫檢查)
-->
<html lang="zh-TW">

<!-- head區塊：包含頁面的元數據，不會直接顯示在頁面上
	- 用於放置SEO信息、樣式表、腳本等資源
	- 瀏覽器會優先加載head中的內容
-->
<head>
	<!-- 字符編碼聲明：必須在head的前1024個字節內
		- UTF-8是Unicode的一種編碼方式，支持全世界的文字
		- 確保中文、日文等多語言字符正確顯示
		- 必須與服務器返回的編碼一致，避免亂碼
	-->
	<meta charset="UTF-8">
	
	<!-- 視口設定：控制移動設備上的頁面顯示
		- width=device-width：視口寬度等於設備寬度
		- initial-scale=1.0：初始縮放比例為100%
		- 這是響應式設計的基礎，確保頁面在移動設備上正確顯示
		- 沒有這個標籤，移動瀏覽器會以桌面寬度渲染頁面
	-->
	<meta name="viewport" content="width=device-width,initial-scale=1.0">
	
	<!-- 頁面標題：顯示在瀏覽器標籤頁和搜索結果中
		- 對SEO極其重要，是搜索引擎排名的重要因素
		- 建議長度在60個字符以內
		- 會被Vue.js動態更新以反映當前頁面內容
	-->
	<title>輕小說翻譯</title>
	
	<!-- 網站圖標：顯示在瀏覽器標籤頁、書籤和快捷方式中
		- rel="icon"定義這是一個圖標鏈接
		- type="image/jpg"指定MIME類型，幫助瀏覽器正確處理
		- 提升用戶體驗和品牌識別度
	-->
	<link rel="icon" href="images/favicon.jpg" type="image/jpg">
	
	<!-- 外部JavaScript庫：Vue.js 3框架
		- Vue.js是漸進式JavaScript框架，用於構建用戶界面
		- 使用CDN加載可以減少服務器負擔，提高加載速度
		- vue.global.js是全局構建版本，包含編譯器和運行時
		- 適合直接在瀏覽器中使用，無需構建工具
	-->
	<script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
	
	<!-- 外部JavaScript庫：Marked.js(Markdown解析器)
		- 用於將Markdown文本轉換為HTML
		- 本應用用它來解析小說內容和描述
		- 支持標準Markdown語法，如標題、粗體、斜體、鏈接等
		- 比手動解析文本更安全和功能豐富
	-->
	<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
	<!-- 內部樣式表：包含所有CSS樣式定義
		- 放在head中確保樣式在內容渲染前加載
		- 使用內部樣式表而非外部文件可減少HTTP請求
		- 對於單頁應用來說，內部樣式更高效
	-->
	<style>
		/* ==========================================================================
		   CSS自定義屬性(CSS Variables)系統
		   ==========================================================================
		   CSS自定義屬性是現代CSS的強大功能，提供以下優勢：
		   1. 主題切換：輕鬆實現明暗主題轉換
		   2. 一致性：確保整個應用的設計風格統一
		   3. 維護性：修改顏色時只需要改一個地方
		   4. 動態性：可以通過JavaScript動態修改
		   5. 響應式：結合clamp()函數實現自適應設計
		   ========================================================================== */
		
		/* :root偽類選擇器：定義全局CSS變數
		   - :root代表文檔的根元素(html元素)
		   - 在:root中定義的變數可以在任何地方使用
		   - 變數名必須以兩個連字符(--) 開頭
		   - 使用var()函數來引用變數：var(--variable-name)
		*/
		:root{
			/* 主色系：用於品牌識別和重要操作
			   - --primary：主要品牌顏色，用於按鈕、鏈接等交互元素
			   - 選用藍色系傳達專業和信任感
			   - 顏色值使用十六進制格式便於理解和修改
			*/
			--primary:#4a90e2;
			
			/* 懸停狀態顏色：提供視覺反饋
			   - 比主色稍暗，表示元素處於活躍狀態
			   - 提升用戶交互體驗的重要細節
			*/
			--primary-hover:#357abd;
			
			/* 背景色系：定義頁面的基礎色調
			   - --bg：主要背景顏色，影響整體視覺感受
			   - 淺色主題使用純白色，營造簡潔明亮的感覺
			*/
			--bg:#fff;
			
			/* 文字顏色系統：確保可讀性和層次感
			   - --text：主要文字顏色，需與背景形成足夠對比
			   - 深灰色比純黑色更柔和，減少視覺疲勞
			*/
			--text:#333;
			
			/* 次要文字顏色：用於不太重要的信息
			   - 比主文字顏色更淺，創造視覺層次
			   - 適用於時間戳記、說明文字等輔助信息
			*/
			--text-muted:#666;
			
			/* 邊框顏色：定義元素間的分界
			   - 淺灰色邊框不會過於突出
			   - 幫助區分不同區域而不造成視覺干擾
			*/
			--border:#ddd;
			
			/* 次要背景色：用於卡片、區塊等容器
			   - 比主背景稍暗，創造深度感
			   - 淺灰色提供微妙的視覺分層
			*/
			--secondary:#f5f5f5;
			
			/* 陰影效果：增加元素的立體感
			   - 使用rgba()實現半透明黑色陰影
			   - 0 2px 8px：水平偏移0、垂直偏移2px、模糊半徑8px
			   - 透明度0.15提供微妙的深度效果
			*/
			--shadow:0 2px 8px rgba(0,0,0,0.15);
			
			/* 響應式字體大小：使用clamp()函數實現自適應
			   - clamp(最小值, 首選值, 最大值)
			   - 16px：最小字體大小，確保可讀性
			   - 4vw：視口寬度的4%，隨螢幕大小縮放
			   - 18px：最大字體大小，避免過大
			   - 這種方法比媒體查詢更平滑
			*/
			--fs:clamp(16px,4vw,18px);
			
			/* 響應式行高：影響文字的垂直間距
			   - 1.6-1.8的行高範圍提供良好的可讀性
			   - 0.2vw的視口單位確保微調響應式效果
			   - 適當的行高減少閱讀疲勞
			*/
			--lh:clamp(1.6,0.2vw,1.8);
			
			/* 響應式邊框圓角：影響元素的視覺柔和度
			   - 6-8px的圓角範圍保持現代感
			   - 1vw確保在不同螢幕上的比例協調
			   - 適度的圓角提升視覺美感
			*/
			--br:clamp(6px,1vw,8px);
			
			/* 響應式間距：控制元素間的距離
			   - 0.8rem-1rem的範圍適合大多數場景
			   - 2vw提供視口寬度的響應式調整
			   - rem單位基於根元素字體大小，更具一致性
			*/
			--sp:clamp(0.8rem,2vw,1rem);
			
			/* RGB格式的背景色：用於rgba()函數
			   - 當需要設定透明度時使用
			   - 255,255,255對應白色的RGB值
			   - 避免重複定義顏色值，提高維護性
			*/
			--bg-rgb:255,255,255;
			
			/* 內容寬度：控制閱讀區域的寬度
			   - 80%的寬度在大螢幕上提供舒適的閱讀體驗
			   - 避免文字行過長造成閱讀困難
			   - 可通過JavaScript動態調整用戶偏好
			*/
			--content-width:80%;
		}
		
		/* 暗色主題變數重定義：實現主題切換功能
		   - 使用屬性選擇器[data-theme="dark"]來檢測暗色主題
		   - 只重定義需要改變的變數，其他保持不變
		   - JavaScript會動態添加/移除data-theme屬性
		   - 這種方法比使用多個CSS文件更高效
		*/
		:root[data-theme="dark"]{
			/* 暗色主題的主色調：更亮的藍色
			   - 在深色背景上需要更亮的顏色來保持對比度
			   - #64b5f6比淺色主題的藍色更亮更飽和
			*/
			--primary:#64b5f6;
			
			/* 深色背景：暗色主題的基礎
			   - #121212是Material Design推薦的暗色背景
			   - 比純黑色更柔和，減少視覺疲勞
			   - 提供良好的對比度和深度感
			*/
			--bg:#121212;
			
			/* 淺色文字：在深色背景上的可讀文字
			   - #e0e0e0提供足夠的對比度
			   - 比純白色柔和，適合長時間閱讀
			   - 遵循無障礙設計的對比度要求
			*/
			--text:#e0e0e0;
			
			/* 暗色主題的次要文字：層次感設計
			   - #999比主文字更暗，創造視覺層次
			   - 適用於時間、說明等次要信息
			*/
			--text-muted:#999;
			
			/* 暗色主題的邊框：微妙的分界線
			   - #333在深色背景上提供適度的分割
			   - 不會過於突出，保持視覺和諧
			*/
			--border:#333;
			
			/* 暗色主題的次要背景：容器和卡片背景
			   - #1a1a1a比主背景稍亮
			   - 創造深度和層次感
			   - 區分不同內容區域
			*/
			--secondary:#1a1a1a;
			
			/* 暗色主題的RGB背景值：用於透明度效果
			   - 18,18,18對應#121212的RGB值
			   - 用於半透明覆蓋層和漸變效果
			*/
			--bg-rgb:18,18,18;
		}
		/* ==========================================================================
		   CSS重置和通用工具類
		   ==========================================================================
		   重置樣式消除瀏覽器間的默認樣式差異，工具類提供可重用的樣式模式
		   ========================================================================== */
		
		/* 通用選擇器重置：消除所有元素的默認外邊距和內邊距
		   - * 選擇器選中頁面上的每一個元素
		   - margin:0; padding:0; 移除瀏覽器的默認間距
		   - 不同瀏覽器對元素的默認間距定義不同，重置確保一致性
		*/
		*{
			margin:0;        /* 移除所有元素的外邊距 */
			padding:0;       /* 移除所有元素的內邊距 */
			
			/* CSS盒模型重定義：box-sizing決定元素尺寸的計算方式
			   - content-box（默認）：寬高只包含內容區域，不包含padding和border
			   - border-box：寬高包含content、padding和border
			   - border-box更直觀，設置width:100px元素就是100px寬
			   - 這避免了添加padding或border時元素突然變大的問題
			*/
			box-sizing:border-box;
		}
		
		/* ==========================================================================
		   過渡動畫工具類：提供一致的動畫效果
		   ==========================================================================
		   過渡效果提升用戶體驗，讓界面變化更加平滑自然
		   ========================================================================== */
		
		/* 平滑過渡：用於較慢的轉換效果
		   - transition: all 0.3s 表示所有可動畫屬性都會在0.3秒內平滑過渡
		   - 適用於需要吸引注意的變化，如主題切換、大尺寸變化
		   - "all"關鍵字意味著任何CSS屬性的變化都會被動畫化
		*/
		.transition-smooth{
			transition:all 0.3s;
		}
		
		/* 快速過渡：用於需要即時反饋的交互
		   - 0.2秒的持續時間提供快速響應感
		   - 適用於懸停效果、按鈕點擊等即時反饋場景
		   - 更短的時間避免用戶感覺到延遲
		*/
		.transition-fast{
			transition:all 0.2s;
		}
		
		/* ==========================================================================
		   Flexbox佈局工具類：提供常用的彈性佈局模式
		   ==========================================================================
		   Flexbox是現代CSS佈局的核心技術，這些工具類封裝了常用模式
		   ========================================================================== */
		
		/* 垂直居中佈局：最常用的Flexbox模式之一
		   - display:flex 啟用彈性佈局
		   - align-items:center 讓子元素在交叉軸（通常是垂直方向）上居中
		   - 適用於按鈕、導航項等需要垂直居中對齊的場景
		*/
		.flex-center{
			display:flex;
			align-items:center;
		}
		
		/* 兩端對齊佈局：導航欄和工具欄的經典模式
		   - justify-content:space-between 讓子元素在主軸上兩端對齊
		   - 第一個子元素貼左邊，最後一個貼右邊，中間元素均勻分布
		   - align-items:center 確保所有子元素垂直居中
		   - 常用於導航欄：左側logo，右側功能按鈕
		*/
		.flex-between{
			display:flex;
			justify-content:space-between;
			align-items:center;
		}
		
		/* ==========================================================================
		   視覺效果工具類：提供一致的視覺樣式
		   ==========================================================================
		   ========================================================================== */
		
		/* 圓角工具類：應用統一的圓角樣式
		   - 使用CSS變數 var(--br) 確保整個應用的圓角保持一致
		   - --br變數支持響應式，會根據螢幕大小自動調整
		   - 統一的圓角風格提升視覺和諧度
		*/
		.rounded{
			border-radius:var(--br);
		}
		/* ==========================================================================
		   主要佈局組件：定義頁面的基本結構和導航系統
		   ==========================================================================
		   這些組件構成了應用的骨架，提供一致的佈局和導航體驗
		   ========================================================================== */
		
		/* body元素：整個頁面的根容器
		   - 設定全域字體、顏色和佈局基礎
		   - 現代前端開發的佈局起點
		*/
		body{
			/* 系統字體堆疊：優先使用系統原生字體，提升性能和本地化體驗
			   - -apple-system: macOS和iOS的系統字體(San Francisco)
			   - BlinkMacSystemFont: 舊版macOS的系統字體
			   - "Segoe UI": Windows的現代UI字體
			   - Roboto: Android和Google產品的字體
			   - sans-serif: 通用無襯線字體備胎
			   - 這種漸進式字體選擇確保在所有平台上都有良好的顯示效果
			*/
			font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,sans-serif;
			
			/* 行高：使用CSS變數實現響應式行距
			   - var(--lh)引用之前定義的響應式行高變數
			   - 良好的行高提升文字可讀性，減少閱讀疲勞
			*/
			line-height:var(--lh);
			
			/* 文字顏色：使用主題系統的文字顏色
			   - var(--text)會根據當前主題(明/暗)自動調整
			   - 確保在不同主題下都有足夠的對比度
			*/
			color:var(--text);
			
			/* 背景顏色：使用次要背景色創造層次感
			   - var(--secondary)比主背景稍有變化
			   - 為頁面提供微妙的深度感
			*/
			background:var(--secondary);
			
			/* 頂部內邊距：為固定導航欄留出空間
			   - 60px的空間確保內容不被固定導航欄遮蓋
			   - 這是固定導航欄設計的常見做法
			*/
			padding-top:60px;
			
			/* 最小高度：確保頁面至少佔滿整個視口
			   - 100vh = 視口高度的100%
			   - 避免內容過少時頁面顯得空洞
			   - 為頁尾提供良好的定位基礎
			*/
			min-height:100vh;
			
			/* 過渡動畫：主題切換時的平滑效果
			   - 0.3秒的過渡讓顏色變化更自然
			   - 提升用戶體驗，避免突兀的變化
			*/
			transition:all 0.3s;
		}
		
		/* 主容器：內容的主要包裝器，控制內容寬度和對齊
		   - 響應式設計的核心組件
		   - 在不同螢幕尺寸下提供最佳的內容展示
		*/
		.container{
			/* 最大寬度限制：防止內容在大螢幕上過於分散
			   - 1200px是常見的桌面最佳閱讀寬度
			   - 平衡了內容密度和可讀性
			*/
			max-width:1200px;
			
			/* 居中對齊：使用自動邊距實現水平居中
			   - var(--sp)提供響應式的垂直邊距
			   - auto實現水平居中對齊
			   - 這是CSS佈局中的經典模式
			*/
			margin:var(--sp) auto;
			
			/* 內邊距：為內容提供適當的呼吸空間
			   - 20px確保內容不會緊貼容器邊緣
			   - 在移動端會被媒體查詢覆蓋為響應式值
			*/
			padding:20px;
		}
		
		/* ==========================================================================
		   導航系統：固定導航欄和相關組件
		   ==========================================================================
		   提供持續可見的導航體驗，支持隱藏/顯示動畫
		   ========================================================================== */
		
		/* 主導航欄：應用的核心導航組件
		   - 固定定位確保導航始終可見
		   - 支持主題切換和響應式隱藏
		*/
		.navbar{
			/* 固定定位：導航欄始終停留在頁面頂部
			   - position:fixed脫離正常文檔流
			   - top:0;left:0;right:0 讓導航欄佔滿整個頂部
			   - 需要為body添加padding-top避免內容被遮蓋
			*/
			position:fixed;
			top:0;
			left:0;
			right:0;
			
			/* 半透明背景：現代化的毛玻璃效果
			   - rgba(var(--bg-rgb),0.85)使用預定義的RGB值
			   - 0.85的透明度創造半透明效果
			   - 讓背景內容若隱若現，增加視覺層次
			*/
			background:rgba(var(--bg-rgb),0.85);
			
			/* 陰影效果：提升導航欄的視覺層級
			   - var(--shadow)使用統一的陰影樣式
			   - 讓導航欄看起來"浮"在內容之上
			*/
			box-shadow:var(--shadow);
			
			/* 內邊距：為導航內容提供適當間距
			   - var(--sp)確保響應式間距
			*/
			padding:var(--sp);
			
			/* 層級索引：確保導航欄在最上層
			   - z-index:1000確保導航欄顯示在其他元素之上
			   - 這是一個足夠高的值，避免被其他元素覆蓋
			*/
			z-index:1000;
			
			/* 變換過渡：支持平滑的隱藏/顯示動畫
			   - transform屬性的變化會觸發硬體加速
			   - 0.3秒的持續時間提供流暢的動畫體驗
			*/
			transition:transform 0.3s;
		}
		
		/* 隱藏狀態的導航欄：滾動時隱藏導航以節省空間
		   - 常見於移動端和沉浸式閱讀體驗
		*/
		.navbar.hidden{
			/* 保持顯示：避免display:none造成的佈局跳躍
			   - !important確保此規則不被其他樣式覆蓋
			   - 使用transform而非display提供更流暢的動畫
			*/
			display:block!important;
			
			/* Y軸位移：將導航欄向上移出視口
			   - translateY(-100%)將元素向上移動自身高度的100%
			   - 實現平滑的向上滑出效果
			*/
			transform:translateY(-100%);
		}
		
		/* 導航內容容器：控制導航內容的佈局和對齊
		   - 與.container使用相同的最大寬度保持一致
		*/
		.nav-container{
			/* 最大寬度：與主要內容容器保持一致
			   - 確保導航內容與頁面內容對齊
			*/
			max-width:1200px;
			
			/* 居中對齊：使用自動邊距實現水平居中 */
			margin:0 auto;
			
			/* Flexbox間距：子元素間的統一間距
			   - gap屬性是現代CSS的便利特性
			   - 比使用margin更簡潔和一致
			*/
			gap:var(--sp);
			
			/* Flexbox佈局：創建水平排列的導航項目
			   - display:flex啟用彈性佈局
			   - align-items:center讓所有子元素垂直居中
			*/
			display:flex;
			align-items:center;
		}
		
		/* 導航區域：左右兩側的導航組件容器
		   - 為左右導航區域提供一致的間距設定
		*/
		.nav-left,
		.nav-right{
			/* 統一間距：確保導航組件間的一致間距 */
			gap:var(--sp);
		}
		
		/* 網站標題：品牌標識和主頁連結
		   - 既是品牌展示也是返回主頁的交互元素
		*/
		.nav-title{
			/* 品牌色彩：使用主題主色突出品牌
			   - var(--primary)確保與整體設計系統一致
			*/
			color:var(--primary);
			
			/* 移除鏈接樣式：避免默認的下劃線
			   - text-decoration:none創造更簡潔的外觀
			*/
			text-decoration:none;
			
			/* 字體大小：相對單位確保響應式縮放
			   - 1.3rem比正常文字稍大，突出重要性
			   - rem單位基於根元素字體大小，更具一致性
			*/
			font-size:1.3rem;
			
			/* 字體粗細：加粗強調品牌重要性 */
			font-weight:bold;
			
			/* 指針樣式：表明這是可點擊的交互元素 */
			cursor:pointer;
		}
		/* ==========================================================================
		   互動組件：下拉選單、模態框和各種用戶交互元素
		   ==========================================================================
		   這些組件實現複雜的用戶交互邏輯，包括狀態管理和動畫效果
		   ========================================================================== */
		
		/* 下拉選單容器：相對定位的參考點
		   - 下拉選單系統的基礎組件
		   - 為絕對定位的下拉內容提供定位上下文
		*/
		.dropdown{
			/* 相對定位：為子元素的絕對定位提供參考點
			   - position:relative讓子元素可以相對於此容器定位
			   - 這是下拉選單實現的關鍵
			*/
			position:relative;
			
			/* 層級設定：確保下拉選單在正確的層級上
			   - z-index:1001比導航欄(1000)略高
			   - 確保下拉內容不被其他元素遮蓋
			*/
			z-index:1001;
		}
		/* 下拉觸發按鈕：用戶點擊展開下拉選單的按鈕
		   - 結合按鈕功能和視覺指示
		   - 支持鍵盤和滑鼠操作
		*/
		.dropdown-toggle{
			/* 指針樣式：表明可點擊的交互性 */
			cursor:pointer;
			
			/* 內邊距：提供適當的點擊區域
			   - 0.5rem垂直內邊距確保觸控友好
			   - 水平無內邊距保持緊湊佈局
			*/
			padding:0.5rem 0;
			
			/* Flexbox佈局：水平排列文字和圖標
			   - display:flex創建彈性容器
			   - align-items:center確保垂直居中對齊
			*/
			display:flex;
			align-items:center;
			
			/* 元素間距：文字和下拉箭頭間的距離 */
			gap:0.5rem;
			
			/* 文字顏色：使用主題系統的標準文字色 */
			color:var(--text);
			
			/* 移除按鈕樣式：創造更自然的外觀
			   - background:none移除背景
			   - border:none移除邊框
			   - 讓按鈕看起來像普通文字元素
			*/
			background:none;
			border:none;
			
			/* 字體大小：稍大於正常文字，提升可讀性 */
			font-size:1.1rem;
		}
		/* 下拉箭頭：使用CSS偽元素創建的視覺指示器
		   - ::after偽元素在按鈕文字後添加箭頭
		   - 純CSS實現，無需額外的HTML元素
		*/
		.dropdown-toggle::after{
			/* 內容插入：使用Unicode字符創建下拉箭頭
			   - content屬性是偽元素的核心功能
			   - '▼'字符提供直觀的下拉提示
			*/
			content:'▼';
			
			/* 字體縮放：讓箭頭比文字稍小
			   - 0.8em相對於父元素字體大小的80%
			   - 保持視覺平衡，不過於突出
			*/
			font-size:0.8em;
			
			/* 變換過渡：為旋轉動畫做準備
			   - transform屬性變化時的平滑過渡
			   - 0.3秒的動畫時長提供流暢感受
			*/
			transition:transform 0.3s;
		}
		/* 啟用狀態的下拉箭頭：當下拉選單展開時的視覺反饋
		   - 通過CSS類狀態管理實現交互反饋
		   - JavaScript控制.active類的添加/移除
		*/
		.dropdown-toggle.active::after{
			/* 箭頭旋轉：180度旋轉表示下拉選單已展開
			   - rotate(180deg)將▼變成▲
			   - 直觀地表示狀態變化
			   - 配合transition實現平滑的旋轉動畫
			*/
			transform:rotate(180deg);
		}
		/* 下拉選單內容：下拉選單的主要內容容器
		   - 複雜的定位和動畫系統實現流暢的展開/收起效果
		   - 結合透明度、可見性和變換實現完美的動畫體驗
		*/
		.dropdown-menu{
			/* 固定定位：相對於視口定位而非父元素
			   - position:fixed確保下拉選單不受滾動影響
			   - JavaScript會動態計算和設置位置
			   - 避免在父容器overflow:hidden時被截斷
			*/
			position:fixed;
			
			/* 背景樣式：與主題系統整合的背景設計
			   - var(--bg)確保在不同主題下都有正確的背景色
			   - 提供清晰的內容對比度
			*/
			background:var(--bg);
			
			/* 最小寬度：確保下拉選單有足夠的寬度顯示內容
			   - 160px是常見的下拉選單最小寬度
			   - 平衡了內容可讀性和空間利用率
			*/
			min-width:160px;
			
			/* 陰影效果：創造浮動感和深度層次
			   - var(--shadow)使用統一的陰影樣式
			   - 讓下拉選單看起來懸浮在頁面之上
			*/
			box-shadow:var(--shadow);
			
			/* 圓角設計：保持與整體設計系統的一致性 */
			border-radius:var(--br);
			
			/* 初始透明度：隱藏狀態的透明設置
			   - opacity:0讓元素完全透明但仍佔據空間
			   - 為淡入動畫提供起始狀態
			*/
			opacity:0;
			
			/* 可見性控制：真正的隱藏/顯示控制
			   - visibility:hidden讓元素不可見且不可交互
			   - 與opacity配合實現完美的隱藏效果
			   - 避免隱藏元素仍然可以被點擊的問題
			*/
			visibility:hidden;
			
			/* 初始位移：創造從上方滑入的效果
			   - translateY(-10px)將元素向上偏移10像素
			   - 配合透明度變化創造優雅的出現動畫
			*/
			transform:translateY(-10px);
			
			/* 過渡動畫：所有屬性變化的統一動畫
			   - transition:all 0.3s影響所有可動畫屬性
			   - 透明度、可見性、變換都會平滑過渡
			   - 0.3秒提供適中的動畫速度
			*/
			transition:all 0.3s;
			
			/* 層級設置：確保下拉內容在最上層
			   - z-index:1002比下拉容器(1001)更高
			   - 確保內容不被其他元素遮蓋
			*/
			z-index:1002;
			
			/* 內邊距：為選單項目提供適當的間距
			   - 4px的內邊距讓選項不會緊貼容器邊緣
			   - 提升視覺美感和點擊體驗
			*/
			padding:4px;
		}
		/* 顯示狀態的下拉選單：完全展開時的最終狀態
		   - .show類由JavaScript動態添加/移除
		   - 所有動畫屬性都會從隱藏狀態平滑過渡到顯示狀態
		*/
		.dropdown-menu.show{
			/* 完全不透明：選單完全可見
			   - opacity:1配合transition實現淡入效果
			*/
			opacity:1;
			
			/* 完全可見：選單可見且可交互
			   - visibility:visible讓元素可以接收點擊事件
			   - 與opacity配合完成顯示過程
			*/
			visibility:visible;
			
			/* 歸位變換：選單回到正常位置
			   - translateY(0)取消向上偏移
			   - 配合transition創造向下滑入效果
			*/
			transform:translateY(0);
		}
		/* 下拉選單項目：下拉選單中的個別選項
		   - 每個選項都是獨立的可點擊元素
		   - 提供一致的交互體驗和視覺反饋
		*/
		.dropdown-menu a{
			/* 區塊級顯示：選項佔據整個寬度
			   - display:block讓每個選項独佔一行
			   - 提供更大的點擊區域，提升可用性
			*/
			display:block;
			
			/* 內邊距：為選項文字提供適當的呼吸空間
			   - 0.8rem垂直內邊距確保觸控友好
			   - var(--sp)水平內邊距保持與整體設計一致
			*/
			padding:0.8rem var(--sp);
			
			/* 文字顏色：使用主題系統的標準文字顏色 */
			color:var(--text);
			
			/* 移除連結裝飾：創造清潔的外觀
			   - text-decoration:none移除連結的下劃線
			   - 讓選單項目看起來像按鈕而非連結
			*/
			text-decoration:none;
			
			/* 背景變化動畫：懸停時的平滑過渡
			   - 只對背景顏色變化做動畫
			   - 0.3秒的過渡時間提供適中的反饋速度
			*/
			transition:background 0.3s;
			
			/* 指針樣式：表明這是可點擊的交互元素 */
			cursor:pointer;
			
			/* 圓角設計：與整體設計系統保持一致
			   - 微妙的圓角提升視覺美感
			   - 特別是在懸停狀態下更加明顯
			*/
			border-radius:var(--br);
		}
		/* 懸停狀態的選單項目：滑鼠懸停時的視覺反饋
		   - 提供立即的視覺反饋，讓用戶知道當前選項
		   - 結合背景和文字顏色變化創造強烈的視覺對比
		*/
		.dropdown-menu a:hover{
			/* 背景變化：使用次要背景顏色創造層次感
			   - var(--secondary)提供與主背景的微妙對比
			   - 讓懸停的選項明顯突出
			*/
			background:var(--secondary);
			
			/* 文字顏色變化：使用主題主色強調選中狀態
			   - var(--primary)讓懸停的選項更加引人注目
			   - 與背景變化配合創造強烈的視覺反饋
			*/
			color:var(--primary);
		}
		/* ==========================================================================
		   主題切換按鈕：在明暗主題間切換的交互元素
		   ==========================================================================
		   這個按鈕實現了現代網站的標準功能，提供個性化的閱讀體驗
		   ========================================================================== */
		
		/* 主題切換按鈕：用戶可以在明暗主題間切換
		   - 使用Emoji圖示提供直觀的視覺指示
		   - 支持動畫效果提升交互體驗
		*/
		.theme-toggle{
			/* 移除按鈕預設樣式：創造清潔的外觀
			   - background:none移除按鈕背景
			   - border:none移除按鈕邊框
			   - 讓按鈕看起來像純文字元素
			*/
			background:none;
			border:none;
			
			/* 文字顏色：與主題系統整合的顏色管理 */
			color:var(--text);
			
			/* 字體大小：較大的字體讓Emoji更加明顯
			   - 1.5rem提供足夠的可識別性
			   - 不會過大影響導航欄的整體平衡
			*/
			font-size:1.5rem;
			
			/* 指針樣式：表明這是可交互的元素 */
			cursor:pointer;
			
			/* 內邊距：提供適當的點擊區域
			   - 0.5rem在所有方向提供等同的內邊距
			   - 確保按鈕在移動設備上也容易點擊
			*/
			padding:0.5rem;
			
			/* 變換動畫：為懸停效果做準備
			   - transform屬性的變化會觸發平滑過渡
			   - 0.3秒的持續時間提供恰到好處的動畫效果
			*/
			transition:transform 0.3s;
		}
		/* 懸停狀態的主題切換按鈕：滑鼠懸停時的互動動畫
		   - 這種旋轉動畫提供了有趣且直觀的交互反饋
		   - 表示「切換」的動作，符合用戶的心理預期
		*/
		.theme-toggle:hover{
			/* 360度旋轉：完整的旋轉一圈
			   - rotate(360deg)實現順時針旋轉一圈
			   - 配合transition創造平滑的旋轉動畫
			   - 提供了有趣的視覺反饋，但不會干擾功能
			*/
			transform:rotate(360deg);
		}
		
		/* 內容網格佈局：小說列表的響應式網格系統
		   CSS Grid現代佈局：
		   - display:grid：啟用CSS Grid佈局引擎
		   - repeat(auto-fill, minmax(200px, 1fr))：自動填充列，最小200px，最大1fr
		   - auto-fill：自動計算可容納的列數
		   - minmax()：設定每列的最小和最大寬度
		   - 1fr：剩餘空間的一個份額，確保列寬均勻分佈
		*/
		.content-grid{
			display:grid;                                                    /* 啟用Grid佈局 */
			grid-template-columns:repeat(auto-fill,minmax(200px,1fr));      /* 響應式列定義 */
			gap:var(--sp);                                                   /* 使用統一間距變量 */
		}
		
		/* 小說卡片容器：每個小說的視覺展示單元
		   卡片設計原則：
		   - 固定寬度確保一致性
		   - 柔性高度適應內容
		   - 懸停效果提升互動性
		   - 陰影和圓角營造層次感
		*/
		.content-card{
			width:196px;                    /* 固定寬度，確保網格對齊 */
			background:var(--bg);           /* 使用主題背景色 */
			border-radius:var(--br);        /* 統一的圓角樣式 */
			overflow:hidden;                /* 隱藏超出邊界的內容（如圖片） */
			box-shadow:var(--shadow);       /* 添加陰影增加層次感 */
			transition:all 0.2s;            /* 所有屬性的平滑過渡動畫 */
			cursor:pointer;                 /* 鼠標指針變為手型，表示可點擊 */
			display:flex;                   /* Flexbox佈局 */
			flex-direction:column;          /* 垂直方向排列子元素 */
		}
		
		/* 卡片懸停效果：提升用戶互動體驗
		   微動畫設計：
		   - translateY(-5px)：向上輕微移動
		   - 營造「浮起」的視覺效果
		   - 提供即時的視覺反饋
		*/
		.content-card:hover{
			transform:translateY(-5px);     /* 懸停時向上移動5像素 */
		}
		
		/* 卡片圖片樣式：小說封面的顯示規範
		   圖片處理策略：
		   - 固定尺寸確保佈局一致性
		   - object-fit:cover保持比例並填滿容器
		   - 避免圖片變形或留白
		*/
		.content-card img{
			width:196px;                    /* 與卡片寬度一致 */
			height:280px;                   /* 固定高度，接近書本比例 */
			object-fit:cover;               /* 保持比例，裁切多餘部分 */
		}
		
		/* 卡片信息區域：標題、作者等文字內容的容器
		   彈性佈局設計：
		   - flex:1 佔據剩餘空間
		   - justify-content:space-between 內容兩端對齊
		   - 確保不同長度的內容都有良好的佈局
		*/
		.content-card-info{
			padding:var(--sp);              /* 使用統一的內邊距 */
			background:var(--bg);           /* 確保背景色一致 */
			flex:1;                         /* 佔據卡片中除圖片外的所有空間 */
			display:flex;                   /* Flexbox佈局 */
			flex-direction:column;          /* 垂直排列內容 */
			justify-content:space-between;  /* 內容在垂直方向上分散對齊 */
		}
		
		/* 內容標題樣式：小說標題的排版設計
		   字體層級設計：
		   - 1.1rem：略大於正文的字體大小
		   - font-weight:bold：粗體強調重要性
		   - 使用主題文字顏色
		*/
		.content-title{
			font-size:1.1rem;              /* 標題字體大小 */
			font-weight:bold;               /* 粗體強調 */
			color:var(--text);              /* 主題文字顏色 */
		}
		
		/* 卡片底部信息：作者、更新時間等次要信息
		   信息層級設計：
		   - 較小的字體大小降低視覺權重
		   - 淡化的顏色表示次要信息
		   - 左右分佈式佈局充分利用空間
		*/
		.card-footer{
			display:flex;                   /* Flexbox佈局 */
			justify-content:space-between;  /* 兩端對齊分佈 */
			align-items:center;             /* 垂直居中對齊 */
			margin-top:0.5rem;              /* 與上方內容的間距 */
			font-size:0.8rem;               /* 較小的字體大小 */
			color:var(--text-muted);        /* 淡化的文字顏色 */
		}
		
		/* 小說詳情頁容器：詳情頁面的主要內容區域
		   頁面佈局設計：
		   - 統一的背景色和圓角設計
		   - 充足的內邊距提供良好的閱讀空間
		   - 底部間距避免與其他元素重疊
		*/
		.novel-detail{
			background:var(--bg);           /* 使用主題背景色 */
			border-radius:var(--br);        /* 統一的圓角樣式 */
			padding:2rem;                   /* 充足的內邊距 */
			margin-bottom:2rem;             /* 底部間距 */
		}
		
		/* 小說信息佈局：封面和詳情的網格佈局
		   雙列佈局設計：
		   - 左側固定300px放置封面
		   - 右側彈性空間(1fr)放置文字信息
		   - 2rem間距分隔兩個區域
		*/
		.novel-info{
			display:grid;                   /* CSS Grid佈局 */
			grid-template-columns:300px 1fr;/* 固定+彈性的兩列佈局 */
			gap:2rem;                       /* 列間距 */
		}
		
		/* 小說封面圖片：可點擊的封面展示
		   交互設計：
		   - 100%寬度填滿容器
		   - cursor:pointer表示可點擊
		   - 平滑的變換動畫提升體驗
		   - 同時處理變形和陰影過渡
		*/
		.novel-cover{
			width:100%;                                          /* 填滿容器寬度 */
			border-radius:var(--br);                             /* 統一圓角 */
			cursor:pointer;                                      /* 指示可點擊 */
			transition:transform 0.3s ease,box-shadow 0.3s ease;/* 變形和陰影的平滑過渡 */
		}
		
		/* 封面懸停效果：圖片放大和陰影增強
		   視覺反饋設計：
		   - scale(1.05)：輕微放大5%
		   - 增強陰影營造浮起效果
		   - 提供清晰的互動反饋
		*/
		.novel-cover:hover{
			transform:scale(1.05);                  /* 放大105% */
			box-shadow:0 8px 25px rgba(0,0,0,0.2); /* 增強陰影效果 */
		}
		
		/* 暗色主題封面懸停：針對暗色主題的陰影調整
		   主題適配：
		   - 暗色主題下使用白色陰影
		   - 較低的透明度避免過於刺眼
		   - 保持一致的視覺效果
		*/
		:root[data-theme="dark"] .novel-cover:hover{
			box-shadow:0 8px 25px rgba(255,255,255,0.1); /* 暗色主題下的白色陰影 */
		}
		
		/* 小說標題：詳情頁的主標題樣式
		   字體層級設計：
		   - 2.3rem大字體突出重要性
		   - 底部間距與其他內容分隔
		   - 使用主題文字顏色確保可讀性
		*/
		.novel-title{
			font-size:2.3rem;              /* 大標題字體大小 */
			margin-bottom:var(--sp);        /* 底部間距 */
			color:var(--text);              /* 主題文字顏色 */
		}
		
		/* 小說元數據：作者、類型等基本信息
		   信息展示設計：
		   - 適當的底部間距
		   - 使用主題文字顏色
		   - 為後續內容留出空間
		*/
		.novel-metadata{
			margin-bottom:var(--sp);        /* 底部間距 */
			color:var(--text);              /* 主題文字顏色 */
		}
		
		/* 小說描述：詳細內容的排版
		   文本處理設計：
		   - line-height:1.8 提供舒適的閱讀行距
		   - white-space:pre-line 保持原始換行格式
		   - 頂部間距與元數據區域分隔
		*/
		.novel-description{
			margin-top:var(--sp);           /* 頂部間距 */
			line-height:1.8;                /* 舒適的行距 */
			white-space:pre-line;           /* 保持換行和空格格式 */
		}
		
		/* 來源鏈接：指向原文站點的按鈕樣式
		   按鈕設計：
		   - inline-block允許設置padding和margin
		   - 適當的內邊距營造按鈕感覺
		   - 圓角和背景色統一視覺風格
		   - 移除下劃線保持整潔外觀
		*/
		.source-link{
			display:inline-block;           /* 行內塊元素 */
			padding:0.25rem 0.75rem;        /* 內邊距創造按鈕感 */
			margin-left:0.5rem;             /* 左側間距分隔多個鏈接 */
			border-radius:var(--br);        /* 統一圓角 */
			color:var(--text);              /* 主題文字顏色 */
			background:var(--secondary);    /* 次要背景色 */
			text-decoration:none;           /* 移除超鏈接下劃線 */
			transition:all 0.2s;            /* 所有屬性的平滑過渡 */
		}
		
		/* 來源鏈接懸停效果：強調互動狀態
		   狀態反饋：
		   - 背景色變為主要色彩
		   - 文字變為白色增加對比度
		   - 清晰的視覺狀態變化
		*/
		.source-link:hover{
			background:var(--primary-hover); /* 懸停時的主要背景色 */
			color:#fff;                       /* 白色文字確保對比度 */
		}
		
		/* 章節列表：小說章節的網格展示
		   響應式網格設計：
		   - repeat(auto-fill, minmax(150px, 1fr))：自適應列數
		   - 最小150px寬度確保章節標題可讀性
		   - 自動計算最佳列數填滿空間
		*/
		.chapter-list{
			display:grid;                                               /* CSS Grid佈局 */
			grid-template-columns:repeat(auto-fill,minmax(150px,1fr));  /* 響應式列定義 */
			gap:var(--sp);                                              /* 統一間距 */
			margin-top:2rem;                                            /* 頂部間距分隔 */
		}
		
		/* 章節項目：單個章節的容器樣式
		   卡片式設計：
		   - 次要背景色區分內容
		   - 柔性佈局適應不同長度的標題
		   - 懸停效果提供互動反饋
		   - 垂直排列標題和日期
		*/
		.chapter-item{
			background:var(--secondary);    /* 次要背景色 */
			padding:var(--sp);              /* 統一內邊距 */
			border-radius:var(--br);        /* 統一圓角 */
			cursor:pointer;                 /* 指示可點擊 */
			transition:all 0.2s;            /* 所有屬性平滑過渡 */
			display:flex;                   /* Flexbox佈局 */
			flex-direction:column;          /* 垂直排列子元素 */
			gap:0.5rem;                     /* 子元素間距 */
		}
		
		/* 章節項目懸停效果：強調可點擊狀態
		   互動反饋設計：
		   - 背景變為主要色彩
		   - 文字變白增加對比
		   - 輕微上移營造浮起效果
		*/
		.chapter-item:hover{
			background:var(--primary);      /* 主要背景色 */
			color:#fff;                     /* 白色文字 */
			transform:translateY(-2px);     /* 向上移動2px */
		}
		
		/* 已讀章節標記：視覺區分已讀狀態
		   閱讀進度指示：
		   - opacity:0.5 降低視覺重要性
		   - 淡邊框進一步標識已讀狀態
		   - 保持基本的交互能力
		*/
		.chapter-item.read{
			opacity:0.5;                             /* 半透明顯示 */
			border:1px solid rgba(0,0,0,0.1);       /* 淡色邊框標識 */
		}
		
		/* 已讀章節懸停：覆蓋已讀樣式
		   優先級設計：
		   - !important確保懸停樣式優先
		   - 即使是已讀章節也能正常交互
		   - 保持一致的懸停體驗
		*/
		.chapter-item.read:hover{
			background:var(--primary)!important;    /* 強制應用主要背景色 */
			color:#fff!important;                    /* 強制應用白色文字 */
		}
		
		/* 章節標題：章節名稱的文字樣式
		   層級設計：
		   - font-weight:500 中等粗細突出重要性
		   - flex-grow:1 佔據可用空間
		   - 確保標題是視覺焦點
		*/
		.chapter-title{
			font-weight:500;                /* 中等粗細 */
			flex-grow:1;                    /* 佔據剩餘空間 */
		}
		
		/* 章節日期：更新時間的次要信息
		   次要信息設計：
		   - 較小字體降低視覺權重
		   - 淡化顏色表示次要性
		   - 提供有用的時間參考
		*/
		.chapter-date{
			font-size:0.85rem;              /* 較小字體 */
			color:var(--text-muted);        /* 淡化文字顏色 */
		}
		
		/* 閱讀器容器：章節內容的主要顯示區域
		   閱讀體驗設計：
		   - 使用用戶設定的內容寬度
		   - 居中對齊營造專注的閱讀環境
		   - 充足的邊距避免擁擠感
		   - 陰影和背景創造獨立的閱讀空間
		   - 響應用戶的字體大小偏好
		*/
		.reader-container{
			width:var(--content-width);     /* 用戶設定的內容寬度 */
			margin:4rem auto 5rem;          /* 垂直間距和水平居中 */
			padding:2rem;                   /* 充足的內邊距 */
			background:var(--bg);           /* 主題背景色 */
			border-radius:var(--br);        /* 統一圓角 */
			box-shadow:var(--shadow);       /* 陰影增加層次感 */
			font-size:var(--fs);            /* 用戶設定的字體大小 */
		}
		
		/* 小說內容區域：章節文字的顯示容器
		   閱讀體驗設計：
		   - 底部間距為控制按鈕留出空間
		   - user-select:none 防止意外選中文字
		   - 專注於純粹的閱讀體驗
		*/
		.novel-content{
			margin-bottom:2rem;             /* 與控制按鈕的間距 */
			user-select:none;               /* 禁止文字選擇 */
		}
		
		/* 內容段落樣式：文章段落的間距設計
		   排版優化：
		   - 統一的段落間距
		   - 提供良好的閱讀節奏
		   - 避免文字過於密集
		*/
		.novel-content p{
			margin-bottom:var(--sp);        /* 段落間距 */
		}
		
		/* 內容圖片樣式：章節中插圖的顯示規範
		   圖片處理設計：
		   - max-width:100% 響應式適應容器
		   - height:auto 保持圖片比例
		   - display:block 使圖片成為塊級元素
		   - margin:auto 水平居中顯示
		   - cursor:pointer 指示可點擊放大
		   - 統一的圓角樣式
		*/
		.novel-content img{
			max-width:100%;                 /* 響應式寬度 */
			height:auto;                    /* 保持比例 */
			display:block;                  /* 塊級元素 */
			margin:var(--sp) auto;          /* 垂直間距和水平居中 */
			cursor:pointer;                 /* 指示可點擊 */
			border-radius:var(--br);        /* 統一圓角 */
		}
		
		/* 控制按鈕：閱讀器中的操作按鈕基礎樣式
		   按鈕設計規範：
		   - 適當的內邊距保證點擊區域
		   - 移除默認邊框樣式
		   - 統一的圓角和背景色
		   - 最小寬度確保按鈕尺寸一致性
		   - 平滑的背景色過渡動畫
		*/
		.control-btn{
			padding:0.5rem var(--sp);       /* 垂直和水平內邊距 */
			border:none;                    /* 移除默認邊框 */
			border-radius:var(--br);        /* 統一圓角 */
			background:var(--primary);      /* 主要背景色 */
			color:white;                    /* 白色文字確保對比度 */
			cursor:pointer;                 /* 指示可點擊 */
			min-width:80px;                 /* 最小寬度保證一致性 */
			transition:background 0.2s;     /* 背景色平滑過渡 */
		}
		
		/* 控制按鈕懸停效果：增強互動反饋
		   狀態反饋：
		   - 懸停時背景色加深
		   - 提供清晰的視覺反饋
		   - 增強用戶操作信心
		*/
		.control-btn:hover{
			background:var(--primary-hover); /* 懸停時的深色背景 */
		}
		
		/* 禁用狀態的控制按鈕：無法操作時的視覺反饋
		   無障礙設計：
		   - opacity:0.5 視覺上表示不可用
		   - cursor:not-allowed 明確的禁用指示
		   - 防止無效操作的混淆
		*/
		.control-btn:disabled{
			opacity:0.5;                    /* 半透明表示禁用 */
			cursor:not-allowed;             /* 禁用游標 */
		}
		
		/* 返回按鈕：特殊樣式的導航按鈕
		   特殊設計：
		   - 透明背景與其他按鈕區分
		   - 自動寬度適應內容
		   - 較小的內邊距
		   - 使用主題文字顏色
		   - Flexbox居中對齊圖標和文字
		*/
		.back-btn{
			background:transparent;         /* 透明背景 */
			min-width:auto;                 /* 自動寬度 */
			padding:0.5rem;                 /* 較小內邊距 */
			color:var(--text);              /* 主題文字顏色 */
			display:flex;                   /* Flexbox佈局 */
			align-items:center;             /* 垂直居中對齊 */
		}
		
		/* 返回按鈕懸停效果：保持透明背景
		   一致性設計：
		   - 背景保持透明
		   - 只改變文字顏色
		   - 與透明設計保持一致
		*/
		.back-btn:hover{
			background:transparent;         /* 保持透明背景 */
			color:var(--primary);           /* 主要色彩文字 */
		}
		/* ==========================================================================
		   閱讀器控制欄樣式：固定在螢幕底部的功能控制區域
		   ==========================================================================
		   這個控制欄提供閱讀過程中的核心操作功能，採用現代UI設計原則：
		   1. 固定定位確保始終可見和易於操作
		   2. 半透明背景保持內容可見性同時確保可讀性
		   3. 平滑動畫提升用戶體驗
		   4. Flexbox佈局確保響應式設計
		   ========================================================================== */
		.reader-controls{
			/* 半透明背景：既保持控制欄可讀性又不完全遮擋內容
			   - rgba(var(--bg-rgb), 0.85)：使用CSS自定義屬性創建85%不透明度的背景
			   - 0.85的透明度是UI設計的最佳實踐，既能看清控制項又不會干擾閱讀
			   - 使用CSS變數確保與主題系統一致性
			*/
			background:rgba(var(--bg-rgb),0.85);
			
			/* 固定定位：讓控制欄始終位於螢幕底部
			   - position:fixed讓元素脫離文檔流，相對於視口定位
			   - 這確保無論頁面如何滾動，控制欄都保持在可見位置
			   - 對於閱讀體驗而言，這是關鍵的可用性設計
			*/
			position:fixed;
			
			/* 底部對齊：將控制欄固定在螢幕最底部
			   - bottom:0確保控制欄緊貼螢幕底部
			   - 這是移動優先設計的體現，手指最容易觸及的區域
			*/
			bottom:0;
			
			/* 水平全寬：讓控制欄橫跨整個螢幕寬度
			   - left:0和right:0讓元素從左到右完全拉伸
			   - 這種方式比width:100%更加可靠，避免了盒模型問題
			*/
			left:0;
			right:0;
			
			/* 內邊距：為控制項提供適當的空間
			   - var(--sp)使用統一的間距變數，保持設計一致性
			   - 適當的內邊距確保觸控友好的操作空間
			*/
			padding:var(--sp);
			
			/* Flexbox佈局：創建靈活的按鈕排列
			   - display:flex啟用Flexbox容器
			   - 為響應式按鈕佈局提供基礎
			*/
			display:flex;
			
			/* 中心對齊：讓控制按鈕在水平方向居中顯示
			   - justify-content:center確保按鈕組合居中對齊
			   - 這創造了平衡和專業的視覺效果
			*/
			justify-content:center;
			
			/* 按鈕間距：控制項之間的統一間距
			   - gap:var(--sp)在flex項目間創建一致的間距
			   - 比使用margin更簡潔和可維護
			*/
			gap:var(--sp);
			
			/* 平滑動畫：為顯示/隱藏狀態提供過渡效果
			   - transition:transform 0.3s為變換屬性添加300ms過渡
			   - 0.3s是UI動畫的標準時長，既明顯又不會感覺緩慢
			   - 主要用於配合隱藏功能的滑動效果
			*/
			transition:transform 0.3s;
			
			/* 層級控制：確保控制欄顯示在其他內容之上
			   - z-index:1000設定較高的堆疊順序
			   - 確保控制欄不會被其他浮動元素遮擋
			*/
			z-index:1000;
		}
		/* 控制欄隱藏狀態：實現平滑的隱藏動畫效果
		   這個狀態用於沉浸式閱讀模式，當用戶想要專注於內容時隱藏控制欄
		*/
		.reader-controls.hidden{
			/* 強制顯示flex佈局：確保動畫效果正常運作
			   - display:flex!important強制覆蓋任何可能的顯示設定
			   - !important在這裡是必要的，因為隱藏動畫需要元素保持在DOM中
			   - 不能使用display:none，因為這會中斷CSS過渡動畫
			*/
			display:flex!important;
			
			/* Y軸平移動畫：將控制欄向下滑出螢幕
			   - transform:translateY(100%)將元素向下移動自身高度的100%
			   - 100%相對於元素自身高度，確保完全滑出視野
			   - 配合transition屬性產生平滑的滑動效果
			   - 這種隱藏方式比淡出更直觀和現代
			*/
			transform:translateY(100%);
		}
		/* 閱讀器標題樣式：控制欄中的章節標題顯示區域 */
		.reader-title{
			/* 文字居中對齊：讓章節標題在控制欄中央顯示
			   - text-align:center確保標題文字水平居中
			   - 提供視覺平衡，讓用戶清楚知道當前閱讀位置
			*/
			text-align:center;
			
			/* Flex彈性增長：讓標題佔據按鈕之間的所有剩餘空間
			   - flex-grow:1讓這個元素擴展填滿父容器的剩餘空間
			   - 確保無論標題長短，按鈕都能維持在兩側的固定位置
			   - 這種設計讓控制欄佈局更加靈活和美觀
			*/
			flex-grow:1;
		}
		/* ==========================================================================
		   設定模態框樣式：閱讀器功能設定的彈出式界面
		   ==========================================================================
		   這個模態框提供閱讀設定功能，採用現代模態設計原則：
		   1. 固定定位確保覆蓋在所有內容之上
		   2. 滑動動畫提供流暢的用戶體驗
		   3. 響應式尺寸適應不同螢幕大小
		   4. 完整的主題整合和可訪問性支持
		   ========================================================================== */
		.settings-modal{
			/* 固定定位：讓模態框相對於視口定位
			   - position:fixed脫離文檔流，始終相對於瀏覽器視口定位
			   - 確保模態框不會被頁面滾動影響，始終保持在正確位置
			*/
			position:fixed;
			
			/* 垂直定位：在控制欄上方顯示
			   - bottom:60px讓模態框顯示在底部控制欄上方
			   - 60px的間距確保不會與控制欄重疊，提供視覺分離
			*/
			bottom:60px;
			
			/* 水平居中：使用CSS Transform技術實現精確居中
			   - left:50%將元素左邊緣移動到視口中心
			   - 這是實現水平居中的第一步
			*/
			left:50%;
			
			/* 變換居中和隱藏狀態：組合變換實現居中和動畫效果
			   - translate(-50%, 200%)組合了兩個變換：
			   - -50%：向左移動自身寬度的一半，配合left:50%實現完美居中
			   - 200%：向下移動自身高度的兩倍，創建隱藏狀態
			   - 這種方法讓模態框從下方滑入，提供自然的動畫效果
			*/
			transform:translate(-50%,200%);
			
			/* 固定寬度：為設定內容提供合適的空間
			   - width:300px提供適中的寬度，既不會太擠也不會太寬
			   - 300px是模態框的標準寬度，適合大多數設定選項
			   - 在移動端會通過媒體查詢進行響應式調整
			*/
			width:300px;
			
			/* 主題背景：使用主題系統的背景色
			   - var(--bg)確保模態框背景與當前主題一致
			   - 在明亮和深色主題間自動切換
			*/
			background:var(--bg);
			
			/* 邊框設計：使用主題系統的邊框樣式
			   - 1px solid var(--border)創建細緻的邊框
			   - 邊框幫助定義模態框邊界，提升視覺層次
			*/
			border:1px solid var(--border);
			
			/* 圓角設計：使用統一的圓角半徑
			   - var(--br)應用主題設定的圓角半徑
			   - 創造現代和友好的視覺效果
			*/
			border-radius:var(--br);
			
			/* 內邊距：為模態框內容提供舒適的空間
			   - 1.5rem提供充足的內部空間，確保內容不會貼邊
			   - 比標準間距稍大，因為模態框需要更多的視覺呼吸空間
			*/
			padding:1.5rem;
			
			/* 文字顏色：使用主題系統的文字色彩
			   - var(--text)確保文字顏色與主題一致
			   - 在不同主題間提供適當的對比度
			*/
			color:var(--text);
			
			/* 層級控制：確保模態框顯示在所有其他內容之上
			   - z-index:1000與控制欄相同的層級
			   - 確保模態框不會被其他界面元素遮擋
			*/
			z-index:1000;
			
			/* 動畫過渡：為顯示/隱藏提供平滑動畫
			   - transition:transform 0.3s為transform屬性添加過渡效果
			   - 0.3s的時長提供適當的動畫速度，既明顯又不會太慢
			*/
			transition:transform 0.3s;
			
			/* 最大高度限制：防止模態框在小螢幕上過高
			   - max-height:60vh限制最大高度為視口高度的60%
			   - 確保在任何螢幕尺寸下都不會超出可視範圍
			   - 60%是一個平衡點，既提供足夠空間又保持可用性
			*/
			max-height:60vh;
			
			/* Flexbox佈局：創建垂直排列的模態框結構
			   - display:flex啟用彈性盒模型
			   - 為模態框頭部、內容和按鈕區域提供靈活佈局
			*/
			display:flex;
			
			/* 垂直排列：將模態框內容從上到下排列
			   - flex-direction:column設定主軸為垂直方向
			   - 確保標題、內容和控制項按邏輯順序顯示
			*/
			flex-direction:column;
			
			/* 陰影效果：增加模態框的視覺深度
			   - var(--shadow)使用主題系統的陰影設定
			   - 陰影讓模態框看起來浮在內容之上，增強層次感
			*/
			box-shadow:var(--shadow);
		}
		/* 設定模態框活躍狀態：顯示動畫的最終位置 */
		.settings-modal.active{
			/* 顯示位置變換：將模態框移動到最終顯示位置
			   - translate(-50%, 0)移除Y軸偏移，只保留居中對齊
			   - -50%確保水平居中對齊
			   - 0表示垂直位置回到原點，讓模態框完全顯示
			   - 配合transition屬性創建從下方滑入的動畫效果
			*/
			transform:translate(-50%,0);
		}
		/* 設定模態框頭部樣式：標題區域的視覺設計 */
		.settings-modal-header{
			/* 頭部內邊距：只在底部添加間距
			   - padding:0 0 var(--sp) 0設定四個方向的內邊距
			   - 上、左、右為0，只有底部有間距
			   - var(--sp)確保與整體設計系統的間距一致
			   - 這種設計讓標題緊貼模態框頂部，看起來更整潔
			*/
			padding:0 0 var(--sp) 0;
			
			/* 底部分隔線：視覺上分離標題和內容區域
			   - border-bottom:1px solid var(--border)添加細線分隔
			   - 1px細線不會過於突兀，只是輕微的視覺分隔
			   - var(--border)使用主題系統的邊框顏色，確保一致性
			*/
			border-bottom:1px solid var(--border);
			
			/* 粗體字重：讓標題更突出和重要
			   - font-weight:bold讓標題文字更加醒目
			   - 強調這是模態框的主要標識
			*/
			font-weight:bold;
			
			/* 文字居中：創造平衡的視覺效果
			   - text-align:center讓標題在頭部區域居中顯示
			   - 提供對稱和專業的外觀
			*/
			text-align:center;
			
			/* 背景色設定：確保頭部背景與模態框一致
			   - var(--bg)使用主題系統的背景色
			   - 在某些情況下確保頭部不會透明或繼承其他顏色
			*/
			background:var(--bg);
		}
		/* 設定組容器樣式：可滾動的設定選項區域 */
		.settings-group{
			/* 垂直滾動：當內容超出高度時提供滾動功能
			   - overflow-y:auto只在需要時顯示垂直滾動條
			   - 這確保所有設定選項都可以訪問，即使在小螢幕上
			   - 水平方向保持默認，避免不必要的水平滾動
			*/
			overflow-y:auto;
			
			/* Flex擴展：佔據模態框的剩餘空間
			   - flex:1讓這個區域擴展填滿頭部和按鈕區之間的所有空間
			   - 這確保設定內容區域最大化利用可用空間
			   - 是flex-grow:1、flex-shrink:1、flex-basis:0的簡寫
			*/
			flex:1;
			
			/* 清除外邊距：避免不必要的間距
			   - margin:0移除所有外邊距
			   - 讓設定組緊密貼合容器邊界
			   - 間距通過padding控制更精確
			*/
			margin:0;
			
			/* 垂直內邊距：為設定內容提供適當間距
			   - padding:var(--sp) 0只在上下方向添加內邊距
			   - 左右保持0，讓內容可以充分利用寬度
			   - var(--sp)確保間距與設計系統一致
			*/
			padding:var(--sp) 0;
		}
		/* 設定組標籤樣式：設定項目的描述文字 */
		.settings-group label{
			/* 塊級顯示：讓標籤獨佔一行
			   - display:block讓標籤元素表現為塊級元素
			   - 確保每個設定項目的標籤都在獨立的行上
			   - 提供更好的可讀性和點擊目標
			*/
			display:block;
			
			/* 底部間距：標籤和控制項之間的分隔
			   - margin-bottom:0.5rem在標籤下方添加適中的間距
			   - 0.5rem提供足夠的視覺分離，不會太緊湊也不會太分散
			   - 讓用戶清楚知道標籤對應的控制項
			*/
			margin-bottom:0.5rem;
			
			/* 文字顏色：使用主題系統的文字色彩
			   - var(--text)確保標籤文字與主題一致
			   - 在明亮和深色主題間自動調整顏色
			*/
			color:var(--text);
		}
		/* 範圍滑桿樣式：用於數值設定的滑動控制項 */
		.settings-group input[type="range"]{
			/* 全寬顯示：讓滑桿佔滿容器寬度
			   - width:100%確保滑桿充分利用可用空間
			   - 提供更大的操作區域，特別在移動端更容易操控
			   - 視覺上更平衡和專業
			*/
			width:100%;
			
			/* 主題色彩：自定義滑桿的強調色
			   - accent-color:var(--primary)設定滑桿的主要顏色
			   - 讓滑桿的選中部分使用主題的主色調
			   - 這是CSS的新特性，提供原生控制項的主題化
			*/
			accent-color:var(--primary);
		}
		
		/* 複選框樣式：用於布爾設定的勾選控制項 */
		.settings-group input[type="checkbox"]{
			/* 右側間距：複選框和標籤文字之間的分隔
			   - margin-right:0.5rem在複選框右側添加適當間距
			   - 確保複選框和對應文字有足夠的視覺分離
			   - 提升可讀性和點擊準確性
			*/
			margin-right:0.5rem;
			
			/* 主題色彩：自定義複選框的強調色
			   - accent-color:var(--primary)讓勾選狀態使用主題色
			   - 保持整體設計的一致性
			   - 現代瀏覽器支持的原生控制項主題化
			*/
			accent-color:var(--primary);
		}
		/* 設定模態框中的章節項目樣式：章節選擇列表的項目外觀 */
		.settings-modal .chapter-item{
			/* 次要背景色：使用較淡的背景色區分章節項目
			   - var(--secondary)使用主題系統的次要色
			   - 提供比主背景稍深的色調，增加視覺層次
			   - 讓章節項目在列表中更容易識別
			*/
			background:var(--secondary);
			
			/* 內邊距：為章節內容提供舒適的空間
			   - padding:0.8rem為章節文字提供適當的內部空間
			   - 0.8rem的值確保項目有足夠的觸控目標大小
			   - 在移動端和桌面端都提供良好的交互體驗
			*/
			padding:0.8rem;
			
			/* 圓角設計：使用統一的圓角風格
			   - var(--br)應用主題設定的圓角半徑
			   - 與整體設計語言保持一致
			   - 創造現代和友好的外觀
			*/
			border-radius:var(--br);
			
			/* 指針光標：表示項目可以點擊
			   - cursor:pointer在滑鼠懸停時顯示手型光標
			   - 明確向用戶傳達這是可交互的元素
			   - 提升用戶體驗的重要細節
			*/
			cursor:pointer;
			
			/* 平滑過渡：為所有屬性變化添加動畫效果
			   - transition:all 0.2s為所有CSS屬性添加200ms過渡
			   - 0.2s是快速但明顯的動畫時長，適合交互反饋
			   - 讓懸停和點擊狀態變化更加平滑
			*/
			transition:all 0.2s;
			
			/* 項目間距：章節項目之間的垂直分隔
			   - margin-bottom:0.5rem在每個項目下方添加間距
			   - 確保章節列表有良好的可讀性和視覺組織
			*/
			margin-bottom:0.5rem;
			
			/* 透明邊框：為懸停狀態預留邊框空間
			   - border:1px solid transparent設定透明邊框
			   - 預防在添加實際邊框時導致的佈局跳動
			   - 這是CSS動畫最佳實踐，保持元素尺寸穩定
			*/
			border:1px solid transparent;
		}
		/* 當前章節高亮樣式（明亮主題）：標示目前正在閱讀的章節 */
		.settings-modal .chapter-item.current{
			/* 明亮藍色背景：在明亮主題中突出當前章節
			   - #bbdefb是淺藍色，與Material Design的藍色調色板一致
			   - !important確保這個樣式覆蓋默認的章節項目背景
			   - 提供清晰的視覺標識，讓用戶知道當前位置
			*/
			background:#bbdefb!important;
			
			/* 深色文字：確保在淺藍背景上有足夠對比度
			   - color:#000使用純黑色文字
			   - !important覆蓋默認的文字顏色設定
			   - 在淺色背景上深色文字提供最佳可讀性
			*/
			color:#000!important;
		}
		
		/* 當前章節高亮樣式（深色主題）：深色主題下的當前章節標示 */
		:root[data-theme="dark"] .settings-modal .chapter-item.current{
			/* 深藍色背景：在深色主題中突出當前章節
			   - #1976d2是較深的藍色，適合深色主題環境
			   - !important確保覆蓋預設和明亮主題的設定
			   - 與深色背景形成良好對比，同時保持品牌色彩
			*/
			background:#1976d2!important;
			
			/* 白色文字：在深藍背景上確保清晰可讀
			   - color:#fff使用純白色文字
			   - !important覆蓋其他文字顏色設定
			   - 在深色背景上白色文字提供最佳對比度
			*/
			color:#fff!important;
		}
		/* ==========================================================================
		   燈箱樣式：圖片放大檢視的全螢幕遮罩層
		   ==========================================================================
		   燈箱是現代Web應用中常見的圖片檢視組件，提供沉浸式的圖片瀏覽體驗：
		   1. 全螢幕覆蓋確保用戶專注於圖片內容
		   2. 深色半透明背景突出圖片並減少干擾
		   3. 居中對齊提供最佳的檢視效果
		   4. 平滑動畫增強用戶體驗
		   ========================================================================== */
		.lightbox{
			/* 全螢幕固定定位：覆蓋整個視口
			   - position:fixed讓燈箱相對於瀏覽器視口定位
			   - 確保無論頁面如何滾動，燈箱都保持固定位置
			   - 這是實現模態覆蓋層的標準方法
			*/
			position:fixed;
			
			/* 全視口覆蓋：使用現代CSS語法填滿整個螢幕
			   - inset:0是top:0; right:0; bottom:0; left:0的簡寫
			   - 確保燈箱覆蓋整個瀏覽器視口
			   - 比傳統的四個方向設定更簡潔
			*/
			inset:0;
			
			/* 深色半透明背景：突出圖片內容並減少背景干擾
			   - rgba(0,0,0,0.9)創建90%不透明度的黑色背景
			   - 0.9的透明度足夠暗以突出圖片，但仍能隱約看到背景
			   - 黑色背景是圖片檢視的最佳選擇，提供中性環境
			*/
			background:rgba(0,0,0,0.9);
			
			/* 默認隱藏：初始狀態不顯示燈箱
			   - display:none完全隱藏元素，不佔用任何空間
			   - 通過JavaScript切換為display:flex來顯示
			   - 這種方式比visibility更徹底
			*/
			display:none;
			
			/* 水平居中：Flexbox水平對齊
			   - justify-content:center在主軸（水平）方向居中對齊
			   - 確保圖片在燈箱中水平居中顯示
			*/
			justify-content:center;
			
			/* 垂直居中：Flexbox垂直對齊
			   - align-items:center在交叉軸（垂直）方向居中對齊
			   - 確保圖片在燈箱中垂直居中顯示
			   - 組合justify-content和align-items實現完美居中
			*/
			align-items:center;
			
			/* 最高層級：確保燈箱顯示在所有其他內容之上
			   - z-index:2000設定非常高的堆疊順序
			   - 比設定模態框(1000)更高，確保燈箱在最頂層
			   - 避免被任何其他界面元素遮擋
			*/
			z-index:2000;
			
			/* 初始透明度：為淡入動畫做準備
			   - opacity:0設定初始狀態為完全透明
			   - 配合transition創建淡入淡出效果
			   - 比直接顯示/隱藏更加優雅
			*/
			opacity:0;
			
			/* 透明度過渡：平滑的顯示/隱藏動畫
			   - transition:opacity 0.3s為透明度變化添加300ms過渡
			   - 0.3s提供適當的動畫時長，既明顯又不會太慢
			   - 創造專業的用戶體驗
			*/
			transition:opacity 0.3s;
		}
		/* 燈箱活躍狀態：顯示燈箱時的樣式 */
		.lightbox.active{
			/* 顯示Flexbox：啟用燈箱的彈性佈局
			   - display:flex從隱藏狀態切換到顯示狀態
			   - 重新啟用justify-content和align-items的居中對齊
			   - 讓燈箱內容可以正確排列和居中
			*/
			display:flex;
			
			/* 完全不透明：顯示完整的燈箱效果
			   - opacity:1讓燈箱從透明變為完全可見
			   - 配合transition屬性產生淡入動畫效果
			   - 創造平滑的視覺轉換
			*/
			opacity:1;
		}
		
		/* 燈箱內容容器：圖片的直接包裝容器 */
		.lightbox-content{
			/* 相對定位：為絕對定位的關閉按鈕提供參考點
			   - position:relative讓子元素可以相對於此容器定位
			   - 主要用於定位右上角的關閉按鈕
			*/
			position:relative;
			
			/* 最大寬度限制：防止圖片在寬螢幕上過大
			   - max-width:95%限制內容寬度為視口寬度的95%
			   - 5%的邊距確保圖片不會完全貼邊，保持視覺呼吸空間
			   - 在超寬螢幕上防止圖片過度拉伸
			*/
			max-width:95%;
			
			/* 最大高度限制：防止圖片在高螢幕上過大
			   - max-height:85vh限制內容高度為視口高度的85%
			   - 85%確保圖片不會佔滿整個螢幕，為關閉按鈕留出空間
			   - vh單位確保響應式適應不同螢幕高度
			*/
			max-height:85vh;
		}
		/* 燈箱圖片樣式：圖片的顯示和適配設定 */
		.lightbox img{
			/* 最大寬度限制：圖片不超出容器寬度
			   - max-width:100%確保圖片不會超出父容器寬度
			   - 保持圖片在容器內完整顯示
			   - 響應式圖片的基本設定
			*/
			max-width:100%;
			
			/* 最大高度限制：圖片不超出視口高度
			   - max-height:85vh與容器設定一致
			   - 85vh確保圖片適合螢幕高度，留出操作空間
			   - vh單位提供視口相對的響應式高度
			*/
			max-height:85vh;
			
			/* 圖片適配模式：保持比例並完整顯示圖片
			   - object-fit:contain確保整張圖片都可見
			   - 保持圖片原始比例，不會裁切任何部分
			   - 如果圖片比例與容器不符，會在兩側留白
			   - 這是圖片檢視器的最佳選擇，確保用戶看到完整圖片
			*/
			object-fit:contain;
		}
		
		/* 燈箱關閉按鈕樣式：用戶關閉燈箱的交互按鈕 */
		.close-lightbox{
			/* 絕對定位：相對於父容器(.lightbox-content)定位
			   - position:absolute讓按鈕脫離文檔流
			   - 可以精確控制按鈕在容器中的位置
			*/
			position:absolute;
			
			/* 垂直定位：在內容容器上方顯示
			   - top:-40px將按鈕向上偏移40像素
			   - 負值讓按鈕顯示在圖片上方，不遮擋圖片內容
			   - 40px提供足夠的空間容納按鈕和必要的間距
			*/
			top:-40px;
			
			/* 水平定位：靠右對齊
			   - right:0讓按鈕貼齊容器右邊緣
			   - 符合用戶對關閉按鈕位置的期望（右上角）
			*/
			right:0;
			
			/* 白色文字：在深色背景上確保可見性
			   - color:white在黑色燈箱背景上提供最佳對比度
			   - 確保關閉按鈕清晰可見
			*/
			color:white;
			
			/* 大號字體：確保按鈕足夠醒目和易於點擊
			   - font-size:24px提供適當的按鈕大小
			   - 24px在桌面和移動端都有良好的可點擊性
			*/
			font-size:24px;
			
			/* 指針光標：表示可點擊的交互元素
			   - cursor:pointer向用戶明確傳達這是可點擊的按鈕
			   - 提升用戶體驗的重要細節
			*/
			cursor:pointer;
			
			/* 移除背景：讓按鈕與深色背景融合
			   - background:none移除默認的按鈕背景
			   - 創造乾淨的視覺效果
			*/
			background:none;
			
			/* 移除邊框：創造極簡的按鈕外觀
			   - border:none移除默認的按鈕邊框
			   - 讓按鈕看起來像純文字圖標
			*/
			border:none;
			
			/* 內邊距：增加按鈕的點擊區域
			   - padding:8px為按鈕提供適當的觸控目標大小
			   - 8px在文字周圍創造足夠的點擊空間
			   - 改善移動端的可用性
			*/
			padding:8px;
		}
		/* ==========================================================================
		   載入遮罩樣式：全螢幕載入狀態指示器
		   ==========================================================================
		   載入遮罩用於在異步操作期間向用戶顯示載入狀態，採用現代UX設計原則：
		   1. 全螢幕覆蓋阻止用戶其他操作，專注於載入過程
		   2. 半透明背景維持上下文可見性
		   3. 居中的載入動畫提供清晰的視覺反饋
		   4. 最高層級確保載入狀態始終可見
		   ========================================================================== */
		.loading-overlay{
			/* 全螢幕固定定位：覆蓋整個視口並阻止交互
			   - position:fixed讓遮罩相對於瀏覽器視口定位
			   - 確保無論頁面滾動狀態如何，遮罩都保持固定位置
			   - 這是實現全局載入狀態的標準方法
			*/
			position:fixed;
			
			/* 全視口覆蓋：使用現代CSS語法填滿整個螢幕
			   - inset:0簡潔地設定top:0; right:0; bottom:0; left:0
			   - 確保載入遮罩覆蓋整個可視區域
			   - 完全阻止用戶與底層內容的交互
			*/
			inset:0;
			
			/* 半透明深色背景：突出載入指示器同時保持上下文
			   - rgba(0,0,0,0.7)創建70%不透明度的黑色背景
			   - 0.7的透明度足夠暗以突出載入動畫，但仍能看到背景內容
			   - 這讓用戶知道系統正在處理，而不是完全凍結
			*/
			background:rgba(0,0,0,0.7);
			
			/* 默認隱藏：初始狀態不顯示載入遮罩
			   - display:none完全隱藏元素，不佔用任何空間
			   - 通過JavaScript切換為display:flex來顯示載入狀態
			   - 這種方式比visibility更徹底，完全移除元素的影響
			*/
			display:none;
			
			/* 水平居中：Flexbox水平對齊載入指示器
			   - justify-content:center在主軸（水平）方向居中對齊
			   - 確保載入動畫在螢幕中央水平居中顯示
			*/
			justify-content:center;
			
			/* 垂直居中：Flexbox垂直對齊載入指示器
			   - align-items:center在交叉軸（垂直）方向居中對齊
			   - 確保載入動畫在螢幕中央垂直居中顯示
			   - 組合實現完美的居中對齊效果
			*/
			align-items:center;
			
			/* 最高層級：確保載入遮罩顯示在所有其他內容之上
			   - z-index:9999設定極高的堆疊順序
			   - 比燈箱(2000)和設定模態框(1000)都更高
			   - 確保載入狀態永遠不會被其他元素遮擋
			*/
			z-index:9999;
		}
		
		/* 載入遮罩顯示狀態：啟動載入指示器時的樣式 */
		.loading-overlay.show{
			/* 顯示Flexbox：啟用載入遮罩的彈性佈局
			   - display:flex從隱藏狀態切換到顯示狀態
			   - 重新啟用justify-content和align-items的居中對齊
			   - 讓載入指示器正確顯示在螢幕中央
			*/
			display:flex;
		}
		/* 載入旋轉動畫：經典的圓形旋轉載入指示器 */
		.loading-spinner{
			/* 固定尺寸：設定旋轉器的寬度和高度
			   - width:50px, height:50px創建50x50像素的正方形
			   - 這個尺寸在各種螢幕上都有良好的可見性
			   - 不會太大干擾用戶，也不會太小看不清
			*/
			width:50px;
			height:50px;
			
			/* 基礎圓環：創建旋轉器的主體結構
			   - border:4px solid rgba(255,255,255,0.3)創建半透明白色邊框
			   - 4px的邊框寬度提供適當的視覺重量
			   - rgba(255,255,255,0.3)是30%不透明度的白色，作為背景軌道
			*/
			border:4px solid rgba(255,255,255,0.3);
			
			/* 高亮指示器：創建旋轉的活躍部分
			   - border-top:4px solid white覆蓋頂部邊框為純白色
			   - 這創造了一個部分高亮的圓環效果
			   - 旋轉時這個白色部分會繞圈移動，形成載入動畫
			*/
			border-top:4px solid white;
			
			/* 圓形形狀：將正方形轉換為圓形
			   - border-radius:50%將正方形的四個角完全圓化
			   - 50%是創建完美圓形的標準值
			   - 這是CSS創建圓形元素的經典技巧
			*/
			border-radius:50%;
			
			/* 無限旋轉動畫：應用旋轉動畫效果
			   - animation:spin 1s linear infinite應用自定義的旋轉動畫
			   - spin是動畫名稱（在@keyframes中定義）
			   - 1s是完成一圈的時間，適中的速度
			   - linear確保勻速旋轉，無加速或減速
			   - infinite讓動畫無限循環，直到載入完成
			*/
			animation:spin 1s linear infinite;
		}
		
		/* 載入文字樣式：載入動畫下方的說明文字 */
		.loading-text{
			/* 白色文字：在深色背景上確保清晰可讀
			   - color:white在半透明黑色背景上提供最佳對比度
			   - 確保載入文字清晰可見
			*/
			color:white;
			
			/* 上方間距：載入動畫和文字之間的分隔
			   - margin-top:var(--sp)在載入文字上方添加標準間距
			   - var(--sp)確保間距與設計系統一致
			   - 提供視覺分離，讓載入動畫和文字各自清晰
			*/
			margin-top:var(--sp);
			
			/* 適中字體：提供良好的可讀性
			   - font-size:1.1rem稍大於基本文字尺寸
			   - 1.1rem確保載入文字足夠醒目但不會過於突出
			   - 在載入狀態下提供清晰的信息傳達
			*/
			font-size:1.1rem;
		}
		/* ==========================================================================
		   CSS關鍵幀動畫：旋轉載入動畫的定義
		   ==========================================================================
		   這個關鍵幀動畫定義了載入指示器的旋轉行為，創造平滑的視覺反饋
		   ========================================================================== */
		@keyframes spin{
			/* 動畫起點：0%時的狀態
			   - 0%表示動畫開始時的狀態
			   - transform:rotate(0deg)設定初始旋轉角度為0度
			   - 這是載入動畫的起始點，元素處於原始位置
			*/
			0%{transform:rotate(0deg)}
			
			/* 動畫終點：100%時的狀態
			   - 100%表示動畫結束時的狀態
			   - transform:rotate(360deg)設定最終旋轉角度為360度
			   - 360度正好是一個完整的圓，元素回到視覺上的起始位置
			   - 配合infinite屬性，這創造了無縫循環的旋轉效果
			*/
			100%{transform:rotate(360deg)}
		}
		/* ==========================================================================
		   頁面狀態控制樣式：根據當前頁面隱藏不相關的組件
		   ==========================================================================
		   這組樣式實現了單頁應用的頁面狀態管理，確保每個頁面只顯示相關內容：
		   1. 透過CSS類控制組件的顯示和隱藏
		   2. 避免JavaScript頻繁操作DOM，提升性能
		   3. 確保頁面間的視覺分離和專注性
		   4. 簡化頁面邏輯，讓每個頁面有清晰的用途
		   ========================================================================== */
		
		/* 首頁列表狀態：隱藏非列表頁面的組件 */
		.page-list .reader-container,    /* 隱藏閱讀器容器，首頁不需要閱讀功能 */
		.page-list .novel-detail,        /* 隱藏小說詳情，首頁專注於列表展示 */
		.page-list .reader-controls,     /* 隱藏閱讀控制欄，列表頁無需閱讀控制 */
		.page-list .settings-modal,      /* 隱藏設定模態框，列表頁不提供閱讀設定 */
		
		/* 詳情頁狀態：隱藏非詳情頁面的組件 */
		.page-detail .content-grid,      /* 隱藏內容網格，詳情頁專注於單一小說 */
		.page-detail .reader-container,  /* 隱藏閱讀器容器，詳情頁只顯示章節列表 */
		.page-detail .reader-controls,   /* 隱藏閱讀控制欄，詳情頁無需閱讀控制 */
		.page-detail .settings-modal,    /* 隱藏設定模態框，詳情頁不提供閱讀設定 */
		
		/* 閱讀器頁面狀態：隱藏非閱讀功能的組件 */
		.page-reader .content-grid,      /* 隱藏內容網格，閱讀頁專注於文字內容 */
		.page-reader .novel-detail{      /* 隱藏小說詳情，閱讀頁只顯示章節內容 */
			/* 完全隱藏：從視覺和佈局中完全移除這些元素
			   - display:none讓這些組件完全不佔用空間
			   - 這比visibility:hidden更徹底，完全移除佈局影響
			   - 提升頁面性能，減少不必要的渲染計算
			   - 確保每個頁面都有清晰的功能專注性
			*/
			display:none;
		}
		/* 頁面底部樣式：網站的頁腳區域 */
		footer{
			/* 文字居中：讓底部信息在頁面中央對齊
			   - text-align:center確保頁腳內容水平居中顯示
			   - 創造平衡和專業的頁面底部效果
			   - 適合放置版權信息、連結等次要內容
			*/
			text-align:center;
			
			/* 標準內邊距：為頁腳內容提供適當的空間
			   - var(--sp)使用統一的間距變數
			   - 確保頁腳與設計系統的間距保持一致
			   - 提供舒適的視覺呼吸空間
			*/
			padding:var(--sp);
			
			/* 主題背景：使用主題系統的背景色
			   - var(--bg)確保頁腳背景與當前主題一致
			   - 在明亮和深色主題間自動切換
			   - 維持整體頁面的視覺統一性
			*/
			background:var(--bg);
		}
		/* ==========================================================================
		   響應式設計：移動端和小螢幕設備的專用樣式
		   ==========================================================================
		   這個媒體查詢實現了完整的移動端適配，採用現代CSS技術：
		   1. 使用clamp()函數實現流暢的響應式縮放
		   2. 優化觸控交互的尺寸和間距
		   3. 重新調整佈局以適應小螢幕
		   4. 保持可讀性和用戶體驗的優先級
		   ========================================================================== */
		
		/* 移動端媒體查詢：螢幕寬度768px及以下的設備
		   - 768px是傳統的平板電腦斷點，也是常用的移動端分界線
		   - max-width意味著只有螢幕寬度小於等於768px時才應用以下樣式
		   - 覆蓋大部分智慧手機和小型平板設備
		*/
		@media (max-width:768px){
			/* 移動端導航欄：調整間距以適應小螢幕 */
			.navbar{
				/* 響應式內邊距：使用clamp()實現彈性間距
				   - clamp(0.5rem, 2vw, 0.8rem)
				   - 最小值：0.5rem，確保基本的觸控友好間距
				   - 首選值：2vw，隨視口寬度縮放(視口寬度的2%)
				   - 最大值：0.8rem，防止間距過大
				   - 這種方法比固定值更加靈活，在不同設備上都能提供合適的間距
				*/
				padding:clamp(0.5rem,2vw,0.8rem);
			}
			
			/* 移動端導航標題：縮放字體以適應小螢幕 */
			.nav-title{
				/* 響應式字體大小：保持品牌標識的可讀性
				   - clamp(1rem, 4vw, 1.3rem)
				   - 最小值：1rem，確保文字始終可讀
				   - 首選值：4vw，視口寬度的4%提供自然縮放
				   - 最大值：1.3rem，與桌面版保持一致
				   - 在小設備上字體會適當縮小，但不會過小影響可讀性
				*/
				font-size:clamp(1rem,4vw,1.3rem);
			}
			
			/* 移動端主容器：調整內邊距以節省空間 */
			.container{
				/* 緊湊的內邊距：在小螢幕上節省寶貴的空間
				   - clamp(8px, 2vw, 16px)
				   - 最小值：8px，保證最基本的邊距
				   - 首選值：2vw，隨螢幕大小彈性調整
				   - 最大值：16px，不會過大影響內容空間
				   - 比桌面版的20px稍小，為內容留出更多空間
				*/
				padding:clamp(8px,2vw,16px);
			}
			
			/* 移動端內容網格：優化卡片佈局以適應小螢幕 */
			.content-grid{
				/* 自適應網格列：動態調整卡片數量和大小
				   - repeat(auto-fit, minmax(...))：自動適應可用空間
				   - clamp(140px, 35vw, 180px)：卡片的響應式最小寬度
				   - 140px最小寬度確保卡片不會過小
				   - 35vw讓卡片寬度隨螢幕縮放(視口寬度的35%)
				   - 180px最大寬度防止在小螢幕上卡片過大
				   - auto-fit會根據可用空間自動決定每行顯示幾個卡片
				*/
				grid-template-columns:repeat(auto-fit,minmax(clamp(140px,35vw,180px),1fr));
				
				/* 響應式間距：卡片之間的動態間距 */
				gap:clamp(8px,2vw,16px);
				
				/* 響應式邊距：網格容器的內邊距
				   - 0 表示上下無內邊距
				   - clamp(4px, 1vw, 12px)提供左右內邊距
				   - 最小4px確保內容不會緊貼螢幕邊緣
				*/
				padding:0 clamp(4px,1vw,12px);
			}
			
			/* 移動端內容卡片：移除固定寬度限制 */
			.content-card{
				/* 全寬顯示：讓卡片充分利用可用空間
				   - width:100%讓卡片填滿網格分配的空間
				   - max-width:none移除桌面版的寬度限制
				   - 在移動端優先考慮空間利用率而非固定尺寸
				*/
				width:100%;
				max-width:none;
			}
			
			/* 移動端卡片圖片：優化圖片顯示比例 */
			.content-card img{
				/* 響應式圖片：適應容器寬度 */
				width:100%;
				height:auto;
				
				/* 長寬比控制：保持封面圖片的理想比例
				   - aspect-ratio:7/10 設定寬高比為7:10
				   - 這是書籍封面的標準比例，接近A4紙張比例
				   - 確保在不同螢幕尺寸下圖片都保持正確的視覺比例
				*/
				aspect-ratio:7/10;
				
				/* 圖片適配：確保圖片完美填充容器
				   - object-fit:cover讓圖片覆蓋整個容器
				   - 保持圖片比例的同時填滿指定區域
				   - 避免圖片拉伸變形
				*/
				object-fit:cover;
			}
			
			/* 移動端內容標題：調整文字大小以提升可讀性 */
			.content-title{
				/* 響應式標題字體：在小螢幕上保持可讀性
				   - clamp(0.9rem, 3vw, 1.1rem)
				   - 比桌面版稍小但仍然清晰可讀
				   - 3vw提供隨螢幕縮放的彈性
				*/
				font-size:clamp(0.9rem,3vw,1.1rem);
			}
			
			/* 移動端卡片底部：縮小次要信息的字體 */
			.card-footer{
				/* 緊湊的底部信息：節省空間但保持可讀性
				   - clamp(0.7rem, 2vw, 0.8rem)
				   - 最小0.7rem確保文字仍然可讀
				   - 在移動端優先顯示主要內容
				*/
				font-size:clamp(0.7rem,2vw,0.8rem);
			}
			
			/* 移動端小說信息網格：調整佈局以適應縱向螢幕 */
			.novel-info{
				/* 縮小封面列寬：為文字信息留出更多空間
				   - clamp(120px, 30vw, 200px)調整第一列(封面)寬度
				   - 120px最小寬度確保封面仍然清晰
				   - 30vw隨螢幕寬度彈性調整
				   - 200px最大寬度防止封面過大
				   - 1fr讓第二列(文字信息)佔用剩餘空間
				*/
				grid-template-columns:clamp(120px,30vw,200px) 1fr;
				
				/* 響應式間距：調整封面和文字間的距離 */
				gap:clamp(0.8rem,2vw,1.5rem);
			}
			
			/* 移動端小說封面：防止封面過大 */
			.novel-cover{
				/* 最大寬度限制：確保封面不會超出容器 */
				max-width:100%;
			}
			
			/* 移動端小說標題：保持標題的視覺重要性 */
			.novel-title{
				/* 響應式大標題：在小螢幕上仍然突出
				   - clamp(1.2rem, 5vw, 2rem)
				   - 最小1.2rem確保標題仍然醒目
				   - 5vw提供較大的縮放範圍
				   - 最大2rem避免標題過大佔用太多空間
				*/
				font-size:clamp(1.2rem,5vw,2rem);
			}
			
			/* 移動端章節列表：增加每行章節數量 */
			.chapter-list{
				/* 緊湊的章節網格：在小螢幕上顯示更多章節
				   - clamp(80px, 20vw, 140px)設定章節項目的最小寬度
				   - 80px最小寬度確保章節名稱仍然可讀
				   - 20vw讓章節寬度隨螢幕調整
				   - 140px最大寬度保持適當的比例
				   - 這樣可以在移動端每行顯示更多章節
				*/
				grid-template-columns:repeat(auto-fill,minmax(clamp(80px,20vw,140px),1fr));
			}
			
			/* 移動端章節標題：適當縮小以容納更多內容 */
			.chapter-title{
				/* 緊湊的章節標題：節省空間但保持可讀性 */
				font-size:clamp(0.8rem,2.5vw,1rem);
			}
			
			/* 移動端閱讀器：全螢幕沉浸式閱讀體驗 */
			.reader-container{
				/* 全寬顯示：充分利用螢幕空間
				   - width:100%!important強制覆蓋桌面版的80%設定
				   - !important確保在移動端優先考慮屏幕空間利用
				*/
				width:100%!important;
				
				/* 緊湊的邊距：為內容騰出最大空間
				   - clamp(4px, 1vw, 8px)設定最小的上下邊距
				   - clamp(60px, 15vw, 80px)為底部控制欄留出空間
				*/
				margin:clamp(4px,1vw,8px) 0 clamp(60px,15vw,80px);
				
				/* 響應式內邊距：適度的內容間距 */
				padding:clamp(0.5rem,2vw,1rem);
				
				/* 移除裝飾效果：專注於內容本身
				   - border-radius:0移除圓角，節省空間
				   - box-shadow:none移除陰影效果
				   - 在小螢幕上優先考慮內容而非視覺裝飾
				*/
				border-radius:0;
				box-shadow:none;
			}
			
			/* 移動端閱讀器控制欄：調整位置和間距 */
			.reader-controls{
				/* 響應式底部間距：適應不同螢幕高度 */
				bottom:clamp(4px,1vw,8px);
				
				/* 響應式內邊距：確保按鈕有足夠的觸控空間 */
				padding:clamp(0.5rem,2vw,1rem);
			}
			
			/* 移動端控制按鈕：優化觸控體驗 */
			.control-btn{
				/* 響應式按鈕內邊距：確保觸控友好
				   - clamp(0.3rem, 1vw, 0.5rem)垂直內邊距
				   - clamp(0.5rem, 2vw, 1rem)水平內邊距
				   - 提供足夠大的觸控目標
				*/
				padding:clamp(0.3rem,1vw,0.5rem) clamp(0.5rem,2vw,1rem);
				
				/* 響應式字體：保持按鈕文字的可讀性 */
				font-size:clamp(0.8rem,2.5vw,1rem);
				
				/* 響應式最小寬度：確保按鈕大小適中
				   - clamp(60px, 15vw, 80px)
				   - 60px最小寬度確保按鈕足夠大
				   - 15vw隨螢幕寬度調整
				   - 80px最大寬度防止按鈕過大
				*/
				min-width:clamp(60px,15vw,80px);
			}
			
			/* 移動端設定模態框：幾乎全螢幕顯示 */
			.settings-modal{
				/* 最大化顯示空間：在小螢幕上提供更好的設定體驗
				   - clamp(85%, 90vw, 95%)
				   - 最小85%確保有一定邊距
				   - 90vw是首選值，使用視口寬度的90%
				   - 最大95%避免完全全螢幕
				   - 這樣在小螢幕上設定選項更容易操作
				*/
				width:clamp(85%,90vw,95%);
			}
		}
	</style>
</head>
<!-- =============================================================================
     HTML BODY：頁面的可見內容部分開始
     =============================================================================
     從這裡開始是用戶實際看到和互動的頁面內容，包含完整的Vue.js單頁應用程式結構
     ============================================================================= -->
<body>
	<!-- ==========================================================================
	     Vue.js 應用程式根容器：整個單頁應用的最頂層容器
	     ==========================================================================
	     這個div是Vue.js應用掛載的目標元素，所有的動態內容都在其中
	     ========================================================================== -->
	
	<!-- Vue應用根元素：
	     - id="app"：Vue.js應用將掛載到這個元素上，JavaScript中會使用mount('#app')
	     - :class：Vue動態類綁定語法，冒號(:)表示這是一個動態屬性
	     - 'page-'+currentPage：JavaScript表達式，創建動態CSS類名
	     - 例如：currentPage='list'時，會生成class="page-list"
	     - 這種模式讓CSS可以根據頁面狀態控制不同組件的顯示/隱藏
	-->
	<div id="app" :class="'page-'+currentPage">
		<!-- ==========================================================================
		     導航欄組件：應用的主要導航界面
		     ==========================================================================
		     提供頁面間的導航功能，支持條件顯示和響應式設計
		     使用Vue.js的條件渲染和事件處理實現動態交互
		     ========================================================================== -->
		
		<!-- 主導航欄：條件顯示的導航組件
		     Vue.js指令詳解：
		     - class="navbar"：應用之前定義的固定導航欄樣式
		     - v-show：Vue條件顯示指令，控制元素的visibility和display
		     - v-show vs v-if：v-show只切換CSS顯示，元素始終存在於DOM中
		     - currentPage!=='reader'：JavaScript表達式，當前頁面不是閱讀器時才顯示
		     - 在閱讀模式下隱藏導航欄提供沉浸式閱讀體驗
		-->
		<nav class="navbar" v-show="currentPage!=='reader'">
			
			<!-- 導航容器：Flexbox佈局的導航內容容器
			     - nav-container：應用之前定義的容器樣式
			     - flex-between：使用Flexbox工具類實現兩端對齊佈局
			     - 左側放置返回按鈕或標題，右側放置功能按鈕
			-->
			<div class="nav-container flex-between">
				
				<!-- 導航左側區域：返回按鈕和網站標題的容器 -->
				<div class="nav-left flex-center">
					<!-- 條件返回按鈕：根據頁面狀態動態顯示
					     Vue.js條件渲染指令詳解：
					     - v-if：Vue條件渲染指令，元素根據條件動態創建/銷毀
					     - v-if vs v-show：v-if會完全移除/添加DOM元素，性能開銷更高但更徹底
					     - currentPage==='detail'：JavaScript嚴格相等比較，只在詳情頁顯示
					     - 這種條件渲染避免了不必要的DOM元素，保持代碼整潔
					     
					     CSS類和事件處理：
					     - class="control-btn back-btn"：應用多個CSS類，提供基礎按鈕樣式和返回按鈕特定樣式
					     - @click：Vue事件監聽器語法糖，等同於v-on:click
					     - goToHome：點擊時調用的Vue實例方法，實現頁面導航
					-->
					<button v-if="currentPage==='detail'" class="control-btn back-btn" @click="goToHome">
						
						<!-- SVG圖標：可縮放的矢量圖形
						     SVG優勢和屬性詳解：
						     - 矢量格式：在任何解析度下都保持清晰
						     - 可通過CSS控制：繼承文字顏色和主題樣式
						     - 輕量級：比點陣圖片檔案更小
						     
						     SVG屬性說明：
						     - width/height：圖標尺寸設為20x20像素，適合導航按鈕
						     - viewBox="0 0 24 24"：SVG的視口坐標系統，定義內部座標空間
						     - fill="none"：不填充圖形內部，創造線條風格圖標
						     - stroke="currentColor"：使用當前文字顏色作為線條顏色
						     - stroke-width="2"：線條寬度為2個單位，提供適當的視覺重量
						     - 這種設計讓圖標可以繼承文字顏色，與主題系統完美整合
						-->
						<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
							<!-- path元素：定義圖形路徑
							     SVG路徑語法詳解：
							     - d屬性：路徑數據，使用SVG路徑命令
							     - M：Move命令，移動到指定座標
							     - H：水平線命令
							     - L：直線命令
							     - "M19 12H5"：從(19,12)移動並畫水平線到x=5
							     - "M12 19l-7-7 7-7"：從(12,19)開始畫箭頭的尖端部分
							     - 結合起來創建一個指向左側的返回箭頭圖標
							-->
							<path d="M19 12H5M12 19l-7-7 7-7"/>
						</svg>
					</button>
					
					<!-- 條件網站標題：品牌標識和首頁導航
					     條件渲染邏輯：
					     - v-if="currentPage!=='detail'"：與返回按鈕形成互斥關係
					     - 在非詳情頁顯示網站標題，在詳情頁顯示返回按鈕
					     - 這種設計最大化利用有限的導航空間
					     
					     元素選擇和語義：
					     - 使用<a>標籤而非<button>：語義上表示這是一個導航連結
					     - class="nav-title"：應用品牌標題樣式
					     - @click="goToHome"：點擊標題也可以返回首頁
					     - 這種設計讓標題既是品牌展示也是實用的導航元素
					-->
					<a v-if="currentPage!=='detail'" class="nav-title" @click="goToHome">輕小說翻譯</a>
				</div>
				<!-- 導航右側區域：功能按鈕和下拉選單 -->
				<div class="nav-right flex-center">
					
					<!-- 排序下拉選單：僅在列表頁顯示的排序功能
					     Vue.js進階指令組合：
					     - v-show="currentPage==='list'"：只在首頁列表顯示排序選單
					     - @mouseenter/@mouseleave：滑鼠進入/離開事件監聽器
					     - 實現滑鼠懸停時自動打開下拉選單的交互效果
					     - activeDropdown='sort'：設定當前活躍的下拉選單標識
					     - 這種設計提供了直觀的用戶體驗，無需點擊即可預覽選項
					-->
					<div class="dropdown" v-show="currentPage==='list'" @mouseenter="activeDropdown='sort'" @mouseleave="activeDropdown=null">
						
						<!-- 下拉選單觸發按鈕：排序功能的觸發器
						     複雜的Vue.js屬性綁定：
						     - class="dropdown-toggle"：基礎下拉按鈕樣式
						     - @click="toggleSortDropdown"：點擊事件處理器，切換下拉選單狀態
						     - :class="{active:activeDropdown==='sort'}"：動態類綁定
						       - 對象語法：{className: condition}
						       - 當activeDropdown等於'sort'時添加'active'類
						       - 這讓CSS可以為活躍狀態提供不同的視覺效果
						-->
						<button class="dropdown-toggle" @click="toggleSortDropdown" :class="{active:activeDropdown==='sort'}">
							<!-- 排序圖標：複合SVG圖形表示排序功能
							     SVG圖標設計分析：
							     - width/height="18"：稍小於返回箭頭，表示次要功能
							     - stroke-linecap="round"：圓形線條端點，更現代的視覺風格
							     - stroke-linejoin="round"：圓形線條連接點，保持一致的視覺風格
							     
							     圖標組成元素：
							     - 第一個path：三條遞減長度的水平線(排序列表的視覺隱喻)
							     - 第二個path：向下的箭頭(表示下拉動作)
							     - 第三個path：垂直線(連接排序概念)
							     - 整體形成排序+下拉的複合概念圖標
							-->
							<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
								<path d="M4 7h10M4 12h8M4 17h6"></path>
								<path d="M17 13l3 3l3-3"></path>
								<path d="M20 8v8"></path>
							</svg>
							
							<!-- Vue.js文本插值：動態顯示當前排序方式
							     雙大括號語法詳解：
							     - {{currentSortLabel}}：Vue的文本插值語法
							     - currentSortLabel：計算屬性，根據currentSort動態生成標籤
							     - 這種方式讓用戶清楚知道當前的排序方式
							     - 文本內容會隨著狀態改變自動更新
							-->
							<span>{{currentSortLabel}}</span>
						</button>
						
						<!-- 下拉選單內容：排序選項的容器
						     複雜的Vue.js屬性綁定組合：
						     - class="dropdown-menu"：基礎下拉選單樣式
						     - :class="{show:activeDropdown==='sort'}"：條件類綁定
						       - show類控制選單的顯示/隱藏動畫
						       - 只有當activeDropdown為'sort'時才添加show類
						     - :style="getDropdownPosition()"：動態樣式綁定
						       - 調用Vue方法計算下拉選單的位置
						       - 確保選單不會超出視窗邊界
						       - 實現智能定位的用戶體驗
						-->
						<div class="dropdown-menu" :class="{show:activeDropdown==='sort'}" :style="getDropdownPosition()">
							
							<!-- Vue.js列表渲染：動態生成排序選項
							     v-for指令詳解：
							     - v-for="option in sortOptions"：遍歷sortOptions數組
							     - option：當前循環項的別名
							     - sortOptions：Vue實例中定義的排序選項數組
							     - :key="option.value"：為每個項目提供唯一標識
							       - Vue需要key來追蹤元素變化，優化渲染性能
							       - 使用option.value確保唯一性
							     
							     事件處理和文本插值：
							     - @click="handleSortChange(option)"：點擊事件處理
							       - 傳遞整個option對象給處理方法
							       - 方法會更新當前排序方式並重新排列列表
							     - {{option.label}}：顯示選項的可讀標籤
							-->
							<a v-for="option in sortOptions" :key="option.value" @click="handleSortChange(option)">{{option.label}}</a>
						</div>
					</div>
					
					<!-- 主題切換按鈕：明暗主題切換的控制器
					     Vue.js條件渲染在文本中的應用：
					     - class="theme-toggle"：應用主題切換按鈕的樣式
					     - @click="toggleTheme"：點擊時調用主題切換方法
					     - {{isDarkMode?'🌜':'🌞'}}：三元運算符的文本插值
					       - isDarkMode：布爾值狀態，表示當前是否為暗色主題
					       - ?:：JavaScript三元運算符
					       - 🌜：月亮Emoji，表示暗色模式
					       - 🌞：太陽Emoji，表示亮色模式
					       - 這種設計提供直觀的視覺提示，用戶一看就知道當前主題和切換效果
					-->
					<button class="theme-toggle" @click="toggleTheme">{{isDarkMode?'🌜':'🌞'}}</button>
				</div>
			</div>
		</nav>
		
		<!-- ==========================================================================
		     主頁列表容器：小說列表的主要展示區域
		     ==========================================================================
		     這是首頁的核心內容區域，展示所有可用的小說
		     使用條件渲染只在列表頁面顯示
		     ========================================================================== -->
		
		<!-- ==========================================================================
		     主頁列表容器：小說列表的主要展示區域
		     ==========================================================================
		     這是首頁的核心內容區域，展示所有可用的小說
		     使用Vue.js條件渲染實現頁面切換，響應式設計適配各種設備
		     ========================================================================== -->
		
		<!-- 列表頁容器：小說卡片網格的包裝容器
		     Vue.js條件渲染詳解：
		     - class="container"：應用響應式容器樣式
		       - 設定最大寬度限制，避免內容在超寬螢幕上過度拉伸
		       - 提供水平居中對齊，確保內容在視窗中心顯示
		       - 包含適當的內邊距，在小螢幕上保持邊距
		     - v-show="currentPage==='list'"：Vue條件顯示指令
		       - v-show vs v-if的性能考量：
		         * v-show：只切換CSS的display屬性，元素始終存在於DOM中
		         * v-if：完全添加/移除DOM元素，有創建/銷毀開銷
		         * 這裡使用v-show因為頁面切換頻繁，避免重複的DOM操作
		       - currentPage==='list'：JavaScript嚴格相等比較
		         * 只有當前頁面狀態完全等於'list'字符串時才顯示
		         * 確保只在首頁狀態下顯示小說列表
		-->
		<div class="container" v-show="currentPage==='list'">
			
			<!-- CSS Grid內容網格：響應式的小說卡片佈局系統
			     現代CSS Grid佈局詳解：
			     - class="content-grid"：應用預定義的CSS Grid佈局樣式
			       - 使用grid-template-columns: repeat(auto-fill, minmax(250px, 1fr))
			       - auto-fill：自動填滿容器寬度，動態調整列數
			       - minmax(250px, 1fr)：每個卡片最小250px，最大平分剩餘空間
			       - 這種設計讓卡片數量自動適應螢幕寬度
			     
			     響應式行為說明：
			     - 大螢幕（>1200px）：4-5個卡片並排顯示
			     - 中等螢幕（768-1200px）：2-3個卡片並排顯示
			     - 小螢幕（<768px）：1-2個卡片並排顯示
			     - 極小螢幕（<480px）：單列顯示，確保可讀性
			     
			     與傳統Flexbox相比的優勢：
			     - Grid提供更精確的二維佈局控制
			     - 自動處理等高卡片，避免高度不一致的問題
			     - 更少的媒體查詢需求，CSS更簡潔
			-->
			<div class="content-grid">
				
				<!-- Vue.js列表渲染：動態生成小說卡片
				     v-for指令深度解析：
				     - v-for="item in sortedNovelList"：遍歷排序後的小說列表
				     - item：當前循環的小說對象，包含標題、作者、封面等信息
				     - sortedNovelList：計算屬性，根據用戶選擇的排序方式動態排序
				     - :key="item.title"：唯一標識符，確保Vue能正確追蹤每個項目
				     
				     CSS類組合和事件處理：
				     - class="content-card rounded transition-fast"：多個CSS類的組合
				       - content-card：基礎卡片樣式
				       - rounded：圓角效果
				       - transition-fast：快速過渡動畫
				     - @click="goToDetail(item)"：點擊事件處理
				       - 點擊整個卡片都會導航到詳情頁
				       - 傳遞item對象以便詳情頁獲取小說信息
				-->
				<div v-for="item in sortedNovelList" :key="item.title" class="content-card rounded transition-fast" @click="goToDetail(item)">
					
					<!-- 小說封面圖片：動態屬性綁定的典型應用
					     Vue.js屬性綁定詳解：
					     - :src="item.coverUrl"：動態綁定圖片源地址
					       - item.coverUrl：從小說對象中獲取封面URL
					       - 路徑通常基於小說標題動態生成
					     - :alt="item.title"：動態綁定替代文字
					       - 提升無障礙性，屏幕閱讀器可以讀出小說標題
					       - 當圖片載入失敗時顯示的描述文字
					     - @error="handleImageError"：錯誤處理事件
					       - 當圖片載入失敗時觸發
					       - 通常會替換為預設的錯誤圖片
					       - 提升用戶體驗，避免顯示破圖
					-->
					<img :src="item.coverUrl" :alt="item.title" @error="handleImageError">
					
					<!-- 卡片信息區域：文字內容的容器 -->
					<div class="content-card-info">
						
						<!-- 小說標題：文本插值的基礎應用
						     - class="content-title"：標題樣式
						     - {{item.title}}：顯示小說標題
						     - Vue會自動處理HTML轉義，確保安全性
						-->
						<div class="content-title">{{item.title}}</div>
						
						<!-- 卡片底部信息：作者和更新時間 -->
						<div class="card-footer">
							<!-- 作者信息：直接文本插值 -->
							<span>{{item.author}}</span>
							
							<!-- 格式化的更新時間：方法調用的文本插值
							     - {{formattedLastUpdated(item)}}：調用Vue方法進行日期格式化
							     - formattedLastUpdated：Vue實例中定義的方法
							     - 傳入整個item對象，方法內部提取lastUpdated屬性
							     - 返回格式化後的日期字符串，如"2024-01-15"
							     - 這種模式將格式化邏輯從模板中分離，保持模板簡潔
							-->
							<span>{{formattedLastUpdated(item)}}</span>
						</div>
					</div>
				</div>
			</div>
		</div>
		
		<!-- ==========================================================================
		     小說詳情頁容器：單一小說的詳細資訊和章節列表
		     ==========================================================================
		     提供小說的完整資訊、封面大圖、作者簡介和章節導航
		     支持回應式設計和無障礙功能，提供優秀的使用者體驗
		     ========================================================================== -->
		
		<!-- 詳情頁主容器：條件渲染的詳情內容區域
		     Vue.js條件顯示詳解：
		     - class="container"：繼承相同的容器樣式，保持設計一致性
		     - v-show="currentPage==='detail'"：只在詳情頁狀態下顯示
		       - 與列表頁形成互斥關係，確保每次只顯示一個頁面
		       - 提供清晰的導航和焦點管理
		-->
		<div class="container" v-show="currentPage==='detail'">
			
			<!-- 小說詳情卡片：包含所有詳情資訊的主要容器
			     CSS類別組合說明：
			     - novel-detail：應用詳情頁的主要樣式
			       - 設定內邊距、背景、陰影等視覺效果
			       - 使用Flexbox或Grid佈局管理內部結構
			     - rounded：應用圓角效果，提供現代的視覺風格
			       - border-radius屬性創建圓滑的邊緣
			       - 提升視覺美感和用戶體驗
			-->
			<div class="novel-detail rounded">
				
				<!-- 小說基本資訊區域：封面、標題、作者和描述
				     這個區域展示小說的主要資訊，使用Flexbox佈局實現響應式設計
				     在桐面上水平排列，在手機上垂直堆疊
				-->
				<div class="novel-info">
					<!-- 小說封面圖片：Vue.js進階屬性繫定和事件處理的經典範例
					     Vue.js動態屬性繫定詳解：
					     - :src="getCoverUrl()"：動態繫定圖片源地址
					       - 冠號(:)是v-bind的簡寫語法，表示這是動態屬性
					       - getCoverUrl()：調用Vue方法計算封面URL
					       - 方法會根據selectedNovel狀態動態產生正確的圖片路徑
					     
					     - :alt="selectedNovel?.title"：無障礙設計的替代文字
					       - selectedNovel?.title：使用可選鏈運算符(?)防止null錯誤
					       - 當selectedNovel為null或undefined時，表達式返回undefined
					       - 提供螢幕閱讀器可以讀取的有意義描述
					     
					     CSS類別和設計考量：
					     - class="novel-cover rounded"：組合封面樣式和圓角效果
					       - novel-cover：設定適當的尺寸、陰影和邊距
					       - rounded：創建現代的圓角外觀
					     
					     事件處理系統：
					     - @click="openLightbox(getCoverUrl())"：點擊事件處理
					       - @符號是v-on的簡寫語法，用於事件監聽
					       - openLightbox()：開啟全螢幕圖片查看器
					       - 傳入封面URL作為參數，讓lightbox顯示正確的圖片
					       - 這種交互設計讓用戶可以詳細查看封面
					     
					     - @error="handleImageError"：圖片載入錯誤處理
					       - 當圖片URL無效或載入失敗時觸發
					       - handleImageError：統一的錯誤處理方法
					       - 通常會替換為預設的錯誤圖片或占位符
					       - 提升用戶體驗，避免顯示破圖或空白
					     
					     用戶體驗考量：
					     - 封面可點擊放大，滿足用戶查看細節的需求
					     - 錯誤處理確保在網路問題或檔案缺失時不影響整體体驗
					     - 無障礙設計支持螢幕閱讀器用戶
					-->
					<img :src="getCoverUrl()" :alt="selectedNovel?.title" class="novel-cover rounded" @click="openLightbox(getCoverUrl())" @error="handleImageError">
					
					<!-- 小說文字資訊區域：標題、作者和其他元數據
					     這個區域使用語意化HTML和結構化數據展示
					     支持無障礙設計和搜尋引擎優化
					-->
					<div>
						
						<!-- 小說主標題：語意化HTML和動態內容的結合
						     HTML語意化考量：
						     - <h2>：使用適當的標題層級，表示這是頁面的次要標題
						       - 主標題(h1)通常是網站名稱，小說標題使用h2符合層級結構
						       - 支持螢幕閱讀器正確識別標題結構
						     - class="novel-title"：應用專用樣式
						       - 設定適當的字體大小、字重和間距
						       - 適應不同主題和螢幕尺寸
						     
						     Vue.js文字插值和安全性：
						     - {{selectedNovel?.title}}：安全的文字輸出
						       - Vue自動轉義HTML字元，防止XSS攻擊
						       - 可選鏈運算符(?)防止null/undefined錯誤
						       - 當selectedNovel不存在時顯示空白而非拋出錯誤
						-->
						<h2 class="novel-title">{{selectedNovel?.title}}</h2>
						
						<!-- 小說元數據區域：結構化的資訊展示
						     這個區域使用結構化的方式展示小說的各項屬性
						     提供清晰的資訊層次和結構
						-->
						<div class="novel-metadata">
							
							<!-- 作者資訊：語意化標籤和動態內容
							     HTML結構設計：
							     - <p>：使用段落標籤包裝每條資訊
							     - <strong>：強調標籤突出標籤部分
							       - 語意化比單純的樣式設定更好
							       - 螢幕閱讀器可以正確識別重要資訊
							     
							     內容組織和用戶體驗：
							     - 每個資訊項目都有清晰的標籤
							     - 一致的格式提供可預測的閱讀體驗
							     - 方便用戶快速掃描和定位所需資訊
							-->
							<p><strong>作者：</strong>{{selectedNovel?.author}}</p>
							<p><strong>類型：</strong>{{selectedNovel?.genres}}</p>
							
							<!-- 原始來源連結：條件渲染和V-for的進階應用
							     這是Vue.js最複雜的範例之一，結合了多個進階概念
							     
							     Vue.js條件渲染複合条件：
							     - v-if="selectedNovel?.sourceLinks && Object.keys(selectedNovel.sourceLinks).length > 0"
							       - 第一個条件：selectedNovel?.sourceLinks
							         * 可選鏈運算符確保對象存在且有sourceLinks屬性
							         * 防止在selectedNovel為null時的訪問錯誤
							       - &&：邏輯且運算符，只有第一個极件為真時才檢查第二個
							       - Object.keys().length > 0：確保對象不是空的
							         * Object.keys()返回對象的所有屬性名數組
							         * length > 0確保至少有一個連結
							     
							     CSS類別和設計：
							     - class="source-links"：應用連結列表的專用樣式
							       - 包含適當的間距、字體大小設定
							       - 為多個連結提供清晰的視覺分隔
							-->
							<p class="source-links" v-if="selectedNovel?.sourceLinks && Object.keys(selectedNovel.sourceLinks).length > 0">
								<strong>原連結：</strong>
								
								<!-- 動態連結列表：V-for遍歷對象的進階用法
								     Vue.js對象遍歷詳解：
								     - v-for="(link,key) in selectedNovel?.sourceLinks"：遍歷對象的鍵值對
								       - (link,key)：破壞性賽值，link是值，key是鍵名
								       - 與數組遍歷不同，對象遍歷需要同時處理鍵和值
								       - selectedNovel?.sourceLinks：可選鏈操作確保安全性
								     
								     - :key="key"：列表渲染的唯一標識符
								       - 使用對象的鍵名作為唯一標識
								       - Vue需要key來追蹤元素變化，優化渲柕性能
								     
								     連結屬性和用戶體驗：
								     - :href="link"：動態繫定連結目標
								       - link變數包含完整的URL地址
								       - 支持各種協議（http、https等）
								     - target="_blank"：在新分頁中開啟連結
								       - 避免離開當前應用，保持用戶上下文
								       - 提供更好的用戶體驗
								     - class="source-link"：應用連結樣式
								       - 設定適當的顯示效果和惸停狀態
								       - 提供清晰的視覺回饋
								     
								     連結文字處理：
								     - {{getSourceLinkName(key)}}：方法調用的文字插值
								       - getSourceLinkName()：Vue方法，將內部鍵名轉換為友好顯示名稱
								       - 例如：'syosetu' -> '小說家になろう'
								       - 提供更友好的用戶界面
								-->
								<a v-for="(link,key) in selectedNovel?.sourceLinks" :key="key" :href="link" target="_blank" class="source-link">{{getSourceLinkName(key)}}</a>
							</p>
						</div>
						
						<!-- 小說描述區域：富文字內容的安全渲染
						     Vue.js富文字渲染詳解：
						     - v-if="parsedDescription"：只在有描述內容時顯示
						       - parsedDescription：經過處理的Markdown或HTML內容
						       - 避免空內容區域占用空間，提升版面效率
						     
						     - v-html="parsedDescription"：Vue原始HTML渲染指令
						       - 與{{}}(文字插值)不同，v-html會解析HTML標籤
						       - 支持富文字格式：粗體、斜體、連結、列表等
						       - 安全性警告：只能用於可信任的內容，防止XSS攻擊
						     
						     CSS類別和設計：
						     - class="novel-description"：應用專用的描述樣式
						       - 設定適當的字體大小、行高和間距
						       - 為內部HTML元素提供一致的樣式
						       - 限制最大寬度，保持適合的閱讀體驗
						     
						     內容處理和安全性：
						     - parsedDescription通常來自Markdown轉HTML的結果
						     - 在JavaScript中進行預處理，清理潛在的危險標籤
						     - 支持常見的Markdown語法：標題、段落、列表、連結等
						-->
						<div class="novel-description" v-if="parsedDescription" v-html="parsedDescription"></div>
					</div>
				</div>
				
				<!-- ==========================================================================
				     章節列表區域：互動式章節導航系統
				     ==========================================================================
				     這是詳情頁的核心功能，提供完整的章節清單和導航
				     結合Vue.js的多個進階特性：列表渲染、條件類別、事件處理
				     ========================================================================== -->
				
				<!-- 章節列表容器：所有章節的父容器
				     CSS設計考量：
				     - class="chapter-list"：應用專用的列表容器樣式
				       - 設定適當的最大高度和滿加渲動
				       - 在章節過多時提供可滿動的介面
				       - 使用Grid或Flexbox實現響應式佈局
				-->
				<div class="chapter-list">
					
					<!-- Vue.js章節列表渲染：結合多個進階特性的範例
					     這是整個應用中最複雜的Vue.js元素之一：
					     
					     列表渲染詳解：
					     - v-for="chapter in chaptersWithDates"：遍歷計算屬性
					       - chaptersWithDates：計算屬性，結合章節數據和日期資訊
					       - chapter：當前循環項目，包含章節的所有屬性
					       - Vue會為每個章節創建一個独立的DOM元素
					     
					     - :key="chapter.number"：渲柕性能優化
					       - 使用章節編號作為唯一標識符
					       - Vue用於Virtual DOM diff演算，提升更新效率
					       - 確保列表重新排序時的正確行為
					     
					     CSS類別組合設計：
					     - class="chapter-item rounded transition-fast"：多個工具類別組合
					       - chapter-item：章節按鈕的基礎樣式（內邊距、字體、邊框）
					       - rounded：圓角效果，提供現代的視覺風格
					       - transition-fast：快速過渡動畫，增強交互回饋
					     
					     Vue.js動態類別繫定：
					     - :class="{read:isChapterRead(chapter.number)}"：條件類別
					       - 對象語法：{className: condition}
					       - read：類別名，當条件為真時添加
					       - isChapterRead(chapter.number)：方法調用，檢查章節是否已讀
					         * 轉入當前章節編號作為參數
					         * 返回布爾值，根據localStorage中的記錄判斷
					         * 已讀章節會有不同的視覺風格（例如較淡的顏色）
					     
					     事件處理和導航：
					     - @click="goToChapter(chapter.number)"：點擊事件處理
					       - 整個章節項目都可以點擊，提供大的觸控目標
					       - goToChapter()：導航方法，切換到閱讀器頁面
					       - 傳入章節編號，讓應用記住位置並載入對應內容
					       - 這種設計提供直覺的章節導航體驗
					-->
					<div v-for="chapter in chaptersWithDates" :key="chapter.number" class="chapter-item rounded transition-fast" :class="{read:isChapterRead(chapter.number)}" @click="goToChapter(chapter.number)">
						
						<!-- 章節標題：章節的主要資訊顯示
						     Vue.js文字插值詳解：
						     - {{chapter.title}}：安全的文字輸出
						       - Vue自動轉義HTML字元，防止XSS攻擊
						       - chapter.title來自當前v-for循環的章節對象
						       - 支持中文、日文和特殊字元的正確顯示
						     
						     CSS類別和設計：
						     - class="chapter-title"：章節標題的專用樣式
						       - 設定適當的字體大小和字重
						       - 限制最大寬度，過長標題會自動截斷
						       - 支持多行顯示或檶圓處理
						-->
						<div class="chapter-title">{{chapter.title}}</div>
						
						<!-- 章節日期：格式化的更新時間顯示
						     Vue.js方法調用詳解：
						     - {{formatDate(chapter.date)}}：方法調用的文字插值
						       - formatDate()：Vue實例中定義的日期格式化方法
						       - chapter.date：原始日期數據（通常是ISO格式或時間戳）
						       - 返回用戶友好的日期格式（例如"2024-01-15"）
						     
						     日期處理和本地化：
						     - 支持不同地區的日期格式
						     - 自動處理時區轉換和本地時間
						     - 提供相對時間（例如"3天前"）或絕對時間選項
						     
						     CSS類別和設計：
						     - class="chapter-date"：日期顯示的專用樣式
						       - 使用較小的字體和較淡的顏色
						       - 位置在標題下方或右側，作為輔助資訊
						       - 在小螢幕上可能隱藏或簡化顯示
						-->
						<div class="chapter-date">{{formatDate(chapter.date)}}</div>
					</div>
				</div>
			</div>
		</div>
		
		<!-- ==========================================================================
		     閱讀器頁面：沉浸式的小說閱讀體驗
		     ==========================================================================
		     提供專注的閱讀環境，支持字體調整、主題切換和深度定制
		     智能隱藏控制列，提供更好的閱讀沉浸感
		     ========================================================================== -->
		
		<!-- 閱讀器主容器：條件渲染的閱讀環境
		     Vue.js條件顯示詳解：
		     - v-show="currentPage==='reader'"：只在閱讀器頁面顯示
		       - 與列表頁和詳情頁形成互斥關係
		       - 提供完全独立的閱讀環境，避免干擾
		       - 支持全螢幕閱讀模式
		-->
		<div v-show="currentPage==='reader'">
			
			<!-- ==========================================================================
			     閱讀器導航列：可隱藏的頂部導航控制
			     ==========================================================================
			     提供基本的導航功能，在閱讀時可以智能隱藏以提供更好的沉浸感
			     ========================================================================== -->
			
			<!-- 閱讀器導航列：智能隱藏的頂部控制列
			     Vue.js動態類別繫定詳解：
			     - class="navbar"：基礎導航列樣式
			     - :class="{hidden:hideControls}"：動態隱藏控制
			       - hidden：CSS類別，通常設定transform: translateY(-100%)
			       - hideControls：Vue狀態，控制是否隱藏導航列
			       - 滿動時自動隱藏，止滿時顯示，提供沉浸式體驗
			       - 平滑的CSS過渡動畫讓隱藏/顯示更加優雅
			-->
			<div class="navbar" :class="{hidden:hideControls}">
				
				<!-- 導航內容容器：三欄式導航佈局
				     Flexbox佈局詳解：
				     - nav-container：導航容器的基礎樣式
				     - flex-between：justify-content: space-between的工具類別
				       - 左右兩端對齊，中間自動分配空間
				       - 完美適配手機和桶面介面
				-->
				<div class="nav-container flex-between">
					
					<!-- 返回按鈕：從閱讀器返回詳情頁
					     事件處理和用戶體驗：
					     - class="control-btn back-btn"：組合基礎按鈕樣式和返回按鈕樣式
					     - @click="goBackToDetail"：返回詳情頁的事件處理
					       - 保持當前小說的上下文，不會失去用戶位置
					       - 維持導航歷史的一致性
					       - 提供明確的返回路徑和預期行為
					-->
					<button class="control-btn back-btn" @click="goBackToDetail">
						
						<!-- SVG返回箭頭圖標：與詳情頁保持一致的視覺風格
						     圖標設計一致性：
						     - 與詳情頁的返回按鈕使用相同的SVG圖標
						     - 維持視覺語言的一致性，提供可預測的用戶體驗
						     - 支持主題切換和無障礙設計
						-->
						<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
							<path d="M19 12H5M12 19l-7-7 7-7"/>
						</svg>
					</button>
					
					<!-- 閱讀器標題顯示：當前章節的標題
					     Vue.js文字插值和安全性：
					     - {{currentChapter?.title}}：安全的文字輸出
					       - currentChapter：當前閱讀的章節對象
					       - 可選鏈運算符(?)防止null錯誤
					       - 當沒有章節載入時顯示空白而不是錯誤
					     
					     CSS類別和設計：
					     - class="reader-title"：閱讀器標題的專用樣式
					       - 置中對齊，在三欄式佈局中作為中間元素
					       - 適當的字體大小和字重，但不會太突出
					       - 支持文字截斷，長標題不會破壞佈局
					       - 響應式設計，在小螢幕上可能簡化顯示
					-->
					<div class="reader-title">{{currentChapter?.title}}</div>
					
					<!-- 占位元素：保持三欄式佈局的平衡
					     佈局設計考量：
					     - style="width:44px;"：與左側返回按鈕相同的寬度
					       - 44px包含按鈕尺寸和內邊距
					       - 確保中間標題完美居中對齊
					       - 這種技巧在Flexbox三欄式佈局中很常見
					     
					     為什麼不放按鈕？
					     - 閱讀器頁面最重要的是內容，減少不必要的交互元素
					     - 右側功能可以通過底部控制列或手勢訪問
					     - 避免界面過於雜亂，提供清爽的閱讀環境
					-->
					<div style="width:44px;"></div>
				</div>
			</div>
			
			<!-- ==========================================================================
			     閱讀器內容容器：主要的章節內容顯示區域
			     ==========================================================================
			     這是閱讀器的核心區域，顯示格式化後的章節內容
			     支持富文字渲染、圖片顯示和響應式設計
			     ========================================================================== -->
			
			<!-- 閱讀器主容器：章節內容的包裝容器
			     CSS設計考量：
			     - class="reader-container rounded"：組合閱讀器樣式和圓角效果
			       - reader-container：閱讀器的主要樣式
			         * 設定適當的內邊距，提供舝適的閱讀空間
			         * 控制最大寬度，避免在大螢幕上文字過寬
			         * 設定背景顏色和文字樣式
			         * 支持主題切換和用戶設定
			       - rounded：圓角效果，提供現代的視覺風格
			         * 輕微的圓角讓閱讀器更加柔和
			         * 與整體設計語言保持一致
			-->
			<div class="reader-container rounded">
				
				<!-- 章節內容區域：富文字內容的安全渲染
				     Vue.js富文字渲染進階應用：
				     - class="novel-content"：章節內容的專用樣式
				       - 控制字體大小、行高和段落間距
				       - 支持用戶設定：字體大小、行高、寬度等
				       - 為內部HTML元素提供一致的樣式（h1-h6, p, img等）
				       - 支持主題切換，不同主題下的表現不同
				     
				     - v-html="parsedContent"：安全的HTML內容渲染
				       - parsedContent：經過處理的Markdown轉HTML內容
				         * 從Markdown檔案載入原始內容
				         * 通過Markdown解析器轉換為HTML
				         * 進行安全清理，移除危險標籤和屬性
				         * 處理圖片路徑和連結轉換
				       - v-html vs {{}}：
				         * v-html會解析HTML標籤，支持富文字格式
				         * {{}}只是純文字輸出，不支持HTML格式
				         * 這裡必須使用v-html才能正確顯示格式化內容
				     
				     安全性考量：
				     - 所有內容都來自可信任的Markdown檔案
				     - 在解析過程中進行安全清理
				     - 不允許用戶生成內容，只顯示預定義的文檔
				     
				     響應式設計：
				     - 在不同螢幕尺寸上提供最佳的閱讀體驗
				     - 支持手機、平板和桐面的獨特優化
				     - 圖片自動縮放和應式佈局
				-->
				<div class="novel-content" v-html="parsedContent"></div>
			</div>
			
			<!-- ==========================================================================
			     閱讀器控制列：底部固定的功能按鈕列
			     ==========================================================================
			     提供章節導航、設定調整和章節目錄等核心功能
			     支持智能隱藏和狀態管理，提供直覺的交互體驗
			     ========================================================================== -->
			
			<!-- 閱讀器控制按鈕列：固定在底部的功能面板
			     Vue.js動態類別繫定詳解：
			     - class="reader-controls"：控制列的基礎樣式
			       - 固定在底部： position: fixed; bottom: 0
			       - 使用Flexbox佈局，按鈕平均分佈
			       - 設定背景、陰影和遠端效果
			       - 支持主題切換和響應式設計
			     - :class="{hidden:hideControls}"：動態隱藏控制
			       - hidden：CSS類別，通常設定transform: translateY(100%)
			       - hideControls：Vue狀態，與導航列同步控制
			       - 滿動時自動隱藏，停止滿動時顯示
			       - 提供沉浸式閱讀體驗，也保持功能可用性
			-->
			<div class="reader-controls" :class="{hidden:hideControls}">
				
				<!-- 上一章按鈕：導航到前一個章節
				     Vue.js事件處理和狀態管理：
				     - class="control-btn"：控制按鈕的統一樣式
				       - 設定適當的尺寸、內邊距和字體
				       - 支持主題切換和狀態變化
				       - 提供惸停和按下效果
				     - @click="goToPrevious"：點擊事件處理
				       - goToPrevious()：導航到前一個章節的方法
				       - 自動更新URL和歷史記錄
				       - 載入新章節內容和保存閱讀進度
				     - :disabled="!hasPrevious||isLoading"：動態禁用狀態
				       - hasPrevious：計算屬性，檢查是否有前一章
				       - isLoading：載入狀態，防止重複點擊
				       - ||：邏輯或運算符，滿足任一条件即禁用
				       - 禁用時按鈕會顯示不同的視覺狀態
				-->
				<button class="control-btn" @click="goToPrevious" :disabled="!hasPrevious||isLoading">上一話</button>
				
				<!-- 章節目錄按鈕：開啟章節列表面板
				     交互設計考量：
				     - @click="toggleChapterMenu"：切換章節選單的顯示狀態
				       - toggleChapterMenu()：切換方法，控制showChapterMenu狀態
				       - 會自動關閉設定面板，確保一次只顯示一個
				       - 提供快速章節導航功能
				     - :disabled="isLoading"：載入時禁用
				       - 防止在章節載入過程中打開選單
				       - 保持界面狀態的一致性
				-->
				<button class="control-btn" @click="toggleChapterMenu" :disabled="isLoading">目錄</button>
				
				<!-- 設定按鈕：開啟閱讀設定面板
				     功能設計考量：
				     - @click="toggleSettings"：切換設定面板的顯示狀態
				       - toggleSettings()：切換方法，控制showSettings狀態
				       - 會自動關閉章節選單，避免界面雜亂
				       - 提供字體、行高、寬度、主題等設定
				     - :disabled="isLoading"：載入時禁用
				       - 避免在內容載入時調整設定造成混亂
				       - 保持用戶体驗的連貫性
				-->
				<button class="control-btn" @click="toggleSettings" :disabled="isLoading">設置</button>
				
				<!-- 下一章按鈕：導航到後一個章節
				     Vue.js事件處理和狀態管理（與上一章類似）：
				     - @click="goToNext"：導航到下一章的事件處理
				       - goToNext()：前進到下一個章節的方法
				       - 自動滿動到頁面頂部
				       - 更新閱讀進度和歷史記錄
				     - :disabled="!hasNext||isLoading"：動態禁用狀態
				       - hasNext：計算屬性，檢查是否有下一章
				       - 與上一章按鈕對稱的狀態管理
				       - 在最後一章時禁用，防止無效操作
				-->
				<button class="control-btn" @click="goToNext" :disabled="!hasNext||isLoading">下一話</button>
			</div>
			
			<!-- ==========================================================================
			     設定模態框：多功能的設定和導航面板
			     ==========================================================================
			     提供閱讀設定和章節目錄兩種模式，支持完整的用戶定制功能
			     使用動態內容和條件渲染實現靈活的界面切換
			     ========================================================================== -->
			
			<!-- 設定模態框主容器：動態顯示的功能面板
			     Vue.js動態類別繫定詳解：
			     - class="settings-modal"：模態框的基礎樣式
			       - 固定在螢幕底部，向上滝動顯示
			       - 設定最大高度和滝動行為
			       - 支持主題切換和響應式設計
			       - 提供圈角、陰影和背景效果
			     - :class="{active:showModal}"：條件顯示控制
			       - active：CSS類別，控制模態框的顯示/隱藏
			       - showModal：計算屬性，組合showSettings和showChapterMenu
			         * return showSettings || showChapterMenu
			         * 當任一面板打開時都顯示模態框
			         * 提供統一的外觀和動畫效果
			-->
			<div class="settings-modal" :class="{active:showModal}">
				
				<!-- 模態框標題：動態文字显示當前模式
				     Vue.js三元運算符詳解：
				     - {{showSettings?'閱讀設置':'章節目錄'}}：條件文字显示
				       - showSettings：布爾狀態，表示是否顯示設定面板
				       - ?：三元運算符的条件部分
				       - '閱讀設置'：showSettings為真時的文字
				       - :：三元運算符的分隔符
				       - '章節目錄'：showSettings為假時的文字
				     
				     交互設計考量：
				     - 清晰地显示當前模式，避免用戶困惑
				     - 提供直覺的標題描述，用戶知道當前功能
				     - 支持中文界面，提供在地化體驗
				-->
				<div class="settings-modal-header">{{showSettings?'閱讀設置':'章節目錄'}}</div>
				
				<!-- ==========================================================================
				     閱讀設定組：用戶個人化設定控制面板
				     ==========================================================================
				     提供字體、行高、寬度和主題等全面的閱讀體驗設定
				     支持即時預覽和響應式設計
				     ========================================================================== -->
				
				<!-- 設定組容器：條件渲染的設定面板
				     Vue.js條件渲染詳解：
				     - class="settings-group"：設定組的基礎樣式
				       - 提供合適的內邊距和元素間距
				       - 統一的表單元素樣式
				       - 支持主題切換和響應式佈局
				     - v-if="showSettings"：只在設定模式下顯示
				       - showSettings：Vue狀態，設定面板的開關
				       - 與章節選單互斥，確保一次只顯示一個面板
				       - 使用v-if而非v-show是因為設定面板內容較複雜
				-->
				<div class="settings-group" v-if="showSettings">
					
					<!-- 字體大小設定：滑桿控制和即時顯示
					     HTML表單設計考量：
					     - <label>：表單標籤，提供說明和當前值
					       - 字體大小: {{fontSize}}px：結合說明和動態值
					       - {{fontSize}}：文字插值，即時顯示當前設定
					       - px單位說明，用戶知道精確數值
					     
					     Vue.js雙向繫定詳解：
					     - type="range"：HTML5滑桿輸入控件
					     - v-model="fontSize"：Vue雙向數據繫定
					       - 當滑桿值改變時，fontSize狀態自動更新
					       - 當fontSize狀態改變時，滑桿位置自動更新
					       - 即時影響閱讀器內容的字體顯示
					     - min="14" max="24" step="1"：滑桿的範圍和精度
					       - 最小14px：確保文字在小螢幕上也可讀
					       - 最大24px：防止字體過大影響版面美觀
					       - 步長1px：提供精確的控制
					-->
					<label>字體大小: {{fontSize}}px</label>
					<input type="range" v-model="fontSize" min="14" max="24" step="1">
					
					<!-- 行高設定：滑桿控制和動態顯示
					     行高設計考量：
					     - <label>行距: {{lineHeight}}</label>：行高說明和當前值
					       - {{lineHeight}}：即時顯示當前行高值
					       - 不顯示單位是因為行高是倍數值（無單位）
					     
					     - v-model="lineHeight"：雙向繫定行高設定
					     - min="1.5" max="2.5" step="0.1"：行高範圍和精度
					       - 最小1.5倍：保證最小的可讀性
					       - 最大2.5倍：防止行間距過大浪費空間
					       - 步長0.1：提供細致的行高調整
					-->
					<label>行距: {{lineHeight}}</label>
					<input type="range" v-model="lineHeight" min="1.5" max="2.5" step="0.1">
					
					<!-- 內容寬度設定：桁面版本的條件顯示
					     Vue.js條件渲染和響應式設計：
					     - v-show="!isMobile"：只在非行動設備上顯示
					       - isMobile：計算屬性，檢測當前設備是否為行動設備
					       - !：邏輯非運算符，在非行動設備上才顯示
					       - 行動設備上隱藏這個設定的原因：
					         * 行動設備螢幕小，寬度調整意義不大
					         * 避免設定選項過多造成界面雜亂
					         * 提供更簡潔的行動體驗
					     
					     內容寬度設計：
					     - v-model="contentWidth"：雙向繫定內容寬度
					     - min="50" max="100" step="5"：寬度範圍和步長
					       - 最小50%：保證在大螢幕上有適合的閱讀寬度
					       - 最大100%：允許全寬显示
					       - 步長5%：提供合適的調整粒度
					-->
					<div v-show="!isMobile">
						<label>內容寬度: {{contentWidth}}%</label>
						<input type="range" v-model="contentWidth" min="50" max="100" step="5">
					</div>
					
					<!-- 主題切換設定：核取方塊和雙向繫定
					     HTML表單設計和用戶體驗：
					     - <label><input type="checkbox" ...>夜間模式</label>：內嵌樣式
					       - 核取方塊和文字在同一個<label>中
					       - 點擊文字也可以切換核取方塊狀態
					       - 提供更大的觸控目標區域
					     
					     Vue.js雙向繫定詳解：
					     - v-model="isDarkMode"：核取方塊的雙向繫定
					       - isDarkMode：布爾狀態，表示是否為暗色主題
					       - 核取方塊的checked屬性與isDarkMode同步
					       - 改變時自動觸發主題切換和儲存
					       - 即時影響整個應用的外觀
					-->
					<label><input type="checkbox" v-model="isDarkMode">夜間模式</label>
				</div>
				
				<!-- ==========================================================================
				     章節選單組：閱讀器中的章節導航面板
				     ==========================================================================
				     提供閱讀器中的快速章節切換功能，支持狀態顯示和直接跳轉
				     與詳情頁的章節列表在功能上類似但在設計上有所不同
				     ========================================================================== -->
				
				<!-- 章節選單容器：條件渲染的章節導航面板
				     Vue.js條件渲染詳解：
				     - class="settings-group"：與設定面板使用相同的樣式
				       - 保持視覺一致性和佈局結構
				       - 統一的內邊距、邊距和滿動行為
				     - v-if="showChapterMenu"：只在章節選單模式下顯示
				       - showChapterMenu：Vue狀態，章節選單的開關
				       - 與設定面板互斥，確保一次只顯示一個面板
				       - 使用v-if而非v-show是因為章節列表可能很長
				-->
				<div class="settings-group" v-if="showChapterMenu">
					
					<!-- 章節項目列表：Vue.js進階列表渲柕和狀態管理
					     這個列表渲柕結合了多個進階特性：
					     
					     列表渲柕詳解：
					     - v-for="chapter in allChapters"：遍歷所有章節
					       - allChapters：Vue數據，包含全部章節資訊
					       - chapter：當前循環項目，包含章節的所有屬性
					       - 與詳情頁使用相同的數據結構，保持一致性
					     
					     - :key="chapter.number"：唯一標識符和性能優化
					       - 使用章節編號確保唯一性
					       - 為Vue的Virtual DOM diff提供優化提示
					     
					     CSS類別組合設計：
					     - class="chapter-item"：章節項目的基礎樣式
					       - 與詳情頁相似的樣式，但可能有細微差異
					       - 適合閱讀器環境的尺寸和間距
					     
					     Vue.js複雜條件類別繫定：
					     - :class="{current:chapter.number===currentChapter?.number,read:isChapterRead(chapter.number)}"
					       - 這是一個對象，包含多個條件類別
					       - current：當前正在閱讀的章節標記
					         * chapter.number===currentChapter?.number：嚴格比較
					         * 可選鏈運算符(?)防止currentChapter為null時的錯誤
					         * 為當前章節提供突出的視覺效果
					       - read：已讀章節的視覺標記
					         * isChapterRead(chapter.number)：方法調用檢查狀態
					         * 與詳情頁使用相同的邏輯，保持一致性
					       - 這兩個類別可以同時存在（當前章節也可能是已讀）
					     
					     事件處理和導航：
					     - @click="goToChapterInReader(chapter.number)"：閱讀器中的章節跳轉
					       - goToChapterInReader()：專為閱讀器設計的導航方法
					       - 與詳情頁的goToChapter()不同：
					         * 不需要切換頁面，只更新內容
					         * 自動關閉章節選單，繼續閱讀
					         * 保持閱讀位置和設定
					-->
					<div v-for="chapter in allChapters" :key="chapter.number" class="chapter-item" :class="{current:chapter.number===currentChapter?.number,read:isChapterRead(chapter.number)}" @click="goToChapterInReader(chapter.number)">
						
						<!-- 章節標題顯示：簡化版的章節資訊
						     設計簡化考量：
						     - 只顯示標題，不顯示日期
						       - 閱讀器中空間有限，優先顯示最重要的資訊
						       - 日期資訊在閱讀時相對不重要
						     - 結構簡單，但功能完整
						       - 包裝在<div>中保持結構一致性
						       - 支持未來擴展（如需要添加其他資訊）
						     
						     Vue.js文字插值：
						     - {{chapter.title}}：安全的文字輸出
						       - 與詳情頁使用相同的數據源
						       - 自動轉義HTML字元，保證安全性
						       - 支持多語言和特殊字元
						-->
						<div>{{chapter.title}}</div>
					</div>
				</div>
			</div>
		</div>
		
		<!-- ==========================================================================
		     Lightbox 圖片查看器：全螢幕圖片顯示組件
		     ==========================================================================
		     提供沉浸式的圖片查看體驗，支持點擊關閉和惸停操作
		     使用現代的Web標準和可用性設計原則
		     ========================================================================== -->
		
		<!-- Lightbox主容器：全螢幕覆蓋的圖片顯示器
		     Vue.js事件處理和動態類別：
		     - class="lightbox"：燈箱的基礎樣式
		       - 全螢幕固定定位，覆蓋整個視窗
		       - 深色半透明背景，突出圖片內容
		       - Flexbox居中對齊，支持響應式設計
		       - 支持平滑的淡入淡出動畫
		     - :class="{active:isLightboxActive}"：動態顯示控制
		       - active：CSS類別，控制燈箱的顯示和動畫
		       - isLightboxActive：Vue狀態，燈箱的開關狀態
		       - 為真時燈箱淡入顯示，為假時淡出隱藏
		     
		     - @click="closeLightbox"：背景點擊關閉事件
		       - 點擊背景區域（非圖片部分）關閉燈箱
		       - closeLightbox()：關閉燈箱的方法
		       - 這是現代燈箱組件的標準交互模式
		-->
		<div class="lightbox" :class="{active:isLightboxActive}" @click="closeLightbox">
			
			<!-- 燈箱內容容器：圖片和控制按鈕的包裝容器
			     CSS設計考量：
			     - class="lightbox-content"：內容容器的樣式
			       - 相對定位，為絕對定位的關閉按鈕提供參考點
			       - 設定最大寬度和高度，防止圖片過大
			       - 保持適當的邊距，避免完全貼邊
			-->
			<div class="lightbox-content">
				
				<!-- 關閉按鈕：燈箱的關閉控制
				     Vue.js事件修飾符詳解：
				     - class="close-lightbox"：關閉按鈕的專用樣式
				       - 絕對定位在內容容器的右上角
				       - 使用白色文字，在深色背景上清晰可見
				       - 適當的字體大小和點擊區域
				     - @click.stop="closeLightbox"：事件處理和修飾符
				       - @click：點擊事件監聽器
				       - .stop：Vue事件修飾符，阻止事件冒泡
				         * 相當於event.stopPropagation()
				         * 防止點擊按鈕時觸發背景的點擊事件
				         * 確保只執行關閉操作，不會意外地觸發其他事件
				       - closeLightbox()：關閉燈箱的方法（與背景點擊相同）
				     
				     用戶體驗考量：
				     - ✕：使用Unicode乘號字元作為關閉圖標
				       - 普遍認知的關閉符號，無需額外解釋
				       - 不依賴外部圖標資源，提升載入速度
				       - 支持所有設備和瀏覽器
				-->
				<button class="close-lightbox" @click.stop="closeLightbox">✕</button>
				
				<!-- 燈箱內的圖片：主要內容元素
				     Vue.js屬性繫定和事件處理：
				     - :src="lightboxImage"：動態繫定圖片源地址
				       - lightboxImage：Vue狀態，儲存要顯示的圖片URL
				       - 由openLightbox()方法設定，通常來自小說封面或內容圖片
				       - 支持相對和絕對路徑
				     - alt=""：空白的替代文字
				       - 燈箱中的圖片通常是裝飾性的，不需要描述
				       - 防止螢幕閱讀器讀出不必要的內容
				     - @click.stop：阻止事件冒泡的空事件處理
				       - 點擊圖片本身不應該關閉燈箱
				       - .stop修飾符阻止事件傳播到父元素（背景）
				       - 用戶可以點擊圖片詳細查看，而不會意外關閉
				     
				     CSS設計和響應式：
				     - 圖片會自動縮放以適合螢幕尺寸
				     - object-fit: contain確保完整圖片可見
				     - 支持高解析度圖片和各種寬高比
				-->
				<img :src="lightboxImage" alt="" @click.stop>
			</div>
		</div>
		
		<!-- ==========================================================================
		     載入覆蓋層：全螢幕載入狀態指示器
		     ==========================================================================
		     提供全局載入狀態的視覺回饋，電止用戶操作直到載入完成
		     使用現代的CSS動畫和可用性設計原則
		     ========================================================================== -->
		
		<!-- 載入覆蓋層主容器：全螢幕阻礙和載入指示
		     Vue.js條件顯示和動態類別：
		     - class="loading-overlay"：載入覆蓋層的基礎樣式
		       - 全螢幕固定定位，覆蓋所有內容
		       - 半透明深色背景，突出載入指示
		       - Flexbox居中對齊，支持響應式設計
		       - 最高z-index，確保始終在最頂層
		     - :class="{show:isLoading}"：動態顯示控制
		       - show：CSS類別，控制覆蓋層的顯示/隱藏
		       - isLoading：Vue狀態，表示是否正在載入
		       - 載入時顯示覆蓋層，阻止用戶交互
		       - 載入完成時自動隱藏，恢復正常交互
		-->
		<div class="loading-overlay" :class="{show:isLoading}">
			
			<!-- 載入指示器容器：旋轉動畫和文字的容器
			     CSS佈局和設計：
			     - style="text-align:center;"：內聯樣式，設定文字居中
			       - 確保旋轉動畫和文字都在容器中心對齊
			       - 適用於所有子元素，包括區塊級元素
			       - 簡單有效的居中方法
			-->
			<div style="text-align:center;">
				
				<!-- 載入旋轉動畫：CSS純技術的旋轉指示器
				     CSS動畫設計詳解：
				     - class="loading-spinner"：旋轉動畫的專用樣式
				       - 創建圓形邊框和部分高亮效果
				       - 使用CSS @keyframes spin定義旋轉動畫
				       - 無限循環的平滑旋轉效果
				       - 輕量級、不依賴外部資源的載入指示
				     
				     設計優勢：
				     - 純CSS實現，不需要JavaScript或圖片
				     - 60fps的平滑動畫效果
				     - 支持所有現代瀏覽器
				     - 可以通過CSS輕易定制大小和顏色
				-->
				<div class="loading-spinner"></div>
				
				<!-- 載入文字：載入狀態的文字說明
				     用戶體驗考量：
				     - class="loading-text"：載入文字的專用樣式
				       - 適當的字體大小和顏色
				       - 與旋轉動畫的適當間距
				       - 支持主題切換和多語言
				     
				     文字內容設計：
				     - "載入中..."：簡單明瞭的中文提示
				       - 不使用太詳細的描述，避免分散注意力
				       - 省略號(...)表示進行中的狀態
				       - 通用性強，適用於各種載入情境
				     
				     可用性考量：
				     - 提供給螢幕閱讀器的文字資訊
				     - 輔助視覺指示，讓用戶了解當前狀態
				     - 在網路較慢時給予明確的等待預期
				-->
				<div class="loading-text">載入中...</div>
			</div>
		</div>
		
		<!-- ==========================================================================
		     網站頁腳：版權聲明和法律信息
		     ==========================================================================
		     提供必要的法律聲明和版權信息，在非閱讀模式下顯示
		     遵循網站責任和版權保護的最佳實踐
		     ========================================================================== -->
		
		<!-- 頁腳容器：條件顯示的法律聲明區域
		     Vue.js條件渲染詳解：
		     - <footer>：語意化HTML5標籤，表示頁面或區段的頁腳
		       - 支持螢幕閱讀器和搜尋引擎正確識別
		       - 提供清晰的文檔結構和資訊層次
		       - 遵循現代Web標準和可用性指南
		     
		     - v-show="currentPage!=='reader'"：在非閱讀模式下顯示
		       - 閱讀模式下隱藏頁腳，提供清爽的閱讀環境
		       - 在列表頁和詳情頁顯示，提供必要的法律信息
		       - 平衡用戶體驗和法律責任的需求
		       - 使用v-show而非v-if是因為頁腳內容簡單固定
		-->
		<footer v-show="currentPage!=='reader'">
			
			<!-- 版權聲明文字：法律保護和免責聲明
			     法律考量和內容設計：
			     - <p>：段落標籤，適合短的聲明文字
			     - style="font-size:0.8em;margin-top:1em;"：內聯樣式
			       - font-size:0.8em：較小的字體，不干擾主要內容
			       - margin-top:1em：上方適當的間距，與主內容分離
			       - 簡潔的版面布局，不太占用空間
			     
			     文字內容詳解：
			     - "此網站僅供學習和參考使用"：明確說明網站性質
			       - 非商業用途的聲明，減少法律風險
			       - 旨在教育和學習，符合合理使用原則
			     - "所有內容版權歸原作者所有"：版權尊重聲明
			       - 明確承認原作者的知識產權
			       - 表明網站不宣稱拇有原創內容的版權
			       - 遵循DMCA和其他版權法律的要求
			     
			     法律保護意義：
			     - 提供合理使用的法律依據
			     - 降低版權争議的風險
			     - 表明網站管理者的責任態度
			     - 遵循行業最佳實踐和法律規範
			-->
			<p style="font-size:0.8em;margin-top:1em;">此網站僅供學習和參考使用，所有內容版權歸原作者所有。</p>
		</footer>
	</div>
	<!-- =============================================================================
	     JavaScript 區塊：Vue.js 應用程式的核心邏輯
	     =============================================================================
	     這裡包含了整個單頁應用程式的JavaScript代碼
	     展示了Vue.js 3的現代開發模式和最佳實踐
	     ============================================================================= -->
	<script>
		/* ==========================================================================
		   Vue.js 應用程式初始化和常數定義
		   ==========================================================================
		   這個區塊設定了應用程式的基本結構和配置常數
		   ========================================================================== */
		
		/* Vue.js 3 解構賦值：從全域Vue對象中提取createApp函數
		   - const {createApp} = Vue：ES6解構賦值語法
		   - Vue：全域變數，由CDN載入的Vue.js庫提供
		   - createApp：Vue 3的應用程式創建函數，取代Vue 2的new Vue()
		   - 這種寫法更簡潔，只導入需要的功能
		*/
		const {createApp}=Vue;
		
		/* 本地存儲鍵值常數：集中管理localStorage的鍵名
		   軟體工程最佳實踐：
		   - 使用常數避免字符串拼寫錯誤
		   - 集中定義便於維護和修改
		   - 大寫命名遵循常數命名慣例
		   - 這種模式提高代碼可維護性和可靠性
		   
		   存儲項目說明：
		   - THEME：用戶選擇的主題(dark/light)
		   - SORT：內容排序方式(lastUpdated/chapterCount/wordCount)
		   - FONT_SIZE：閱讀器字體大小設定
		   - LINE_HEIGHT：閱讀器行高設定
		   - CONTENT_WIDTH：閱讀器內容寬度設定
		   - SCROLL_POSITION：各章節的滾動位置記錄
		   - READ_CHAPTERS：已讀章節的記錄
		   - CURRENT_NOVEL：當前瀏覽的小說
		*/
		const STORAGE_KEYS={
			THEME:'theme',
			SORT:'content_sort',
			FONT_SIZE:'font_size',
			LINE_HEIGHT:'line_height',
			CONTENT_WIDTH:'content_width',
			SCROLL_POSITION:'novel_scroll_position',
			READ_CHAPTERS:'read_chapters',
			CURRENT_NOVEL:'currentNovel'
		};
		
		/* ==========================================================================
		   Vue.js 應用程式實例創建
		   ==========================================================================
		   createApp()函數創建一個Vue應用程式實例，接收一個配置對象
		   這個對象定義了應用程式的所有行為和狀態
		   ========================================================================== */
		createApp({
			/* ==========================================================================
			   data函數：Vue.js響應式狀態的定義
			   ==========================================================================
			   data函數返回一個對象，包含組件的所有響應式狀態
			   Vue.js會自動將這些屬性轉換為響應式屬性，當值改變時自動更新視圖
			   ========================================================================== */
			
			/* Vue.js data函數：
			   - 必須是一個函數而非對象，確保每個組件實例有獨立的狀態副本
			   - 返回的對象中的所有屬性都會成為響應式屬性
			   - 當這些屬性的值改變時，Vue會自動重新渲染相關的DOM
			   - 這是Vue.js響應式系統的核心機制
			*/
			data(){
				return{
					/* ==========================================================================
					   頁面狀態管理：控制當前顯示的頁面和內容
					   ========================================================================== */
					
					/* 當前頁面狀態：單頁應用的路由狀態管理
					   - 'list'：首頁小說列表
					   - 'detail'：小說詳情頁
					   - 'reader'：閱讀器頁面
					   - 這個狀態控制整個應用的視圖切換
					*/
					currentPage:'list',
					
					/* ==========================================================================
					   數據存儲：應用程式的核心數據結構
					   ========================================================================== */
					
					/* 小說列表：從API載入的所有小說數據 */
					novelList:[],
					
					/* 當前選中的小說：用戶點擊的小說基本信息 */
					selectedNovel:null,
					
					/* 當前小說的詳細數據：包含章節列表、描述等完整信息 */
					selectedNovelData:null,
					
					/* 當前小說的所有章節：格式化後的章節列表 */
					allChapters:[],
					
					/* 當前閱讀的章節：閱讀器中顯示的章節對象 */
					currentChapter:null,
					
					/* 當前章節內容：從服務器載入的Markdown文本 */
					chapterContent:'',
					
					/* ==========================================================================
					   用戶偏好設定：從localStorage載入的個人化設定
					   ========================================================================== */
					
					/* 暗色模式狀態：布爾值，控制主題外觀
					   - localStorage.getItem()：從本地存儲讀取保存的主題偏好
					   - === 'dark'：嚴格比較，只有完全匹配'dark'字符串才為true
					   - 默認為false（亮色模式）
					*/
					isDarkMode:localStorage.getItem(STORAGE_KEYS.THEME)==='dark',
					
					/* 字體大小設定：閱讀器的字體大小（像素值）
					   - parseInt()：將字符串轉換為整數
					   - ||18：邏輯OR運算符，如果localStorage中沒有值則使用默認值18
					   - 這種模式提供了優雅的回退機制
					*/
					fontSize:parseInt(localStorage.getItem(STORAGE_KEYS.FONT_SIZE))||18,
					
					/* 行高設定：閱讀器的行距（倍數值）
					   - parseFloat()：將字符串轉換為浮點數
					   - ||1.8：默認行高1.8倍，提供良好的閱讀體驗
					*/
					lineHeight:parseFloat(localStorage.getItem(STORAGE_KEYS.LINE_HEIGHT))||1.8,
					
					/* 內容寬度：閱讀器內容區域的寬度百分比
					   - 默認80%，在大螢幕上提供舒適的閱讀寬度
					   - 可以通過設定面板調整
					*/
					contentWidth:parseInt(localStorage.getItem(STORAGE_KEYS.CONTENT_WIDTH))||80,
					
					/* 當前排序方式：小說列表的排序條件
					   - 'lastUpdated'：按最後更新時間排序（默認）
					   - 'chapterCount'：按章節數量排序
					   - 'wordCount'：按總字數排序
					*/
					currentSort:localStorage.getItem(STORAGE_KEYS.SORT)||'lastUpdated',
					
					/* 排序選項配置：定義所有可用的排序方式
					   - 這是一個靜態配置數組，定義下拉選單的選項
					   - 每個選項包含value（內部值）和label（顯示文字）
					   - 這種數據驅動的方式讓添加新排序方式變得簡單
					*/
					sortOptions:[
						{
							value:'lastUpdated',    // 內部標識值
							label:'最新更新'        // 用戶看到的文字
						},
						{
							value:'chapterCount',
							label:'章節數'
						},
						{
							value:'wordCount',
							label:'文字數'
						}
					],
					
					/* ==========================================================================
					   UI狀態管理：控制各種界面元素的顯示和行為
					   ========================================================================== */
					
					/* 活躍的下拉選單：當前打開的下拉選單標識
					   - null：沒有下拉選單打開
					   - 'sort'：排序下拉選單打開
					   - 這種設計支持多個下拉選單的狀態管理
					*/
					activeDropdown:null,
					
					/* 載入狀態：表示是否正在進行異步操作
					   - true：正在載入數據（顯示載入動畫，禁用按鈕）
					   - false：載入完成（正常交互狀態）
					   - 提升用戶體驗，避免重複點擊
					*/
					isLoading:false,
					
					/* 控制欄隱藏狀態：閱讀器中的UI自動隱藏功能
					   - true：隱藏導航欄和控制欄（沉浸式閱讀）
					   - false：顯示所有控制元素（正常狀態）
					   - 滾動時自動切換，提供更好的閱讀體驗
					*/
					hideControls:false,
					
					/* 設定面板顯示狀態：閱讀器設定面板的開關
					   - true：顯示設定面板
					   - false：隱藏設定面板
					   - 與showChapterMenu互斥，同一時間只能顯示一個面板
					*/
					showSettings:false,
					
					/* 章節選單顯示狀態：閱讀器中的章節導航面板
					   - true：顯示章節列表面板
					   - false：隱藏章節列表面板
					   - 與showSettings互斥，確保界面不會過於雜亂
					*/
					showChapterMenu:false,
					
					/* Lightbox激活狀態：圖片查看器的開關
					   - true：圖片查看器打開（全螢幕顯示圖片）
					   - false：圖片查看器關閉
					   - 點擊小說封面或內容中的圖片時激活
					*/
					isLightboxActive:false,
					
					/* Lightbox圖片URL：當前在查看器中顯示的圖片地址
					   - 存儲要在lightbox中顯示的圖片URL
					   - 當isLightboxActive為true時使用
					*/
					lightboxImage:'',
					
					/* 上次滾動位置：用於滾動方向檢測
					   - 記錄上一次的滾動位置
					   - 與當前滾動位置比較，判斷滾動方向
					   - 用於實現滾動時自動隱藏/顯示控制欄
					*/
					lastScrollTop:0,
					
					/* 移動設備檢測：判斷當前是否為移動設備
					   - true：移動設備（觸控螢幕、小螢幕）
					   - false：桌面設備（滑鼠操作、大螢幕）
					   - 用於調整某些功能的行為，提供更適合的交互方式
					*/
					isMobile:false
				}
			},
			
			/* ==========================================================================
			   computed（計算屬性）：Vue.js的響應式衍生狀態
			   ==========================================================================
			   計算屬性基於響應式依賴進行緩存，只有依賴改變時才重新計算
			   這比在模板中調用方法更高效，避免了不必要的重複計算
			   ========================================================================== */
			computed:{
				/* 小說鍵值：用於localStorage的唯一標識
				   計算屬性優勢：
				   - 響應式：當selectedNovel改變時自動更新
				   - 緩存：只有依賴變化時才重新計算
				   
				   實現詳解：
				   - this.selectedNovel?.title：可選鏈操作符，安全地訪問title
				   - replace(/^《|》$/g,'')：正則表達式移除標題前後的書名號
				   - ^《：匹配開頭的《
				   - 》$：匹配結尾的》
				   - g標志：全局匹配
				   - 結果用作localStorage的鍵值，避免特殊字符問題
				*/
				novelKey(){
					return this.selectedNovel?.title.replace(/^《|》$/g,'');
				},
				
				/* 模態框顯示狀態：統一管理多個模態框的顯示
				   邏輯OR運算：
				   - 當設定面板或章節選單任一顯示時，這個計算屬性為true
				   - 用於控制背景遮罩層的顯示
				   - 簡化模板中的條件判斷
				*/
				showModal(){
					return this.showSettings||this.showChapterMenu;
				},
				
				/* 當前排序標籤：動態顯示當前排序方式的標籤
				   Array.find()方法應用：
				   - 在sortOptions數組中查找匹配currentSort的選項
				   - opt.value===this.currentSort：比較選項值與當前排序
				   - ?.label：可選鏈獲取標籤，如果找到選項則返回其label
				   - ||'排序'：回退值，確保總是有文字顯示
				   - 這種模式提供了安全的數據訪問和友好的回退機制
				*/
				currentSortLabel(){
					return this.sortOptions.find(opt=>opt.value===this.currentSort)?.label||'排序';
				},
				
				/* 格式化最後更新時間：返回一個格式化日期的函數
				   高階函數模式：
				   - 計算屬性返回一個函數，而不是直接的值
				   - 這個函數可以在模板中被調用，傳入不同的參數
				   - (item)=>：箭頭函數接收小說項目作為參數
				   - new Date(item.lastUpdated)：將字符串轉換為Date對象
				   - .toLocaleDateString()：格式化為本地日期格式
				   - 這種模式平衡了性能和靈活性
				*/
				formattedLastUpdated(){
					return(item)=>new Date(item.lastUpdated).toLocaleDateString();
				},
				
				/* 排序後的小說列表：根據用戶選擇動態排序
				   響應式排序實現：
				   - [...this.novelList]：展開運算符創建數組副本，避免修改原數組
				   - .sort((a,b)=>...)：使用比較函數排序
				   - switch語句：根據currentSort選擇不同的排序邏輯
				   
				   排序邏輯詳解：
				   - lastUpdated：比較日期，新的在前（降序）
				   - chapterCount：比較章節數量，多的在前
				   - wordCount：比較總字數，多的在前
				   - (b.chapters||[])：使用空數組作為回退，避免undefined錯誤
				   - default: return 0：保持原有順序
				*/
				sortedNovelList(){
					return[...this.novelList].sort((a,b)=>{
						switch(this.currentSort){
							case'lastUpdated':
								return new Date(b.lastUpdated)-new Date(a.lastUpdated);
							case'chapterCount':
								return(b.chapters||[]).length-(a.chapters||[]).length;
							case'wordCount':
								return(b.totalWordCount||0)-(a.totalWordCount||0);
							default:
								return 0;
						}
					});
				},
				
				/* 帶日期的章節列表：按章節號倒序排列
				   簡單排序：
				   - sort((a,b)=>b.number-a.number)：按章節號降序排列
				   - 最新章節顯示在最前面
				   - 提供更直觀的章節瀏覽體驗
				*/
				chaptersWithDates(){
					return this.allChapters.sort((a,b)=>b.number-a.number);
				},
				/* 解析後的小說描述：將Markdown轉換為HTML
				   Markdown解析流程：
				   - this.selectedNovel?.description：安全地獲取小說描述文本
				   - ?操作符：如果selectedNovel為null/undefined，則跳過後續操作
				   - marked.parse()：marked.js函數庫的主要API，將Markdown轉換為HTML
				   - 三元運算符：如果描述存在則解析，否則返回空字符串
				   
				   Markdown語法支持：
				   - **粗體**、*斜體*、***粗斜體***
				   - 標題（# ## ### 等）
				   - 列表（有序和無序）
				   - 鏈接 [文字](URL)
				   - 圖片 ![alt](URL)
				   - 程式碼塊和行內程式碼
				   
				   安全性考量：
				   - marked.js會適當處理HTML標籤
				   - 在生產環境中可能需要額外的HTML消毒
				*/
				parsedDescription(){
					return this.selectedNovel?.description?marked.parse(this.selectedNovel.description):'';
				},
				
				/* 解析後的章節內容：將Markdown章節內容轉換為HTML
				   實際應用詳解：
				   - this.chapterContent：當前載入的章節原始Markdown文本
				   - marked.parse()：將輕小說的Markdown格式轉換為富文本HTML
				   - 這讓作者可以使用Markdown語法撰寫，讀者看到格式化的內容
				   
				   輕小說Markdown慣例：
				   - 段落間的空行會轉換為<p>標籤
				   - **對話**可以用粗體強調
				   - *心理描述*可以用斜體表示
				   - ---分隔線表示場景轉換
				   - 支援日文書式文檔格式
				   
				   性能優化：
				   - 計算屬性確保只有內容變化時才重新解析
				   - 避免了每次重新渲染時都執行Markdown解析
				*/
				parsedContent(){
					return this.chapterContent?marked.parse(this.chapterContent):'';
				},
				
				/* 是否有下一章：檢查是否存在更大章節號的章節
				   Array.some()方法應用：
				   - .some()：測試數組中是否至少有一個元素滿足條件
				   - chapter=>chapter.number>this.currentChapter?.number：比較函數
				   - 只要找到一個章節號大於當前章節的就返回true
				   - 效率高：找到第一個匹配項就停止搜索
				   
				   章節導航邏輯：
				   - 用於控制「下一章」按鈕的顯示狀態
				   - 如果當前是最後一章，按鈕會被禁用或隱藏
				   - 提供良好的用戶體驗和導航指示
				   
				   可選鏈運算符（?.）：
				   - this.currentChapter?.number：安全地訪問章節號
				   - 如果currentChapter為null，表達式返回undefined
				   - 任何數字都大於undefined，所以會正確處理初始狀態
				*/
				hasNext(){
					return this.allChapters.some(chapter=>chapter.number>this.currentChapter?.number);
				},
				
				/* 是否有上一章：檢查是否存在更小章節號的章節
				   鏡像邏輯：
				   - 與hasNext()相對應，檢查是否有更小的章節號
				   - chapter.number<this.currentChapter?.number：比較條件
				   - 用於控制「上一章」按鈕的狀態
				   
				   邊界條件處理：
				   - 如果當前是第一章，此計算屬性返回false
				   - 如果currentChapter為null（未載入章節），返回false
				   - 確保導航按鈕在所有狀態下都有正確的行為
				   
				   用戶體驗設計：
				   - 配合hasNext()提供完整的章節導航指示
				   - 讓用戶清楚知道還有多少內容可以閱讀
				   - 避免用戶點擊無效的導航按鈕
				*/
				hasPrevious(){
					return this.allChapters.some(chapter=>chapter.number<this.currentChapter?.number);
				}
			},
			
			/* ==========================================================================
			   watch（監聽器）：Vue.js的響應式數據監聽機制
			   ==========================================================================
			   監聽器用於執行副作用操作，如DOM操作、API調用、localStorage等
			   當被監聽的響應式數據發生變化時，對應的處理函數會被自動調用
			   ========================================================================== */
			watch:{
				/* 暗色模式監聽器：當主題切換時同步更新DOM和本地存儲
				   副作用操作詳解：
				   - newValue：Vue自動傳入的新值（true或false）
				   - 三元運算符：newValue?'dark':'light'
				   - document.documentElement：HTML根元素<html>
				   - setAttribute('data-theme',theme)：設置HTML屬性
				   
				   主題切換機制：
				   - CSS使用[data-theme="dark"]選擇器應用不同樣式
				   - 這比添加/移除class更語義化
				   - 可以支持多種主題（light、dark、auto等）
				   
				   持久化存儲：
				   - localStorage.setItem()：將用戶偏好保存到瀏覽器
				   - 下次訪問時會自動恢復用戶的主題選擇
				   - 提供一致的用戶體驗
				*/
				isDarkMode(newValue){
					const theme=newValue?'dark':'light';
					document.documentElement.setAttribute('data-theme',theme);
					localStorage.setItem(STORAGE_KEYS.THEME,theme);
				},
				
				/* 字體大小監聽器：實時更新CSS變量和本地存儲
				   CSS變量動態更新：
				   - document.documentElement.style.setProperty()：動態設置CSS自定義屬性
				   - '--fs'：對應CSS中的var(--fs)變量
				   - `${newValue}px`：模板字符串，確保單位正確
				   
				   實時響應機制：
				   - 用戶調整滑塊時，字體大小立即變化
				   - 無需刷新頁面，提供流暢的設定體驗
				   - CSS變量會影響所有使用--fs的元素
				   
				   性能優化：
				   - 直接修改CSS變量比重新計算所有樣式更高效
				   - 瀏覽器會自動重新應用相關樣式
				*/
				fontSize(newValue){
					document.documentElement.style.setProperty('--fs',`${newValue}px`);
					localStorage.setItem(STORAGE_KEYS.FONT_SIZE,newValue);
				},
				
				/* 行高監聽器：控制文本的垂直間距
				   閱讀體驗優化：
				   - '--lh'：對應CSS中的line-height屬性
				   - newValue：直接使用數值（如1.8），CSS會解釋為倍數
				   - 行高影響文本的可讀性和視覺舒適度
				   
				   無單位數值：
				   - line-height可以使用無單位數值
				   - 表示相對於字體大小的倍數
				   - 這種方式在字體大小變化時會保持相對比例
				*/
				lineHeight(newValue){
					document.documentElement.style.setProperty('--lh',newValue);
					localStorage.setItem(STORAGE_KEYS.LINE_HEIGHT,newValue);
				},
				
				/* 內容寬度監聽器：調整閱讀區域的寬度
				   響應式佈局控制：
				   - '--content-width'：控制主要內容區域的寬度
				   - `${newValue}%`：百分比單位，相對於容器寬度
				   - 在大螢幕上限制行長度可以提升閱讀體驗
				   
				   閱讀舒適度：
				   - 過寬的文本行會讓眼睛難以追蹤
				   - 適當的行長度（約50-75字符）最為舒適
				   - 用戶可以根據螢幕大小和個人偏好調整
				*/
				contentWidth(newValue){
					document.documentElement.style.setProperty('--content-width',`${newValue}%`);
					localStorage.setItem(STORAGE_KEYS.CONTENT_WIDTH,newValue);
				},
				
				/* 當前頁面監聽器：管理頁面切換時的事件監聽器
				   生命週期管理：
				   - 進入閱讀器頁面時添加滾動監聽器
				   - 離開閱讀器頁面時移除滾動監聽器
				   - 避免內存洩漏和不必要的計算
				   
				   this.$nextTick()詳解：
				   - Vue的DOM更新是異步的
				   - $nextTick確保DOM更新完成後再執行回調
				   - 在DOM準備好之後再添加事件監聽器
				   
				   事件監聽器管理：
				   - window.addEventListener()：添加全局滾動監聽器
				   - this.handleScroll：滾動處理函數（實現自動隱藏控制欄）
				   - this.setupImageViewer()：初始化圖片查看器
				   - removeEventListener()：清理資源，防止內存洩漏
				*/
				currentPage(newValue){
					if(newValue==='reader'){
						this.$nextTick(()=>{
							window.addEventListener('scroll',this.handleScroll);
							this.setupImageViewer();
						});
					}else{
						window.removeEventListener('scroll',this.handleScroll);
					}
				}
			},
			
			/* ==========================================================================
			   methods（方法）：Vue.js應用程式的功能實現
			   ==========================================================================
			   方法包含應用程式的所有業務邏輯、事件處理器、API調用等
			   與計算屬性不同，方法每次調用都會執行，不會被緩存
			   ========================================================================== */
			methods:{
				/* 獲取小說列表：從API載入所有小說的基本信息
				   異步函數（async/await）詳解：
				   - async函數：標記函數為異步，可以使用await關鍵字
				   - await：暫停函數執行，等待Promise解析
				   - 使代碼看起來像同步，但實際上是非阻塞的
				   
				   錯誤處理機制：
				   - try-catch：捕獲異步操作中的錯誤
				   - 網絡錯誤、JSON解析錯誤、文件不存在等都會被捕獲
				   - console.error()：將錯誤信息輸出到開發者控制台
				   
				   Fetch API應用：
				   - fetch()：現代瀏覽器的網絡請求API
				   - 替代傳統的XMLHttpRequest
				   - 返回Promise，與async/await配合使用
				   - response.json()：將響應體解析為JSON對象
				*/
				async fetchNovelList(){
					try{
						/* 網絡請求：獲取小說列表JSON文件
						   相對路徑：'輕小說翻譯/novels.json'
						   - 相對於當前HTML文件的位置
						   - 這個文件包含所有小說的元數據
						   - 包括標題、作者、章節列表、更新時間等
						*/
						const response=await fetch('輕小說翻譯/novels.json');
						
						/* JSON解析：將響應轉換為JavaScript對象
						   await response.json()：
						   - response.json()返回Promise
						   - await等待JSON解析完成
						   - 如果JSON格式錯誤會拋出異常
						*/
						const data=await response.json();
						
						/* 數據轉換：將原始數據轉換為應用程式需要的格式
						   Array.map()方法：
						   - 遍歷每個小說對象
						   - 返回新的格式化對象
						   - 不修改原始數組，保持函數純粹性
						   
						   數據標準化：
						   - 確保標題包含書名號《》
						   - 生成標準化的封面圖片路徑
						   - 提供默認值避免undefined錯誤
						   - 保留原始數據以備後用
						*/
						this.novelList=data.novels.map(novel=>{
							/* 標題標準化：確保所有標題都有書名號
							   邏輯判斷：
							   - startsWith('《')：檢查標題是否已有書名號
							   - 三元運算符：有則保持原樣，沒有則添加
							   - 統一的格式便於顯示和處理
							*/
							const titleWithBrackets=novel.title.startsWith('《')?novel.title:`《${novel.title}》`;
							
							/* 返回標準化的小說對象：
							   封面圖片路徑生成：
							   - 使用模板字符串構建相對路徑
							   - encodeURIComponent()：處理標題中的特殊字符
							   - 確保URL安全，避免路徑錯誤
							   
							   默認值處理：
							   - ||運算符：如果左側為falsy則使用右側默認值
							   - 防止undefined/null值導致的錯誤
							   - 提供合理的回退數據
							*/
							return{
								title:titleWithBrackets,                    // 標準化的標題
								coverUrl:`輕小說翻譯/${encodeURIComponent(titleWithBrackets)}/cover.jpg`,  // 封面圖片路徑
								lastUpdated:novel.lastUpdated||new Date().toISOString(),  // 最後更新時間
								author:novel.author||'未知作者',           // 作者信息
								chapters:novel.chapters||[],              // 章節列表
								totalWordCount:novel.totalWordCount||0,   // 總字數
								originalData:novel                         // 保留原始數據
							};
						});
					}catch(error){
						/* 錯誤處理：記錄錯誤並提供用戶反饋
						   console.error()：
						   - 在開發者控制台顯示錯誤信息
						   - 包含完整的錯誤對象，便於調試
						   - 在生產環境中可以改為用戶友好的提示
						*/
						console.error('讀取小說列表失敗:',error);
					}
				},
				/* 更新URL：實現單頁應用的路由功能
				   單頁應用路由原理：
				   - 不刷新頁面的情況下改變URL
				   - 使用History API管理瀏覽器歷史
				   - 讓用戶可以使用瀏覽器的前進/後退按鈕
				   - 支持書籤和分享鏈接
				   
				   URL結構設計：
				   - 首頁：/
				   - 小說詳情：/?title=《小說名》
				   - 閱讀器：/?title=《小說名》&chapter=章節號
				   - 查詢參數包含所有必要的狀態信息
				*/
				updateUrl(page,params={}){
					/* 獲取當前路徑：window.location.pathname
					   - 只獲取路徑部分，不包含查詢參數
					   - 為了構建新的完整URL
					*/
					let url=window.location.pathname;
					
					/* URLSearchParams：現代瀏覽器的查詢參數處理API
					   - 自動處理URL編碼
					   - 提供便利的get/set方法
					   - 比手動字符串拼接更安全可靠
					*/
					const searchParams=new URLSearchParams();
					
					/* 條件性URL參數：根據頁面類型添加相應參數
					   detail頁面：只需要title參數
					   reader頁面：需要title和chapter參數
					   - 使用邏輯AND確保參數存在
					   - 避免無效的URL參數
					*/
					if(page==='detail'&&params.title){
						searchParams.set('title',params.title);
					}else if(page==='reader'&&params.title&&params.chapter){
						searchParams.set('title',params.title);
						/* .toString()：確保章節號為字符串格式
						   - URL參數必須是字符串
						   - 避免類型轉換錯誤
						*/
						searchParams.set('chapter',params.chapter.toString());
					}
					
					/* 構建完整URL：
					   - searchParams.toString()：生成查詢字符串
					   - 三元運算符：有參數時添加?，沒有則保持原路徑
					   - 確保URL格式正確
					*/
					const queryString=searchParams.toString();
					const newUrl=queryString?`${url}?${queryString}`:url;
					
					/* History API：更新瀏覽器歷史和地址欄
					   window.history.pushState()詳解：
					   - 第一個參數：狀態對象，包含頁面狀態信息
					   - 第二個參數：頁面標題（大多數瀏覽器忽略）
					   - 第三個參數：新的URL
					   - 不會觸發頁面刷新，只更新地址欄和歷史記錄
					*/
					window.history.pushState({page,params},'',newUrl);
					
					/* 同步更新頁面標題：保持標題與內容一致 */
					this.updatePageTitle(page,params);
				},
				
				/* 更新頁面標題：根據當前頁面動態設置document.title
				   SEO和用戶體驗：
				   - 有意義的頁面標題提升SEO效果
				   - 用戶在瀏覽器標籤中看到相關信息
				   - 書籤時會使用頁面標題
				   
				   標題層級設計：
				   - 首頁：輕小說翻譯
				   - 詳情頁：《小說名》 - 輕小說翻譯
				   - 閱讀器：章節名 - 《小說名》 - 輕小說翻譯
				   - 從具體到一般的信息層級
				*/
				updatePageTitle(page,params={}){
					/* 默認標題：網站名稱 */
					let title='輕小說翻譯';
					
					/* 詳情頁標題：小說名 + 網站名 */
					if(page==='detail'&&params.title){
						title=`${params.title} - 輕小說翻譯`;
					}
					/* 閱讀器標題：章節名 + 小說名 + 網站名
					   - 需要確保currentChapter已載入
					   - 提供最具體的上下文信息
					*/
					else if(page==='reader'&&params.title&&this.currentChapter){
						title=`${this.currentChapter.title} - ${params.title} - 輕小說翻譯`;
					}
					
					/* 設置文檔標題：直接修改DOM */
					document.title=title;
				},
				
				/* 處理URL參數：應用程式啟動時根據URL恢復狀態
				   深鏈接支持：
				   - 用戶可以直接訪問特定小說或章節
				   - 刷新頁面後保持當前位置
				   - 支持分享和書籤功能
				   
				   狀態恢復流程：
				   1. 解析URL參數
				   2. 載入必要的數據
				   3. 設置應用狀態
				   4. 導航到正確頁面
				*/
				async handleUrlParams(){
					/* 解析當前URL的查詢參數
					   window.location.search：包含?和後面的查詢字符串
					   URLSearchParams：解析查詢字符串為鍵值對
					*/
					const urlParams=new URLSearchParams(window.location.search);
					const titleParam=urlParams.get('title');     // 小說標題
					const chapterParam=urlParams.get('chapter'); // 章節號
					
					/* 處理帶標題的URL：小說詳情或閱讀器頁面 */
					if(titleParam){
						/* 確保小說列表已載入：
						   - 如果列表為空則先載入
						   - 避免查找不到小說的問題
						*/
						if(this.novelList.length===0){
							await this.fetchNovelList();
						}
						
						/* 查找對應的小說：
						   - 使用Array.find()精確匹配標題
						   - 標題必須完全一致（包括書名號）
						*/
						const novel=this.novelList.find(n=>n.title===titleParam);
						
						if(novel){
							/* 設置小說數據：恢復選中狀態 */
							this.selectedNovel=novel;
							this.selectedNovelData=novel.originalData;
							this.setupNovelDetail();
							
							/* 記錄到本地存儲：保持一致性 */
							localStorage.setItem(STORAGE_KEYS.CURRENT_NOVEL,titleParam);
							
							/* 處理章節參數：如果有章節號則直接進入閱讀器 */
							if(chapterParam){
								/* 解析章節號：
								   - parseFloat()：支持小數章節號（如1.5）
								   - 在某些輕小說中可能有番外篇使用小數編號
								*/
								const chapterNumber=parseFloat(chapterParam);
								this.currentChapter=this.allChapters.find(ch=>ch.number===chapterNumber);
								
								if(this.currentChapter){
									/* 進入閱讀器：載入章節內容 */
									this.currentPage='reader';
									await this.loadChapterContent();
								}else{
									/* 章節不存在：回到詳情頁並修正URL */
									this.currentPage='detail';
									this.updateUrl('detail',{title:titleParam});
								}
							}else{
								/* 只有標題參數：進入詳情頁 */
								this.currentPage='detail';
							}
						}else{
							/* 小說不存在：回到首頁 */
							this.goToHome();
						}
					}else{
						/* 沒有參數：顯示小說列表 */
						this.currentPage='list';
					}
				},
				/* 回到首頁：重置應用狀態並返回小說列表
				   狀態清理：
				   - 清除當前選中的小說和章節
				   - 關閉所有下拉選單
				   - 重置頁面狀態為列表視圖
				   
				   URL和歷史管理：
				   - 使用pushState更新瀏覽器歷史
				   - 設置正確的頁面標題
				   - 確保瀏覽器前進/後退按鈕正常工作
				*/
				goToHome(){
					/* 重置核心狀態：清除選中的內容 */
					this.currentPage='list';
					this.selectedNovel=null;
					this.currentChapter=null;
					this.activeDropdown=null;
					
					/* 更新瀏覽器歷史：
					   - {page:'list'}：狀態對象，記錄頁面類型
					   - '輕小說翻譯'：頁面標題（大多數瀏覽器忽略）
					   - window.location.pathname：保持原路徑，清除查詢參數
					*/
					window.history.pushState({page:'list'},'輕小說翻譯',window.location.pathname);
					document.title='輕小說翻譯';
					
					/* 滾動到頂部：提供一致的用戶體驗
					   this.$nextTick()：確保DOM更新完成後再滾動
					   - Vue的響應式更新是異步的
					   - 等待頁面內容渲染完成
					   - 然後平滑滾動到頂部
					*/
					this.$nextTick(()=>window.scrollTo(0,0));
				},
				
				/* 進入小說詳情頁：顯示特定小說的信息和章節列表
				   參數處理：
				   - novel：從小說列表點擊傳入的小說對象
				   - 包含所有必要的小說信息
				   
				   狀態設置流程：
				   1. 設置選中的小說
				   2. 初始化詳情頁數據
				   3. 更新頁面狀態
				   4. 同步URL和存儲
				*/
				goToDetail(novel){
					/* 設置小說數據：
					   - selectedNovel：當前選中的小說（顯示用）
					   - selectedNovelData：小說的原始數據（詳細信息）
					   - setupNovelDetail()：初始化詳情頁相關數據
					*/
					this.selectedNovel=novel;
					this.selectedNovelData=novel.originalData;
					this.setupNovelDetail();
					
					/* 更新UI狀態：
					   - 切換到詳情頁面
					   - 關閉可能打開的下拉選單
					   - 保持界面整潔
					*/
					this.currentPage='detail';
					this.activeDropdown=null;
					
					/* 持久化存儲：記錄用戶最後閱讀的小說
					   - 下次訪問時可以快速回到這本小說
					   - 提供更好的用戶體驗
					*/
					localStorage.setItem(STORAGE_KEYS.CURRENT_NOVEL,novel.title);
					
					/* 同步URL：支持深鏈接和分享 */
					this.updateUrl('detail',{title:novel.title});
					
					/* 滾動到頂部：每次進入新頁面都從頂部開始 */
					this.$nextTick(()=>window.scrollTo(0,0));
				},
				
				/* 從詳情頁進入章節：點擊章節列表項時調用
				   直接跳轉模式：
				   - 從章節列表直接跳到閱讀器
				   - 適用於詳情頁的章節選擇
				   
				   流程：找到章節 → 載入內容 → 進入閱讀器
				*/
				goToChapter(chapterNumber){
					/* 查找目標章節：
					   - 在所有章節中找到匹配的章節號
					   - 章節號通常是數字（1, 2, 3...）
					   - 支持小數章節號（如番外篇1.5）
					*/
					this.currentChapter=this.allChapters.find(ch=>ch.number===chapterNumber);
					
					/* 載入章節內容：異步獲取章節文本 */
					this.loadChapterContent();
					
					/* 切換到閱讀器：
					   - 關閉章節選單（如果有打開）
					   - 更新頁面狀態為閱讀器模式
					*/
					this.currentPage='reader';
					this.showChapterMenu=false;
					
					/* 更新URL：包含小說標題和章節號 */
					this.updateUrl('reader',{title:this.selectedNovel.title,chapter:chapterNumber});
				},
				
				/* 在閱讀器中切換章節：已在閱讀器中時的章節切換
				   智能切換：
				   - 檢查是否確實需要切換（避免重複載入）
				   - 防止在載入過程中重複觸發
				   - 保存當前滾動位置
				   
				   性能優化：
				   - 只有章節號不同且不在載入中才執行
				   - 避免不必要的網絡請求和DOM操作
				*/
				goToChapterInReader(chapterNumber){
					/* 條件檢查：確保切換是必要且安全的
					   - chapterNumber!==this.currentChapter?.number：章節號確實不同
					   - !this.isLoading：沒有正在進行的載入操作
					   - 避免重複載入相同章節
					   - 防止載入衝突
					*/
					if(chapterNumber!==this.currentChapter?.number&&!this.isLoading){
						/* 保存滾動位置：記錄當前閱讀進度
						   - 用戶可能想要回到之前的位置
						   - 提供更好的閱讀體驗
						*/
						this.saveScrollPosition();
						
						/* 切換章節：設置新章節並載入內容 */
						this.currentChapter=this.allChapters.find(ch=>ch.number===chapterNumber);
						this.loadChapterContent();
						
						/* 更新URL：反映當前章節 */
						this.updateUrl('reader',{title:this.selectedNovel.title,chapter:chapterNumber});
					}
					
					/* 關閉章節選單：切換完成後隱藏選單 */
					this.showChapterMenu=false;
				},
				
				/* 從閱讀器返回詳情頁：退出閱讀模式
				   狀態清理：
				   - 重置閱讀器相關的UI狀態
				   - 清除可能顯示的控制面板
				   - 恢復正常的頁面佈局
				   
				   用戶體驗：
				   - 平滑過渡回詳情頁
				   - 保持小說選中狀態
				   - 滾動到頂部重新開始瀏覽
				*/
				goBackToDetail(){
					/* 切換頁面模式：回到詳情頁 */
					this.currentPage='detail';
					
					/* 重置閱讀器UI狀態：
					   - hideControls：顯示所有控制元素
					   - showSettings：關閉設定面板
					   - showChapterMenu：關閉章節選單
					   - 確保界面回到正常狀態
					*/
					this.hideControls=false;
					this.showSettings=false;
					this.showChapterMenu=false;
					
					/* 更新URL：移除章節參數，只保留小說標題 */
					this.updateUrl('detail',{title:this.selectedNovel.title});
					
					/* 滾動到頂部：重新開始瀏覽詳情 */
					this.$nextTick(()=>window.scrollTo(0,0));
				},
				/* 設置小說詳情：處理和格式化小說的詳細信息
				   數據整合和處理：
				   - 從原始數據中提取和格式化有用信息
				   - 解析來源鏈接，支持多個平台
				   - 生成標準化的章節列表
				   - 為詳情頁顯示準備所有必要數據
				*/
				setupNovelDetail(){
					/* 防護性檢查：確保有選中的小說數據
					   - 如果沒有數據則提早返回
					   - 避免後續處理時的錯誤
					*/
					if(!this.selectedNovelData){
						return;
					}
					
					/* 解析來源鏈接：處理原文網站的URL
					   多平台支持：
					   - kakuyomu.jp：カクヨム平台
					   - syosetu.com：小説家になろう平台
					   - 其他：通用日文原文鏈接
					   
					   URL處理邏輯：
					   - split('、')：按中文頓號分割多個URL
					   - forEach遍歷每個URL並分類
					   - 根據域名判斷平台類型
					*/
					const sourceLinks={};
					if(this.selectedNovelData.originalUrl){
						const urls=this.selectedNovelData.originalUrl.split('、');
						urls.forEach(url=>{
							/* 平台檢測：根據URL域名分類
							   - includes()方法檢查URL是否包含特定域名
							   - 支援未來擴展更多平台
							*/
							if(url.includes('kakuyomu.jp')){
								sourceLinks.kakuyomu=url;
							}else if(url.includes('syosetu.com')){
								sourceLinks.syosetu=url;
							}else{
								sourceLinks.japanese=url;  // 其他日文原文網站
							}
						});
					}
					
					/* 擴展小說對象：添加詳情頁需要的額外信息
					   展開運算符（...）：
					   - 保留現有的小說基本信息
					   - 添加新的詳細信息屬性
					   - 創建新對象而不修改原對象
					   
					   數據處理：
					   - tags?.join(', ')：安全地連接標籤為字符串
					   - ||操作符：提供默認值
					   - 確保所有字段都有有效值
					*/
					this.selectedNovel={
						...this.selectedNovel,                                         // 保留原有屬性
						genres:this.selectedNovelData.tags?.join(', ')||'',           // 標籤轉換為類型字符串
						description:this.selectedNovelData.description||'',          // 小說描述
						sourceLinks:sourceLinks                                       // 來源鏈接對象
					};
					
					/* 處理章節列表：將原始章節數據轉換為標準格式
					   多步處理流程：
					   1. filter：過濾有效章節（id>=0）
					   2. map：轉換為標準格式
					   3. sort：按章節號排序
					   
					   章節過濾：
					   - chapter.id>=0：排除負數ID的特殊章節
					   - 某些小說可能有-1等特殊標記的章節
					*/
					this.allChapters=this.selectedNovelData.chapters
						.filter(chapter=>chapter.id>=0)
						.map(chapter=>({
							/* 章節對象標準化：
							   number：統一使用number作為章節號
							   title：章節標題
							   filename：構建文件路徑用的文件名
							   date：格式化的日期
							*/
							number:chapter.id,                                        // 章節號
							title:chapter.title,                                      // 章節標題
							
							/* 文件名生成：構建實際文件的路徑
							   模板字符串：`${chapter.id} ${processedTitle}.md`
							   - chapter.id：章節號前綴
							   - replace(/^第\d+\.?\d*話\s+/,'')：移除標題中的"第X話"前綴
							     - ^：匹配開頭
							     - 第：字面匹配"第"字
							     - \d+：一個或多個數字
							     - \.?\d*：可選的小數點和數字
							     - 話\s+：字面匹配"話"字加空白字符
							   - .md：添加Markdown文件擴展名
							*/
							filename:`${chapter.id} ${chapter.title.replace(/^第\d+\.?\d*話\s+/,'')}.md`,
							
							/* 日期格式化：轉換為ISO日期字符串
							   - new Date()：創建日期對象
							   - toISOString()：轉換為ISO格式
							   - split('T')[0]：只取日期部分（YYYY-MM-DD）
							*/
							date:new Date(chapter.lastUpdated).toISOString().split('T')[0]
						}))
						/* 章節排序：按章節號升序排列
						   - (a,b)=>a.number-b.number：數字比較函數
						   - 確保章節按正確順序顯示
						   - 支持小數章節號的正確排序
						*/
						.sort((a,b)=>a.number-b.number);
				},
				/* 獲取封面圖片URL：動態生成封面圖片的完整路徑
				   路徑構建邏輯：
				   - 基於小說標題動態生成封面路徑
				   - 使用encodeURIComponent處理特殊字符
				   - 確保文件路徑的URL安全性
				   
				   防護性處理：
				   - 三元運算符：只有選中小說時才生成路徑
				   - 避免undefined錯誤
				   - 提供空字符串作為默認值
				*/
				getCoverUrl(){
					/* 條件性URL生成：
					   - this.selectedNovel?：確保小說已選中
					   - encodeURIComponent()：編碼小說標題中的特殊字符
					     - 處理中文字符、標點符號、空格等
					     - 確保URL格式正確
					   - /cover.jpg：固定的封面文件名
					   - ''：沒有選中小說時返回空字符串
					*/
					return this.selectedNovel?`輕小說翻譯/${encodeURIComponent(this.selectedNovel.title)}/cover.jpg`:'';
				},
				
				/* 獲取來源鏈接顯示名稱：將平台鍵值轉換為友好的顯示名稱
				   國際化顯示：
				   - 為不同的原文平台提供正確的顯示名稱
				   - 支持日文原文網站名稱
				   - 提供用戶友好的鏈接標籤
				   
				   擴展性設計：
				   - 使用對象映射，便於添加新平台
				   - 提供回退機制，未知鍵值直接返回
				*/
				getSourceLinkName(key){
					/* 平台名稱映射：鍵值到顯示名稱的對應
					   - kakuyomu：カクヨム（角川集團的小說投稿平台）
					   - syosetu：小説家になろう（最大的日文網絡小說平台）
					   - japanese：通用的日文原文標籤
					*/
					const names={
						kakuyomu:'カクヨム',           // カクヨム平台
						syosetu:'小説家になろう',      // 成為小說家平台
						japanese:'日文原文'            // 通用日文原文
					};
					
					/* 安全的名稱獲取：
					   - names[key]：嘗試獲取對應的顯示名稱
					   - ||key：如果沒有匹配則直接返回原始鍵值
					   - 確保總是返回有意義的字符串
					*/
					return names[key]||key;
				},
				
				/* 格式化日期：將日期字符串轉換為本地化格式
				   本地化處理：
				   - 使用台灣地區的日期格式
				   - 統一日期顯示樣式
				   - 處理各種輸入日期格式
				   
				   格式標準化：
				   - 輸入：各種日期字符串格式
				   - 輸出：統一的YYYY-MM-DD格式
				   - 適合中文環境的日期顯示
				*/
				formatDate(dateStr){
					/* 防護性檢查：處理空值或無效輸入
					   - 如果沒有日期字符串則返回空字符串
					   - 避免Date構造函數錯誤
					*/
					if(!dateStr){
						return'';
					}
					
					/* 日期對象創建和格式化：
					   - new Date(dateStr)：解析日期字符串
					   - toLocaleDateString('zh-TW',options)：本地化格式化
					     - 'zh-TW'：台灣繁體中文區域設置
					     - year:'numeric'：完整年份（2024）
					     - month:'2-digit'：兩位數月份（01-12）
					     - day:'2-digit'：兩位數日期（01-31）
					   - replace(/\//g,'-')：將斜線替換為破折號
					     - 從2024/01/01格式轉換為2024-01-01
					     - 提供更統一的顯示格式
					*/
					const date=new Date(dateStr);
					return date.toLocaleDateString('zh-TW',{year:'numeric',month:'2-digit',day:'2-digit'}).replace(/\//g,'-');
				},
				/* 載入章節內容：從服務器獲取Markdown章節文件
				   異步載入流程：
				   1. 設置載入狀態
				   2. 構建文件路徑
				   3. 發送網絡請求
				   4. 處理響應
				   5. 初始化閱讀器功能
				   6. 錯誤處理
				   
				   性能和用戶體驗：
				   - 顯示載入狀態防止重複點擊
				   - 錯誤處理提供用戶反饋
				   - DOM更新後再執行相關功能
				*/
				async loadChapterContent(){
					try{
						/* 設置載入狀態：防止重複載入和提供視覺反饋
						   - 禁用相關按鈕和功能
						   - 可以顯示載入動畫
						   - 防止用戶在載入過程中進行其他操作
						*/
						this.isLoading=true;
						
						/* 構建文件路徑：生成章節文件的完整URL
						   路徑構成：輕小說翻譯/《小說名》/章節文件名.md
						   
						   URL編碼處理：
						   - encodeURIComponent()：確保路徑中的特殊字符正確編碼
						   - 處理中文字符、空格、標點符號等
						   - 避免因特殊字符導致的404錯誤
						*/
						const folderPath=encodeURIComponent(this.selectedNovel.title);      // 小說文件夾名
						const encodedFilename=encodeURIComponent(this.currentChapter.filename);  // 章節文件名
						const filename=`輕小說翻譯/${folderPath}/${encodedFilename}`;          // 完整文件路徑
						
						/* 網絡請求：使用Fetch API獲取文件內容
						   - await fetch()：發送HTTP GET請求
						   - 獲取指定路徑的Markdown文件
						   - 相對路徑基於當前HTML文件位置
						*/
						const response=await fetch(filename);
						
						/* HTTP狀態檢查：確保請求成功
						   - response.ok：檢查狀態碼是否在200-299範圍
						   - 如果失敗則拋出詳細的錯誤信息
						   - 包含HTTP狀態碼和狀態文本
						*/
						if(!response.ok){
							throw new Error(`HTTP ${response.status}: ${response.statusText}`);
						}
						
						/* 內容解析：將響應解析為文本
						   - await response.text()：獲取原始文本內容
						   - 不進行JSON解析，保持Markdown格式
						   - 將內容存儲到響應式狀態中
						*/
						this.chapterContent=await response.text();
						
						/* DOM更新後的初始化：確保內容渲染完成後執行
						   this.$nextTick()：Vue的DOM更新完成回調
						   - Vue的響應式更新是異步的
						   - 確保新內容已經渲染到DOM中
						   - 然後執行依賴DOM的功能
						*/
						this.$nextTick(()=>{
							/* 閱讀器初始化序列：
							   執行順序很重要，確保最佳的用戶體驗
							*/
							
							/* 1. 滾動到頂部：新章節從頭開始閱讀 */
							this.scrollToTop();
							
							/* 2. 設置圖片查看器：處理內容中的圖片點擊事件 */
							this.setupImageViewer();
							
							/* 3. 恢復滾動位置：如果用戶之前閱讀過此章節 */
							this.restoreScrollPosition();
							
							/* 4. 標記為已讀：更新閱讀進度 */
							this.markAsRead();
							
							/* 5. 重置載入狀態：恢復正常交互 */
							this.isLoading=false;
							
							/* 6. 更新頁面標題：顯示當前章節信息 */
							this.updatePageTitle('reader',{title:this.selectedNovel.title});
						});
					}catch(error){
						/* 錯誤處理：載入失敗時的處理流程
						   - 重置載入狀態
						   - 記錄錯誤信息
						   - 提供用戶反饋
						*/
						this.isLoading=false;
						console.error('讀取章節內容失敗:',error);
						
						/* 用戶友好的錯誤提示：
						   - alert()：簡單直接的錯誤通知
						   - 包含具體的錯誤信息
						   - 在生產環境中可以改為更優雅的UI提示
						*/
						alert(`讀取章節內容失敗: ${error.message}`);
					}
				},
				/* 設置圖片查看器：為章節內容中的圖片添加點擊放大功能
				   事件委託模式：
				   - 在父容器上監聽點擊事件
				   - 檢查點擊目標是否為圖片
				   - 避免為每張圖片單獨添加監聽器
				   
				   用戶體驗增強：
				   - 點擊圖片可以全螢幕查看
				   - 自動關閉其他面板，專注於圖片
				   - 支持輕小說中的插圖和圖表
				*/
				setupImageViewer(){
					/* DOM更新後執行：確保內容已渲染 */
					this.$nextTick(()=>{
						/* 查找小說內容容器：
						   - querySelector('.novel-content')：選中內容顯示區域
						   - 這是包含所有章節內容的容器
						*/
						const content=document.querySelector('.novel-content');
						
						if(content){
							/* 事件監聽器：處理容器內的點擊事件
							   事件委託優勢：
							   - 只需要一個監聽器就能處理所有圖片
							   - 動態添加的圖片也能自動支持
							   - 性能更好，減少內存使用
							*/
							content.addEventListener('click',(e)=>{
								/* 圖片點擊檢測：
								   - e.target：實際被點擊的元素
								   - tagName==='IMG'：檢查是否為圖片標籤
								   - 只有點擊圖片時才觸發lightbox
								*/
								if(e.target.tagName==='IMG'){
									/* 啟動圖片查看器：
									   - lightboxImage：設置要顯示的圖片URL
									   - isLightboxActive：激活全螢幕查看器
									   - 關閉其他面板：避免界面衝突
									*/
									this.lightboxImage=e.target.src;  // 獲取圖片源地址
									this.isLightboxActive=true;       // 激活lightbox
									this.showSettings=false;          // 關閉設定面板
									this.showChapterMenu=false;       // 關閉章節選單
								}
							});
						}
					});
				},
				
				/* 滾動到頂部：簡單的頁面滾動控制
				   使用場景：
				   - 載入新章節時回到頂部
				   - 頁面導航時的重置
				   - 提供一致的閱讀起始位置
				*/
				scrollToTop(){
					/* window.scrollTo(x, y)：滾動到指定位置
					   - (0, 0)：滾動到頁面頂部
					   - 立即滾動，沒有動畫效果
					   - 跨瀏覽器兼容的標準方法
					*/
					window.scrollTo(0,0);
				},
				
				/* 處理滾動事件：實現智能控制欄自動隱藏
				   智能UI設計：
				   - 向下滾動時隱藏控制欄（沉浸式閱讀）
				   - 向上滾動或到達底部時顯示控制欄
				   - 滾動時關閉彈出面板，避免干擾
				   - 持續保存滾動位置
				   
				   性能優化：
				   - 使用requestAnimationFrame節流（如果需要）
				   - 計算滾動方向，而不是每次都更新UI
				*/
				handleScroll(){
					/* 獲取當前滾動位置：
					   - window.pageYOffset：現代瀏覽器的滾動位置
					   - document.documentElement.scrollTop：舊版瀏覽器回退
					   - ||運算符：確保在所有瀏覽器中都能獲取滾動位置
					*/
					const st=window.pageYOffset||document.documentElement.scrollTop;
					
					/* 滾動方向檢測：
					   - 比較當前位置與上次記錄的位置
					   - true：向下滾動，false：向上滾動
					   - 用於決定是否隱藏控制欄
					*/
					const isScrollingDown=st>this.lastScrollTop;
					
					/* 底部檢測：判斷是否接近頁面底部
					   計算公式：視窗高度 + 滾動距離 >= 文檔總高度 - 緩衝區
					   - window.innerHeight：視窗可見高度
					   - window.pageYOffset：當前滾動距離
					   - document.body.offsetHeight：文檔總高度
					   - -100：100像素的緩衝區，提前觸發
					*/
					const isAtBottom=window.innerHeight+window.pageYOffset>=document.body.offsetHeight-100;
					
					/* 控制欄顯示邏輯：
					   - 向下滾動且不在底部：隱藏控制欄（沉浸式閱讀）
					   - 其他情況：顯示控制欄（向上滾動或接近底部）
					*/
					if(isScrollingDown&&!isAtBottom){
						this.hideControls=true;          // 隱藏控制欄
						this.showSettings=false;         // 關閉設定面板
						this.showChapterMenu=false;      // 關閉章節選單
					}else{
						this.hideControls=false;         // 顯示控制欄
					}
					
					/* 更新記錄：為下次滾動事件準備 */
					this.lastScrollTop=st;               // 記錄當前位置
					this.saveScrollPosition();           // 保存閱讀進度
				},
				
				/* 保存滾動位置：記錄用戶在每個章節的閱讀進度
				   持久化閱讀進度：
				   - 使用sessionStorage保存滾動位置
				   - 按小說和章節分別記錄
				   - 頁面刷新後可以恢復閱讀位置
				   
				   數據結構：
				   {
				     "小說A": {
				       "1": 500,    // 第1章滾動到500px
				       "2": 1200    // 第2章滾動到1200px
				     },
				     "小說B": {
				       "1": 300
				     }
				   }
				*/
				saveScrollPosition(){
					/* 防護性檢查：確保有必要的數據 */
					if(!this.selectedNovel||!this.currentChapter){
						return;
					}
					
					/* 讀取現有滾動位置數據：
					   - sessionStorage.getItem()：從瀏覽器會話存儲讀取
					   - JSON.parse()：將JSON字符串轉換為對象
					   - ||'{}'：如果沒有數據則使用空對象
					*/
					const scrollPositions=JSON.parse(sessionStorage.getItem(STORAGE_KEYS.SCROLL_POSITION)||'{}');
					
					/* 初始化小說的滾動位置對象：
					   - 如果這本小說還沒有記錄，創建空對象
					   - 為每本小說分別管理章節滾動位置
					*/
					if(!scrollPositions[this.novelKey]){
						scrollPositions[this.novelKey]={};
					}
					
					/* 記錄當前章節的滾動位置：
					   - novelKey：小說的唯一標識
					   - currentChapter.number：章節號
					   - window.pageYOffset：當前滾動距離（像素）
					*/
					scrollPositions[this.novelKey][this.currentChapter.number]=window.pageYOffset;
					
					/* 保存到瀏覽器存儲：
					   - JSON.stringify()：將對象轉換為JSON字符串
					   - sessionStorage.setItem()：保存到會話存儲
					   - 會話存儲在瀏覽器標籤關閉時清除
					*/
					sessionStorage.setItem(STORAGE_KEYS.SCROLL_POSITION,JSON.stringify(scrollPositions));
				},
				
				/* 恢復滾動位置：載入章節時恢復用戶的閱讀位置
				   用戶體驗優化：
				   - 回到之前閱讀的位置
				   - 避免用戶重新找到閱讀進度
				   - 支持在多個章節間切換
				   
				   使用時機：
				   - 載入章節內容後
				   - 頁面刷新後恢復狀態
				   - 從其他頁面返回閱讀器時
				*/
				restoreScrollPosition(){
					/* 防護性檢查：確保有必要的數據 */
					if(!this.selectedNovel||!this.currentChapter){
						return;
					}
					
					/* 讀取滾動位置數據：
					   - 從sessionStorage獲取所有保存的滾動位置
					   - 解析JSON數據為JavaScript對象
					*/
					const scrollPositions=JSON.parse(sessionStorage.getItem(STORAGE_KEYS.SCROLL_POSITION)||'{}');
					
					/* 獲取當前小說的滾動位置：
					   - scrollPositions[this.novelKey]：當前小說的所有章節位置
					   - ||{}：如果沒有記錄則使用空對象
					*/
					const novelPositions=scrollPositions[this.novelKey]||{};
					
					/* 獲取當前章節的保存位置：
					   - novelPositions[this.currentChapter.number]：當前章節的滾動位置
					   - 可能是數字（像素值）或undefined（沒有記錄）
					*/
					const savedPosition=novelPositions[this.currentChapter.number];
					
					/* 恢復滾動位置：
					   - 檢查savedPosition是否存在（!== undefined）
					   - parseInt()：確保數值的正確格式
					   - window.scrollTo(0, position)：滾動到保存的位置
					*/
					if(savedPosition!==undefined){
						window.scrollTo(0,parseInt(savedPosition));
					}
				},
				/* 章節導航核心邏輯：智能查找並切換到相鄰章節
				   智能導航算法：
				   1. 根據方向過濾可用章節
				   2. 找到最接近的目標章節
				   3. 保存當前閱讀進度
				   4. 載入新章節內容
				   5. 更新URL狀態
				   
				   參數處理：
				   - direction：'next'（下一章）或'previous'（上一章）
				   - 統一的邏輯處理兩個方向的導航
				*/
				navigateToChapter(direction){
					/* 方向判斷：確定是前進還是後退 */
					const isNext=direction==='next';
					
					/* 候選章節過濾：根據方向找出所有可能的目標章節
					   filter條件：
					   - isNext為true：找出章節號大於當前章節的所有章節
					   - isNext為false：找出章節號小於當前章節的所有章節
					   - 三元運算符：根據方向動態選擇過濾條件
					*/
					const chapters=this.allChapters.filter(chapter=>
						isNext?chapter.number>this.currentChapter.number:chapter.number<this.currentChapter.number
					);
					
					/* 導航可行性檢查：
					   - chapters.length>0：確保有可用的目標章節
					   - !this.isLoading：確保沒有正在進行的載入操作
					   - 避免在載入過程中重複觸發導航
					*/
					if(chapters.length>0&&!this.isLoading){
						/* 保存當前閱讀進度：記錄離開前的滾動位置 */
						this.saveScrollPosition();
						
						/* 最接近章節查找：使用reduce找到最佳目標章節
						   reduce邏輯：
						   - 對於下一章：找章節號最小的（最接近當前章節）
						   - 對於上一章：找章節號最大的（最接近當前章節）
						   - 三元運算符嵌套：根據方向選擇比較邏輯
						   
						   比較邏輯詳解：
						   - isNext為true：chapter.number<result.number?chapter:result
						     選擇更小的章節號（下一個最近的章節）
						   - isNext為false：chapter.number>result.number?chapter:result
						     選擇更大的章節號（上一個最近的章節）
						*/
						const targetChapter=chapters.reduce((result,chapter)=>
							isNext?(chapter.number<result.number?chapter:result):(chapter.number>result.number?chapter:result)
						);
						
						/* 切換到目標章節：更新當前章節並載入內容 */
						this.currentChapter=targetChapter;
						this.loadChapterContent();
						
						/* 更新URL：反映新的章節狀態，支持深鏈接 */
						this.updateUrl('reader',{title:this.selectedNovel.title,chapter:targetChapter.number});
					}
				},
				
				/* 下一章快捷方法：提供便捷的下一章導航接口
				   封裝性設計：
				   - 隱藏direction參數的複雜性
				   - 提供語義化的方法名
				   - 便於模板中調用和理解
				*/
				goToNext(){
					this.navigateToChapter('next');
				},
				
				/* 上一章快捷方法：提供便捷的上一章導航接口
				   一致性設計：
				   - 與goToNext()方法保持一致的命名風格
				   - 簡化模板中的方法調用
				   - 提高代碼可讀性
				*/
				goToPrevious(){
					this.navigateToChapter('previous');
				},
				
				/* 主題切換：在明亮和暗色模式間切換
				   簡單切換邏輯：
				   - 使用邏輯NOT運算符翻轉布爾值
				   - Vue監聽器會自動處理DOM更新和存儲
				   - 一行代碼實現完整的主題切換功能
				   
				   響應式更新：
				   - Vue的響應式系統會自動觸發相關更新
				   - watch監聽器會處理DOM屬性設置
				   - CSS變量會自動應用新的主題樣式
				*/
				toggleTheme(){
					this.isDarkMode=!this.isDarkMode;
				},
				
				/* 排序下拉選單切換：管理排序選項的顯示/隱藏
				   狀態切換邏輯：
				   - 如果當前顯示排序選單，則隱藏（設為null）
				   - 如果當前沒有顯示，則顯示排序選單（設為'sort'）
				   - 三元運算符：簡潔的條件切換語法
				   
				   互斥性設計：
				   - 同一時間只能有一個下拉選單打開
				   - 點擊其他區域會自動關閉（由全局點擊監聽器處理）
				*/
				toggleSortDropdown(){
					this.activeDropdown=this.activeDropdown==='sort'?null:'sort';
				},
				
				/* 設定面板切換：管理閱讀器設定面板的顯示
				   排他性切換：
				   - 切換設定面板的顯示狀態
				   - 同時關閉章節選單，確保界面整潔
				   - 避免多個面板同時顯示造成混亂
				   
				   用戶體驗：
				   - 提供清晰的界面狀態
				   - 避免功能面板間的衝突
				   - 保持一致的交互邏輯
				*/
				toggleSettings(){
					this.showSettings=!this.showSettings;    // 切換設定面板
					this.showChapterMenu=false;              // 關閉章節選單
				},
				
				/* 章節選單切換：管理章節導航選單的顯示和智能滾動
				   智能定位功能：
				   - 打開選單時自動滾動到當前章節
				   - 提供視覺上的當前位置指示
				   - 便於用戶快速導航到相鄰章節
				   
				   複雜的DOM操作：
				   - 需要等待DOM更新完成
				   - 計算滾動位置確保最佳顯示
				   - 處理各種邊界情況和錯誤
				*/
				toggleChapterMenu(){
					/* 基本切換：與設定面板互斥 */
					this.showChapterMenu=!this.showChapterMenu;  // 切換章節選單
					this.showSettings=false;                     // 關閉設定面板
					
					/* 智能滾動：選單打開時自動定位到當前章節 */
					if(this.showChapterMenu){
						/* 多層異步等待：確保DOM完全更新 */
						this.$nextTick(()=>{
							/* 延遲執行：給動畫時間完成渲染 */
							setTimeout(()=>{
								/* 查找當前章節元素：
								   - '.settings-modal .chapter-item.current'：當前章節的DOM元素
								   - 通過CSS類選擇器精確定位
								*/
								const currentChapterElement=document.querySelector('.settings-modal .chapter-item.current');
								
								if(currentChapterElement){
									try{
										/* 精確滾動計算：將當前章節滾動到容器中央
										   幾何計算：
										   - 找到滾動容器
										   - 計算容器和元素的位置關係
										   - 計算理想滾動位置（中央對齊）
										*/
										const container=currentChapterElement.closest('.settings-group');
										if(container){
											/* 位置計算：
											   - containerRect：容器在視窗中的位置和大小
											   - elementRect：目標元素在視窗中的位置和大小
											   - 相對位置計算確保精確滾動
											*/
											const containerRect=container.getBoundingClientRect();
											const elementRect=currentChapterElement.getBoundingClientRect();
											
											/* 滾動位置計算：
											   - container.scrollTop：當前滾動位置
											   - elementRect.top-containerRect.top：元素相對容器的位置
											   - containerRect.height/2：容器中央位置
											   - elementRect.height/2：元素中央偏移
											   - 最終結果：元素中央對齊到容器中央
											*/
											const scrollTop=container.scrollTop+(elementRect.top-containerRect.top)-(containerRect.height/2)+(elementRect.height/2);
											
											/* 平滑滾動：提供良好的視覺體驗
											   - behavior:'smooth'：平滑滾動動畫
											   - top:scrollTop：目標滾動位置
											*/
											container.scrollTo({top:scrollTop,behavior:'smooth'});
										}
									}catch(e){
										/* 回退方案：如果精確計算失敗，使用瀏覽器內建方法
										   - scrollIntoView()：瀏覽器原生滾動到視野方法
										   - behavior:'smooth'：平滑滾動
										   - block:'center'：垂直居中對齊
										*/
										currentChapterElement.scrollIntoView({behavior:'smooth',block:'center'});
									}
								}
							},100);  // 100ms延遲，確保動畫完成
						});
					}
				},
				/* 打開圖片查看器：啟動全螢幕圖片顯示模式
				   模態窗口管理：
				   - 設置要顯示的圖片URL
				   - 激活lightbox狀態
				   - 阻止背景滾動（提升體驗）
				   
				   用戶體驗設計：
				   - 全螢幕顯示圖片，便於查看細節
				   - 阻止背景滾動，專注於圖片內容
				   - 支持點擊關閉或ESC鍵退出
				*/
				openLightbox(imageUrl){
					/* 設置圖片源：傳入的圖片URL */
					this.lightboxImage=imageUrl;
					
					/* 激活lightbox：顯示全螢幕圖片查看器 */
					this.isLightboxActive=true;
					
					/* 阻止背景滾動：
					   - overflow:'hidden'：隱藏滾動條，防止背景滾動
					   - 當用戶專注查看圖片時，背景頁面保持靜止
					   - 提供更沉浸的查看體驗
					*/
					document.body.style.overflow='hidden';
				},
				
				/* 關閉圖片查看器：退出全螢幕圖片顯示模式
				   狀態恢復：
				   - 關閉lightbox顯示
				   - 恢復背景滾動功能
				   - 清理相關狀態
				*/
				closeLightbox(){
					/* 關閉lightbox：隱藏圖片查看器 */
					this.isLightboxActive=false;
					
					/* 恢復背景滾動：
					   - overflow:''：重置為默認值，恢復滾動
					   - 用戶可以繼續正常瀏覽頁面內容
					*/
					document.body.style.overflow='';
				},
				
				/* 處理圖片載入錯誤：當圖片無法載入時顯示預設圖片
				   錯誤處理策略：
				   - 監聽圖片載入錯誤事件
				   - 自動替換為預設的錯誤圖片
				   - 避免顯示破損的圖片圖標
				   
				   用戶體驗優化：
				   - 提供一致的視覺反饋
				   - 避免空白或破損圖片影響閱讀
				   - 讓用戶知道這裡原本應該有圖片
				*/
				handleImageError(event){
					/* 圖片替換：
					   - event.target：觸發錯誤的圖片元素
					   - src：設置新的圖片源路徑
					   - 'images/ImageError.png'：預設的錯誤提示圖片
					*/
					event.target.src='images/ImageError.png';
				},
				
				/* 處理排序選項變更：用戶選擇新的排序方式
				   排序狀態管理：
				   - 更新當前排序設定
				   - 保存用戶偏好到本地存儲
				   - 關閉下拉選單
				   
				   響應式更新：
				   - Vue響應式系統會自動重新排序列表
				   - 用戶立即看到新的排序結果
				*/
				handleSortChange(sortOption){
					/* 更新排序設定：設置新的排序方式 */
					this.currentSort=sortOption.value;
					
					/* 保存用戶偏好：下次訪問時記住選擇 */
					localStorage.setItem(STORAGE_KEYS.SORT,sortOption.value);
					
					/* 關閉下拉選單：選擇完成後自動收起 */
					this.activeDropdown=null;
				},
				
				/* 獲取下拉選單位置：計算下拉選單的顯示位置
				   動態定位計算：
				   - 基於觸發按鈕的位置計算
				   - 確保下拉選單在視窗範圍內
				   - 支持響應式定位
				   
				   位置計算邏輯：
				   - 獲取觸發元素的邊界框
				   - 計算下拉選單的理想位置
				   - 返回CSS定位屬性
				*/
				getDropdownPosition(){
					/* 查找觸發元素：下拉按鈕 */
					const element=document.querySelector('.dropdown-toggle');
					
					/* 防護性檢查：如果找不到元素則返回空對象 */
					if(!element){
						return{};
					}
					
					/* 獲取元素位置信息：
					   getBoundingClientRect()：
					   - 返回元素相對於視窗的位置和大小
					   - 包含top, left, bottom, right, width, height
					   - 實時計算，考慮滾動和縮放
					*/
					const rect=element.getBoundingClientRect();
					
					/* 計算下拉選單位置：
					   position:'fixed'：相對於視窗定位，不受滾動影響
					   top：按鈕底部 + 5px間距
					   right：從視窗右邊緣計算距離，確保右對齊
					   
					   右對齊計算：
					   - window.innerWidth：視窗寬度
					   - rect.right：按鈕右邊緣位置
					   - 相減得到從右邊緣的距離
					*/
					return{
						position:'fixed',
						top:`${rect.bottom+5}px`,              // 按鈕下方5px
						right:`${window.innerWidth-rect.right}px`  // 右對齊
					};
				},
				
				/* 關閉下拉選單：點擊其他區域時自動關閉
				   事件委託處理：
				   - 監聽全局點擊事件
				   - 檢查點擊位置是否在下拉選單外
				   - 自動關閉選單提升用戶體驗
				   
				   區域檢測邏輯：
				   - closest('.dropdown')：向上查找最近的下拉容器
				   - 如果點擊在下拉區域外，則關閉選單
				*/
				closeDropdowns(e){
					/* 區域檢測：
					   - e.target：被點擊的元素
					   - closest('.dropdown')：查找最近的下拉容器
					   - 如果返回null，說明點擊在下拉區域外
					*/
					if(!e.target.closest('.dropdown')){
						this.activeDropdown=null;  // 關閉所有下拉選單
					}
				},
				
				/* 標記章節為已讀：記錄用戶的閱讀進度
				   閱讀進度管理：
				   - 追蹤用戶已閱讀的章節
				   - 按小說分別記錄進度
				   - 持久化存儲，刷新後保持
				   
				   數據結構：
				   {
				     "小說A": [1, 2, 3],    // 已讀章節號數組
				     "小說B": [1, 5, 10]
				   }
				   
				   去重邏輯：
				   - 檢查章節是否已標記為已讀
				   - 避免重複添加相同章節
				*/
				markAsRead(){
					/* 防護性檢查：確保有必要的數據 */
					if(!this.selectedNovel||!this.currentChapter){
						return;
					}
					
					/* 讀取現有閱讀記錄：
					   - localStorage：永久存儲，瀏覽器關閉後仍保存
					   - JSON.parse：將字符串轉換為對象
					   - ||'{}'：默認空對象
					*/
					const readChapters=JSON.parse(localStorage.getItem(STORAGE_KEYS.READ_CHAPTERS)||'{}');
					
					/* 初始化小說的閱讀記錄：
					   - 如果這本小說還沒有記錄，創建空數組
					   - 為每本小說單獨管理閱讀進度
					*/
					if(!readChapters[this.novelKey]){
						readChapters[this.novelKey]=[];
					}
					
					/* 去重檢查和添加：
					   - includes()：檢查數組是否包含特定值
					   - 只有未讀章節才會被添加
					   - 避免重複記錄相同章節
					*/
					if(!readChapters[this.novelKey].includes(this.currentChapter.number)){
						readChapters[this.novelKey].push(this.currentChapter.number);
						
						/* 保存更新的閱讀記錄：
						   - JSON.stringify：轉換為字符串格式
						   - localStorage.setItem：保存到瀏覽器存儲
						*/
						localStorage.setItem(STORAGE_KEYS.READ_CHAPTERS,JSON.stringify(readChapters));
					}
				},
				
				/* 檢查章節是否已讀：用於UI顯示和邏輯判斷
				   閱讀狀態查詢：
				   - 檢查特定章節是否已被閱讀
				   - 用於章節列表的視覺標示
				   - 支援閱讀進度的顯示
				   
				   使用場景：
				   - 章節列表中的已讀標記
				   - 進度條的計算
				   - 條件性樣式應用
				*/
				isChapterRead(chapterNumber){
					/* 防護性檢查：確保有選中的小說 */
					if(!this.selectedNovel){
						return false;
					}
					
					/* 讀取閱讀記錄：獲取存儲的閱讀進度 */
					const readChapters=JSON.parse(localStorage.getItem(STORAGE_KEYS.READ_CHAPTERS)||'{}');
					
					/* 檢查章節狀態：
					   - readChapters[this.novelKey]：當前小說的已讀章節數組
					   - ?.includes()：可選鏈操作，安全地檢查是否包含
					   - 如果沒有記錄則返回false
					   - 有記錄則檢查是否包含指定章節號
					*/
					return readChapters[this.novelKey]?.includes(chapterNumber);
				}
			},
			
			/* ==========================================================================
			   mounted（掛載完成）：Vue.js生命週期鉤子
			   ==========================================================================
			   在組件掛載到DOM後執行，是進行初始化設置的最佳時機
			   包含：設備檢測、主題初始化、數據載入、事件監聽器設置
			   ========================================================================== */
			mounted(){
				/* ==========================================================================
				   初始化設置：應用程式啟動時的基本配置
				   ========================================================================== */
				
				/* 設備類型檢測：判斷是否為移動設備
				   響應式設計基礎：
				   - window.innerWidth：獲取視窗寬度
				   - 768px：常用的移動設備斷點
				   - 用於調整某些功能的行為模式
				*/
				this.isMobile=window.innerWidth<=768;
				
				/* 主題系統初始化：恢復用戶的主題偏好
				   持久化主題：
				   - 從localStorage讀取保存的主題設定
				   - 默認為'light'主題
				   - 立即應用到DOM，避免閃爍
				*/
				const theme=localStorage.getItem(STORAGE_KEYS.THEME)||'light';
				document.documentElement.setAttribute('data-theme',theme);
				
				/* CSS變量初始化：應用用戶的個人化設定
				   動態樣式設置：
				   - --fs：字體大小變量
				   - --lh：行高變量  
				   - --content-width：內容寬度變量
				   - 這些設定會影響整個應用的視覺呈現
				*/
				document.documentElement.style.setProperty('--fs',`${this.fontSize}px`);
				document.documentElement.style.setProperty('--lh',this.lineHeight);
				document.documentElement.style.setProperty('--content-width',`${this.contentWidth}%`);
				
				/* ==========================================================================
				   數據載入和路由處理：應用程式內容的初始化
				   ========================================================================== */
				
				/* 異步數據載入鏈：
				   1. fetchNovelList()：載入小說列表
				   2. .then()：載入完成後處理URL參數
				   3. handleUrlParams()：根據URL恢復應用狀態
				   
				   這種鏈式調用確保數據準備好後再處理路由
				*/
				this.fetchNovelList().then(()=>this.handleUrlParams());
				
				/* ==========================================================================
				   全局事件監聽器：處理瀏覽器和用戶交互事件
				   ========================================================================== */
				
				/* 瀏覽器歷史導航：處理前進/後退按鈕
				   popstate事件：
				   - 用戶點擊瀏覽器的前進/後退按鈕時觸發
				   - pushState/replaceState不會觸發此事件
				   - 需要手動處理URL變化並更新應用狀態
				*/
				window.addEventListener('popstate',()=>this.handleUrlParams());
				
				/* 視窗大小變化：響應式設備檢測更新
				   resize事件：
				   - 視窗大小改變時觸發（包括旋轉設備）
				   - 實時更新isMobile狀態
				   - 確保移動設備檢測的準確性
				*/
				window.addEventListener('resize',()=>{
					this.isMobile=window.innerWidth<=768;
				});
				
				/* 全局點擊監聽：自動關閉下拉選單
				   事件委託：
				   - 在document級別監聽點擊事件
				   - 檢查點擊位置並關閉下拉選單
				   - 提供良好的用戶體驗
				*/
				document.addEventListener('click',this.closeDropdowns);
				
				/* 鍵盤快捷鍵：提升操作效率和無障礙性
				   複雜的鍵盤事件處理：
				   - ESC鍵：通用的取消/關閉操作
				   - 方向鍵：閱讀器中的章節導航
				   - 條件檢查：確保快捷鍵在適當情況下才生效
				*/
				document.addEventListener('keydown',(e)=>{
					/* ESC鍵處理：分層的取消邏輯
					   優先級順序：
					   1. 關閉Lightbox（最高優先級）
					   2. 關閉閱讀器中的面板
					   - 提供直觀的退出路徑
					*/
					if(e.key==='Escape'){
						if(this.isLightboxActive){
							/* 關閉圖片查看器：最優先的ESC操作 */
							this.closeLightbox();
						}else if(this.currentPage==='reader'){
							/* 關閉閱讀器面板：次優先的ESC操作 */
							this.showSettings=false;
							this.showChapterMenu=false;
						}
					}
					/* 方向鍵導航：閱讀器中的章節切換
					   條件檢查：
					   - 必須在閱讀器頁面
					   - 沒有面板打開（避免衝突）
					   - 沒有Lightbox激活
					   - 確保有可用的上一章/下一章
					   
					   鍵位映射：
					   - ArrowLeft/ArrowUp：上一章（向前翻頁的直覺）
					   - ArrowRight/ArrowDown：下一章（向後翻頁的直覺）
					*/
					else if(this.currentPage==='reader'&&!this.showSettings&&!this.showChapterMenu&&!this.isLightboxActive){
						/* 上一章導航：左箭頭或上箭頭 */
						if((e.key==='ArrowLeft'||e.key==='ArrowUp')&&this.hasPrevious){
							this.goToPrevious();
						}
						/* 下一章導航：右箭頭或下箭頭 */
						else if((e.key==='ArrowRight'||e.key==='ArrowDown')&&this.hasNext){
							this.goToNext();
						}
					}
				});
				
				/* 閱讀器點擊處理：智能面板關閉邏輯
				   複雜的區域檢測：
				   - 只在閱讀器頁面生效
				   - 檢查點擊位置是否在特定區域
				   - 智能地關閉相關面板
				   
				   區域判斷：
				   - settings-modal：設定面板區域
				   - control-btn：控制按鈕區域
				   - 點擊這些區域外時自動關閉面板
				*/
				document.addEventListener('click',(e)=>{
					if(this.currentPage==='reader'){
						/* 查找特定區域：
						   - closest()：向上查找最近的匹配元素
						   - 檢查點擊是否在面板或按鈕內
						*/
						const settingsModal=e.target.closest('.settings-modal');
						const controlBtn=e.target.closest('.control-btn');
						
						/* 區域外點擊：關閉所有面板
						   - 如果點擊在面板和按鈕之外
						   - 自動關閉設定面板和章節選單
						   - 提供直觀的關閉體驗
						*/
						if(!settingsModal&&!controlBtn){
							this.showSettings=false;
							this.showChapterMenu=false;
						}
					}
				});
			}
		}).mount('#app');
	</script>
</body>
</html>
