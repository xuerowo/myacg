<!-- 
	=== HTML5 文檔類型聲明 ===
	DOCTYPE 聲明告訴瀏覽器這是一個 HTML5 文檔
	必須放在文檔的第一行，確保瀏覽器使用標準模式解析網頁
-->
<!DOCTYPE html>

<!-- 
	=== HTML 根元素 ===
	<html> 是網頁的根元素，包含整個網頁的內容
	lang="zh-TW" 屬性指定網頁的主要語言為繁體中文（台灣）
	這對搜索引擎優化(SEO)和無障礙設計都很重要
-->
<html lang="zh-TW">

<!-- 
	=== 文檔頭部 ===
	<head> 區塊包含網頁的元數據(metadata)
	這些信息不會直接顯示在網頁上，但對瀏覽器和搜索引擎很重要
-->
<head>
	<!-- 
		=== 字符編碼設置 ===
		指定文檔使用 UTF-8 編碼，這是目前最通用的編碼方式
		支持全世界所有語言的字符，包括中文、表情符號等
		必須放在 <head> 的最前面，確保瀏覽器正確解析後續內容
	-->
	<meta charset="UTF-8">
	
	<!-- 
		=== 響應式設計配置 ===
		viewport meta 標籤控制網頁在移動設備上的顯示方式
		- width=device-width: 設置視窗寬度等於設備螢幕寬度
		- initial-scale=1.0: 設置初始縮放級別為 100%
		這確保網頁在手機和平板上正確顯示，不會出現縮放問題
	-->
	<meta name="viewport" content="width=device-width,initial-scale=1.0">
	
	<!-- 
		=== 網頁標題 ===
		<title> 標籤定義網頁標題，會顯示在：
		1. 瀏覽器標籤頁上
		2. 搜索引擎結果中
		3. 社交媒體分享時
		4. 書籤列表中
	-->
	<title>輕小說翻譯</title>
	
	<!-- 
		=== 網站圖標(Favicon) ===
		rel="icon" 指定這是網站的圖標文件
		href 指向圖標文件的路徑
		type="image/jpg" 指定圖標的文件類型
		圖標會顯示在瀏覽器標籤頁、書籤列表等地方
	-->
	<link rel="icon" href="images/favicon.jpg" type="image/jpg">
	
	<!-- 
		=== Vue.js 框架引入 ===
		從 CDN（內容分發網絡）載入 Vue.js 3.x 版本
		Vue.js 是一個漸進式 JavaScript 框架，用於構建用戶界面
		global.js 版本可以直接在 HTML 中使用，無需構建工具
		- 特點：響應式數據綁定、組件化開發、虛擬 DOM
	-->
	<script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
	
	<!-- 
		=== Marked.js 庫引入 ===
		Marked.js 是一個 Markdown 解析器和編譯器
		可以將 Markdown 格式的文本轉換為 HTML
		在本應用中用於：
		1. 解析小說描述中的 Markdown 格式
		2. 將章節內容的 Markdown 轉換為 HTML 顯示
	-->
	<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
	
	<!-- 
		=== CSS 樣式開始 ===
		<style> 標籤包含所有的 CSS 樣式定義
		這裡使用內聯 CSS 的方式，將所有樣式寫在 HTML 文檔內
	-->
	<style>
		/* 
			===============================================
			=== CSS 自定義屬性 (CSS Variables) - 亮色主題 ===
			===============================================
			
			:root 選擇器定義全局 CSS 變量，這些變量可以在整個文檔中重複使用
			CSS 變量的優勢：
			1. 統一管理：所有顏色、尺寸都在一個地方定義
			2. 易於維護：修改一個變量值，整個網站的對應樣式都會更新
			3. 主題切換：可以輕鬆實現亮色/暗色主題切換
			4. 動態修改：可以通過 JavaScript 動態改變變量值
			
			變量命名規則：使用 -- 前綴，後接語義化的名稱
		*/
		:root{
			/* === 主要顏色系統 === */
			
			/* 主色調：柔和的藍色，用於按鈕、連結等重要交互元素 */
			--primary:#4a90e2;
			
			/* 主色調的懸停狀態：較深的藍色，提供視覺反饋 */
			--primary-hover:#357abd;
			
			/* 背景色：純白色，提供乾淨的閱讀環境 */
			--bg:#fff;
			
			/* 主要文字顏色：深灰色，確保良好的可讀性 */
			--text:#333;
			
			/* 次要文字顏色：中等灰色，用於不太重要的信息（如日期、作者等） */
			--text-muted:#666;
			
			/* 邊框顏色：淺灰色，用於分隔線和邊框 */
			--border:#ddd;
			
			/* 次要背景色：非常淺的灰色，用於卡片背景、輸入框等 */
			--secondary:#f5f5f5;
			
			/* === 陰影效果 === */
			/* 標準陰影：模擬真實物理陰影，增加元素的立體感和層次 */
			--shadow:0 2px 8px rgba(0,0,0,0.15);
			
			/* === 響應式字體和間距 === */
			
			/* 
				響應式字體大小：使用 clamp() 函數實現自適應
				clamp(最小值, 首選值, 最大值)
				- 16px: 最小字體大小（確保在小螢幕上仍可讀）
				- 4vw: 基於視窗寬度的動態值（4% 的視窗寬度）
				- 18px: 最大字體大小（避免在大螢幕上字體過大）
			*/
			--fs:clamp(16px,4vw,18px);
			
			/* 
				響應式行高：同樣使用 clamp() 函數
				- 1.6: 最小行高（緊湊但仍可讀）
				- 0.2vw: 基於視窗寬度的微調
				- 1.8: 最大行高（舒適的閱讀間距）
			*/
			--lh:clamp(1.6,0.2vw,1.8);
			
			/* === 設計系統的基本單位 === */
			
			/* 統一的圓角半徑：8px 提供現代化的圓潤外觀 */
			--br:8px;
			
			/* 
				標準間距單位：1rem（等於根元素的字體大小，通常是 16px）
				使用 rem 單位的優勢：
				1. 相對於根元素字體大小，確保一致性
				2. 易於縮放：用戶改變瀏覽器字體大小時，間距會相應調整
				3. 更好的可訪問性
			*/
			--sp:1rem;
			
			/* 內容區域寬度：80% 的容器寬度，為閱讀提供舒適的行長 */
			--content-width:80%;
			
			/* === 動畫和過渡效果 === */
			
			/* 
				快速過渡：0.2秒的過渡效果，用於小元素的快速反饋
				ease 緩動函數提供自然的動畫效果（先快後慢）
			*/
			--transition-fast:all 0.2s ease;
			
			/* 標準過渡：0.3秒的過渡效果，用於大多數交互元素 */
			--transition-normal:all 0.3s ease;
		}
		
		/* 
			===============================================
			=== CSS 自定義屬性 - 暗色主題 ===
			===============================================
			
			使用屬性選擇器 [data-theme="dark"] 來定義暗色主題
			當 HTML 根元素 <html> 具有 data-theme="dark" 屬性時，這些樣式會覆蓋亮色主題
			
			暗色主題的設計原則：
			1. 降低整體亮度，減少眼睛疲勞
			2. 使用足夠的對比度確保可讀性
			3. 保持色彩的相對關係和視覺層次
		*/
		:root[data-theme="dark"]{
			/* 暗色主題的主色調：較亮的藍色，在暗背景上提供足夠對比度 */
			--primary:#64b5f6;
			
			/* 暗色背景：接近黑色但不是純黑，減少對比度過強的問題 */
			--bg:#121212;
			
			/* 暗色主題的主要文字：淺灰色，在暗背景上清晰可讀 */
			--text:#e0e0e0;
			
			/* 暗色主題的次要文字：中等亮度的灰色 */
			--text-muted:#999;
			
			/* 暗色主題的邊框：深灰色，提供微妙的分隔效果 */
			--border:#333;
			
			/* 暗色主題的次要背景：比主背景稍亮的深灰色 */
			--secondary:#1a1a1a;
			
			/* 
				注意：其他變量（如字體大小、間距等）不需要重新定義
				它們會繼承自亮色主題的設置，保持一致性
			*/
		}
		
		/* 
			===============================================
			=== CSS 重置和基礎樣式 ===
			===============================================
		*/
		
		/* 
			=== 全局重置樣式 ===
			通用選擇器 * 選擇頁面上的所有元素
			這裡進行 CSS 重置，消除瀏覽器默認樣式的差異
		*/
		*{
			/* 移除所有元素的默認外邊距 */
			margin:0;
			
			/* 移除所有元素的默認內邊距 */
			padding:0;
			
			/* 
				設置盒模型為 border-box
				這意味著 width 和 height 包括 padding 和 border
				使佈局計算更直觀和可預測
				默認值是 content-box（只計算內容區域）
			*/
			box-sizing:border-box;
		}
		
		/* 
			=== 網頁主體樣式 ===
			body 元素定義整個網頁的基礎外觀
		*/
		body{
			/* 
				系統字體堆棧：
				優先使用用戶操作系統的原生字體，提供最佳的閱讀體驗
				-apple-system: macOS 系統字體
				BlinkMacSystemFont: 舊版 macOS 字體
				"Segoe UI": Windows 系統字體
				Roboto: Android 系統字體
				sans-serif: 備用無襯線字體
			*/
			font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,sans-serif;
			
			/* 行高設置為 1.6 倍字體大小，提供舒適的閱讀間距 */
			line-height:1.6;
			
			/* 使用 CSS 變量設置文字顏色，支持主題切換 */
			color:var(--text);
			
			/* 使用次要背景色作為頁面背景 */
			background:var(--secondary);
			
			/* 
				頂部內邊距 60px：為固定導航欄預留空間
				防止導航欄遮蓋頁面內容
			*/
			padding-top:60px;
			
			/* 
				最小高度設置為整個視窗高度
				確保頁面至少佔滿整個螢幕，即使內容不多
				100vh = 100% 的視窗高度
			*/
			min-height:100vh;
			
			/* 
				為顏色變化添加平滑過渡效果
				當主題切換時，背景色會平滑變化
			*/
			transition:var(--transition-normal);
		}
		
		/* 
			===============================================
			=== 佈局容器樣式 ===
			===============================================
		*/
		
		/* 
			=== 主容器樣式 ===
			.container 類定義主要內容區域的佈局約束
		*/
		.container{
			/* 
				最大寬度限制為 1200px
				防止在超寬螢幕上內容過於分散，保持良好的閱讀體驗
			*/
			max-width:1200px;
			
			/* 
				水平居中對齊：
				margin: 上下邊距 左右邊距
				var(--sp) auto: 上下使用標準間距，左右自動分配（實現居中）
			*/
			margin:var(--sp) auto;
			
			/* 內邊距 20px，為內容提供呼吸空間 */
			padding:20px;
		}
		
		/* 
			===============================================
			=== 固定頭部導航樣式 ===
			===============================================
		*/
		
		/* 
			=== 固定定位的頭部容器 ===
			.fixed-header 類用於創建固定在頁面頂部的導航欄
		*/
		.fixed-header{
			/* 
				固定定位：相對於視窗定位，不隨頁面滾動
				position: fixed 使元素脫離正常文檔流
			*/
			position:fixed;
			
			/* 左邊緣對齊視窗左側 */
			left:0;
			
			/* 右邊緣對齊視窗右側（實現全寬） */
			right:0;
			
			/* 
				半透明背景：
				rgba(255,255,255,0.85) = 85% 透明度的白色
				創建毛玻璃效果，既保持可見性又不完全遮蓋下方內容
			*/
			background:rgba(255,255,255,0.85);
			
			/* 添加陰影效果，增加頭部的立體感和層次 */
			box-shadow:var(--shadow);
			
			/* 內邊距使用標準間距變量 */
			padding:var(--sp);
			
			/* 
				z-index 層級設置為 1000
				確保導航欄顯示在其他內容之上
				數值越大，層級越高
			*/
			z-index:1000;
			
			/* 
				為 transform 屬性添加過渡效果
				用於導航欄的顯示/隱藏動畫
			*/
			transition:transform 0.3s;
		}
		
		/* 
			=== 暗色主題的固定頭部樣式 ===
			使用屬性選擇器匹配暗色主題，覆蓋背景色
		*/
		[data-theme="dark"] .fixed-header{
			/* 暗色主題下的半透明深色背景 */
			background:rgba(18,18,18,0.85);
		}
		
		/* 
			=== 導航欄定位 ===
			.navbar 類設置導航欄的垂直位置
		*/
		.navbar{
			/* 距離視窗頂部 0px，緊貼頂部 */
			top:0;
		}
		
		/* 
			=== 隱藏狀態的導航欄 ===
			.navbar.hidden 是導航欄隱藏時的樣式
		*/
		.navbar.hidden{
			/* 
				向上平移 100% 高度，使導航欄隱藏在視窗頂部之外
				transform: translateY() 進行垂直平移
				負值表示向上移動
			*/
			transform:translateY(-100%);
		}
		
		/* 
			===============================================
			=== 導航容器佈局 ===
			===============================================
		*/
		
		/* 
			=== 導航內容容器 ===
			.nav-container 類使用 Flexbox 佈局導航欄內容
		*/
		.nav-container{
			/* 限制導航內容的最大寬度，與主容器保持一致 */
			max-width:1200px;
			
			/* 水平居中對齊 */
			margin:0 auto;
			
			/* Flexbox 子元素之間的間隔 */
			gap:var(--sp);
			
			/* 
				啟用 Flexbox 佈局：
				Flexbox 是一維佈局方法，非常適合導航欄這種線性佈局
			*/
			display:flex;
			
			/* 
				垂直對齊方式：
				align-items: center 讓所有子元素在交叉軸（垂直方向）上居中對齊
			*/
			align-items:center;
			
			/* 
				水平分佈方式：
				justify-content: space-between 讓子元素兩端對齊
				第一個元素靠左，最後一個元素靠右，中間自動分配空間
			*/
			justify-content:space-between;
		}
		
		/* 
			=== 導航右側內容 ===
			.nav-right 類組織導航欄右側的控制元素
		*/
		.nav-right{
			/* 使用 Flexbox 橫向排列右側元素 */
			display:flex;
			
			/* 垂直居中對齊 */
			align-items:center;
			
			/* 子元素之間的間隔 */
			gap:var(--sp);
		}
		
		/* 
			===============================================
			=== 導航標題和控制元件 ===
			===============================================
		*/
		
		/* 
			=== 導航標題樣式 ===
			.nav-title 類定義主標題的外觀
		*/
		.nav-title{
			/* 使用主色調，突出品牌標識 */
			color:var(--primary);
			
			/* 移除連結的默認下劃線 */
			text-decoration:none;
			
			/* 較大的字體大小：1.3rem，約等於 20.8px */
			font-size:1.3rem;
			
			/* 粗體字重，增加視覺重要性 */
			font-weight:bold;
		}
		
		/* 
			===============================================
			=== 下拉菜單組件 ===
			===============================================
		*/
		
		/* 
			=== 下拉菜單容器 ===
			.dropdown 類為下拉菜單提供定位上下文
		*/
		.dropdown{
			/* 
				相對定位：為子元素的絕對/固定定位提供參考點
				這允許下拉菜單相對於這個容器定位
			*/
			position:relative;
		}
		
		/* 
			=== 下拉菜單觸發按鈕 ===
			.dropdown-toggle 類定義觸發下拉菜單的按鈕樣式
		*/
		.dropdown-toggle{
			/* 
				滑鼠游標樣式：
				cursor: pointer 告訴用戶這是可點擊的元素
			*/
			cursor:pointer;
			
			/* 內邊距 0.5rem，提供足夠的點擊區域 */
			padding:0.5rem;
			
			/* 使用 Flexbox 水平排列按鈕內容 */
			display:flex;
			
			/* 垂直居中對齊按鈕內的元素 */
			align-items:center;
			
			/* 按鈕內元素之間的間隔 */
			gap:0.5rem;
			
			/* 使用主文字顏色 */
			color:var(--text);
			
			/* 
				移除按鈕的默認背景
				background: none 讓按鈕看起來像文字連結
			*/
			background:none;
			
			/* 移除按鈕的默認邊框 */
			border:none;
			
			/* 設置字體大小為 1rem（標準大小） */
			font-size:1rem;
		}
		
		/* 
			=== 下拉箭頭樣式 ===
			使用 CSS 偽元素 ::after 創建下拉箭頭
		*/
		.dropdown-toggle::after{
			/* 
				使用 content 屬性插入下拉箭頭符號
				'▼' Unicode 字符作為視覺指示器
			*/
			content:'▼';
			
			/* 較小的字體大小：0.8em（相對於父元素字體大小的 80%） */
			font-size:0.8em;
			
			/* 
				為 transform 變換添加過渡效果
				當箭頭旋轉時會有平滑的動畫
			*/
			transition:transform 0.3s;
		}
		
		/* 
			=== 激活狀態的下拉箭頭 ===
			當下拉菜單展開時，箭頭向上旋轉
		*/
		.dropdown-toggle.active::after{
			/* 
				旋轉 180 度：箭頭從向下變為向上
				transform: rotate() 進行旋轉變換
			*/
			transform:rotate(180deg);
		}
		
		/* 
			=== 下拉菜單內容 ===
			.dropdown-menu 類定義下拉菜單的主體樣式
		*/
		.dropdown-menu{
			/* 
				固定定位：相對於視窗定位
				這確保菜單不會被父容器的 overflow 裁剪
			*/
			position:fixed;
			
			/* 使用主背景色 */
			background:var(--bg);
			
			/* 最小寬度 160px，確保菜單有足夠的寬度 */
			min-width:160px;
			
			/* 添加陰影效果，增加立體感 */
			box-shadow:var(--shadow);
			
			/* 使用統一的圓角 */
			border-radius:var(--br);
			
			/* 
				初始狀態不透明度為 0（完全透明）
				配合 transition 實現淡入效果
			*/
			opacity:0;
			
			/* 
				初始狀態不可見：
				visibility: hidden 讓元素完全不可交互
				與 opacity: 0 結合使用實現完整的隱藏效果
			*/
			visibility:hidden;
			
			/* 
				初始位置向上偏移 10px：
				配合 transition 實現下滑顯示效果
			*/
			transform:translateY(-10px);
			
			/* 使用標準過渡效果，讓顯示/隱藏更流暢 */
			transition:var(--transition-normal);
			
			/* 
				高層級的 z-index：1002
				確保下拉菜單顯示在其他元素之上
				比固定頭部的 z-index: 1000 更高
			*/
			z-index:1002;
			
			/* 內邊距 4px，為菜單項提供微小的邊距 */
			padding:4px;
		}
		
		/* 
			=== 顯示狀態的下拉菜單 ===
			當 activeDropdown==='sort' 時，這個類別會被添加
		*/
		.dropdown-menu.show{
			/* 完全可見 */
			opacity:1;
			
			/* 可以接收用戶交互 */
			visibility:visible;
			
			/* 恢復到原始位置（無偏移） */
			transform:translateY(0);
		}
		
		/* 
			=== 下拉菜單項目樣式 ===
			每個排序選項的外觀和行為
		*/
		.dropdown-menu a{
			/* 使用 Flexbox 水平排列內容 */
			display:flex;
			
			/* 左右兩端對齊：文字在左，勾選標記在右 */
			justify-content:space-between;
			
			/* 垂直居中對齊 */
			align-items:center;
			
			/* 內邊距：0.8rem（約13px）提供舒適的點擊區域 */
			padding:0.8rem var(--sp);
			
			/* 使用主文字顏色 */
			color:var(--text);
			
			/* 移除連結的默認下劃線 */
			text-decoration:none;
			
			/* 添加平滑過渡效果 */
			transition:var(--transition-normal);
			
			/* 指針游標，表示可點擊 */
			cursor:pointer;
			
			/* 圓角邊框，與整體設計保持一致 */
			border-radius:var(--br);
		}
		
		/* 
			=== 菜單項目懸停效果 ===
			滑鼠懸停時的視覺反饋
		*/
		.dropdown-menu a:hover{
			/* 背景變為次要背景色 */
			background:var(--secondary);
			
			/* 文字變為主色調，增加對比度 */
			color:var(--primary);
		}
		
		/* 
			=== 激活狀態的菜單項目 ===
			當前選中的排序方式
		*/
		.dropdown-menu a.active{
			/* 背景使用主色調，強烈的視覺標識 */
			background:var(--primary);
			
			/* 白色文字，確保在藍色背景上的可讀性 */
			color:white;
		}
		
		/* 
			=== 激活項目的懸停效果 ===
			當前選中項目的懸停狀態
		*/
		.dropdown-menu a.active:hover{
			/* 使用更深的主色調，提供視覺層次 */
			background:var(--primary-hover);
		}
		
		/* 
			=== 勾選標記樣式 ===
			顯示當前選中狀態的符號
		*/
		.dropdown-menu .checkmark{
			/* 粗體字重，突出顯示 */
			font-weight:bold;
			
			/* 標準字體大小 */
			font-size:1rem;
			
			/* 左邊距，與文字保持適當距離 */
			margin-left:0.5rem;
		}
		
		/* 
			===============================================
			=== 按鈕基礎樣式系統 ===
			===============================================
		*/
		
		/* 
			=== 按鈕基礎類別 ===
			所有按鈕共享的基本樣式
		*/
		.btn-base{
			/* 內邊距：提供足夠的點擊區域 */
			padding:0.5rem var(--sp);
			
			/* 移除瀏覽器默認邊框 */
			border:none;
			
			/* 統一的圓角設計 */
			border-radius:var(--br);
			
			/* 指針游標，表示可交互 */
			cursor:pointer;
			
			/* 平滑過渡效果，提升用戶體驗 */
			transition:var(--transition-normal);
		}
		
		/* 
			=== 主要按鈕樣式 ===
			用於重要操作的按鈕（如導航、確認等）
		*/
		.btn-primary{
			/* 主色調背景，突出重要性 */
			background:var(--primary);
			
			/* 白色文字，確保對比度 */
			color:white;
			
			/* 最小寬度 80px，保證按鈕不會過小 */
			min-width:80px;
		}
		
		/* 
			=== 主要按鈕懸停效果 ===
			滑鼠懸停時的視覺反饋
		*/
		.btn-primary:hover{
			/* 使用懸停色，提供互動反饋 */
			background:var(--primary-hover);
		}
		
		/* 
			=== 禁用狀態的按鈕 ===
			當按鈕不可用時的外觀
		*/
		.btn-primary:disabled{
			/* 半透明效果，表示不可用 */
			opacity:0.5;
			
			/* 
				禁用游標：
				not-allowed 游標告訴用戶此操作不被允許
				提供清晰的視覺反饋
			*/
			cursor:not-allowed;
		}
		
		/* 
			=== 透明按鈕樣式 ===
			用於次要操作或圖標按鈕
		*/
		.btn-transparent{
			/* 透明背景，不干擾內容 */
			background:transparent;
			
			/* 自動寬度，適應內容大小 */
			min-width:auto;
			
			/* 使用主文字顏色 */
			color:var(--text);
			
			/* Flexbox 佈局，便於放置圖標 */
			display:flex;
			
			/* 垂直居中對齊內容 */
			align-items:center;
		}
		
		/* 
			=== 透明按鈕懸停效果 ===
			微妙的顏色變化提供反饋
		*/
		.btn-transparent:hover{
			/* 懸停時變為主色調 */
			color:var(--primary);
		}
		
		/* 
			===============================================
			=== 主題切換按鈕 ===
			===============================================
			
			特殊的主題切換按鈕，具有獨特的動畫效果
		*/
		.theme-toggle{
			/* 無背景，保持簡潔 */
			background:none;
			
			/* 無邊框 */
			border:none;
			
			/* 使用主文字顏色 */
			color:var(--text);
			
			/* 較大字體，突出 emoji 圖標 */
			font-size:1.3rem;
			
			/* 指針游標 */
			cursor:pointer;
			
			/* 內邊距提供點擊區域 */
			padding:0.5rem;
			
			/* 
				變換過渡效果：
				專門為 transform 屬性設置過渡
				實現旋轉動畫效果
			*/
			transition:transform 0.3s;
			
			/* 行高設為 1，確保 emoji 垂直居中 */
			line-height:1;
		}
		
		/* 
			=== 主題切換按鈕懸停效果 ===
			有趣的 360 度旋轉動畫
		*/
		.theme-toggle:hover{
			/* 360度旋轉動畫，增加互動趣味性 */
			transform:rotate(360deg);
		}
		
		/* 
			===============================================
			=== 內容網格佈局系統 ===
			===============================================
		*/
		
		/* 
			=== 主要內容網格 ===
			用於顯示小說卡片的響應式網格佈局
		*/
		.content-grid{
			/* 
				CSS Grid 佈局：
				Grid 是二維佈局系統，非常適合卡片網格
				相比 Flexbox，Grid 更適合複雜的二維佈局
			*/
			display:grid;
			
			/* 
				響應式列定義：
				repeat(auto-fill, minmax(200px, 1fr))
				- auto-fill: 自動填滿容器寬度，創建盡可能多的列
				- minmax(200px, 1fr): 每列最小200px，最大為剩餘空間的平均分配
				- 1fr: 網格分數單位，表示可用空間的一個分數
				
				這個設置實現了真正的響應式：
				- 大螢幕：多列顯示
				- 小螢幕：自動減少列數
				- 永遠保持最小200px的可讀寬度
			*/
			grid-template-columns:repeat(auto-fill,minmax(200px,1fr));
			
			/* 
				網格間隔：
				calc(var(--sp)*2) 使用CSS計算函數
				將標準間距乘以2，創建更寬鬆的佈局
				calc() 允許混合不同單位進行運算
			*/
			gap:calc(var(--sp)*2);
		}
		
		/* 
			===============================================
			=== 卡片組件系統 ===
			===============================================
		*/
		
		/* 
			=== 卡片基礎樣式 ===
			每個小說的顯示卡片
		*/
		.card{
			/* 使用主背景色，確保在不同主題下的一致性 */
			background:var(--bg);
			
			/* 統一的圓角設計 */
			border-radius:var(--br);
			
			/* 
				隱藏溢出內容：
				確保圓角效果正確顯示
				防止子元素（如圖片）超出邊界
			*/
			overflow:hidden;
			
			/* 添加陰影，增加卡片的立體感和層次 */
			box-shadow:var(--shadow);
			
			/* 
				快速過渡效果：
				用於懸停動畫，提供即時的視覺反饋
			*/
			transition:var(--transition-fast);
			
			/* 指針游標，表示卡片可點擊 */
			cursor:pointer;
			
			/* 
				Flexbox 垂直佈局：
				讓卡片內容垂直排列
			*/
			display:flex;
			
			/* 垂直方向排列：圖片在上，信息在下 */
			flex-direction:column;
		}
		
		/* 
			=== 卡片懸停效果 ===
			滑鼠懸停時的3D提升效果
		*/
		.card:hover{
			/* 
				向上平移5px：
				創建卡片"浮起"的視覺效果
				結合 box-shadow 模擬真實的物理提升
			*/
			transform:translateY(-5px);
		}
		
		/* 
			=== 卡片圖片樣式 ===
			小說封面圖片的顯示設置
		*/
		.card img{
			/* 圖片寬度100%，填滿卡片寬度 */
			width:100%;
			
			/* 
				固定長寬比：
				aspect-ratio: 0.7 設置寬高比為 7:10
				這是小說封面的典型比例（類似書本比例）
				確保所有卡片高度一致，創建整齊的網格
			*/
			aspect-ratio:0.7;
			
			/* 
				對象適配方式：
				object-fit: cover 確保圖片填滿整個區域
				類似 background-size: cover
				可能會裁切圖片，但保持比例不變形
			*/
			object-fit:cover;
			
			/* 
				對象定位：
				object-position: center top 從圖片的中上部分開始顯示
				對於人物封面，這樣可以確保臉部可見
			*/
			object-position:center top;
		}
		
		/* 
			=== 卡片信息區域 ===
			包含標題、作者、日期等文字信息
		*/
		.card-info{
			/* 使用標準間距作為內邊距 */
			padding:var(--sp);
			
			/* 
				flex: 1 讓信息區域佔據剩餘空間
				這確保所有卡片底部對齊，無論標題長短
			*/
			flex:1;
			
			/* 信息區域內部也使用 Flexbox 垂直佈局 */
			display:flex;
			flex-direction:column;
			
			/* 
				空間分佈：
				justify-content: space-between 讓標題和底部信息分別佔據頂部和底部
				中間的空間自動分配
			*/
			justify-content:space-between;
		}
		
		/* 
			=== 卡片標題樣式 ===
			小說名稱的顯示設置
		*/
		.card-title{
			/* 略大的字體，突出標題重要性 */
			font-size:1.1rem;
			
			/* 粗體字重，增加視覺重量 */
			font-weight:bold;
			
			/* 使用主文字顏色 */
			color:var(--text);
		}
		
		/* 
			=== 卡片底部信息 ===
			作者和更新日期的顯示區域
		*/
		.card-footer{
			/* Flexbox 水平佈局 */
			display:flex;
			
			/* 左右兩端對齊：作者在左，日期在右 */
			justify-content:space-between;
			
			/* 垂直居中對齊 */
			align-items:center;
			
			/* 與標題保持0.5rem的間距 */
			margin-top:0.5rem;
			
			/* 較小的字體，降低視覺重要性 */
			font-size:0.8rem;
			
			/* 使用次要文字顏色，進一步降低對比度 */
			color:var(--text-muted);
		}
		
		/* 
			===============================================
			=== 小說詳情頁面樣式 ===
			===============================================
		*/
		
		/* 
			=== 詳情頁主容器 ===
			包含小說封面、信息和章節列表的主要區域
		*/
		.novel-detail{
			/* 使用主背景色，與整體設計一致 */
			background:var(--bg);
			
			/* 統一的圓角設計 */
			border-radius:var(--br);
			
			/* 較大的內邊距，提供舒適的閱讀空間 */
			padding:2rem;
			
			/* 底部邊距，與章節列表保持距離 */
			margin-bottom:2rem;
		}
		
		/* 
			=== 小說信息佈局 ===
			封面和文字信息的兩列佈局
		*/
		.novel-info{
			/* 使用 CSS Grid 創建兩列佈局 */
			display:grid;
			
			/* 
				列寬定義：
				300px: 封面固定寬度，確保封面顯示完整
				1fr: 信息區域佔據剩餘空間
				這是經典的側邊欄+主內容佈局
			*/
			grid-template-columns:300px 1fr;
			
			/* 列間隔2rem，提供足夠的視覺分隔 */
			gap:2rem;
		}
		
		/* 
			=== 小說封面樣式 ===
			大尺寸封面圖片的顯示設置
		*/
		.novel-cover{
			/* 寬度100%，填滿網格列 */
			width:100%;
			
			/* 圓角邊框，柔化圖片邊緣 */
			border-radius:var(--br);
			
			/* 指針游標，表示可點擊查看大圖 */
			cursor:pointer;
			
			/* 
				複合過渡效果：
				同時為 transform 和 box-shadow 添加過渡
				使用 ease 緩動函數提供自然的動畫感覺
			*/
			transition:transform 0.3s ease,box-shadow 0.3s ease;
		}
		
		/* 
			=== 封面懸停效果 ===
			滑鼠懸停時的放大和陰影效果
		*/
		.novel-cover:hover{
			/* 
				放大效果：
				scale(1.05) 放大到105%
				創建"放大鏡"的視覺效果
			*/
			transform:scale(1.05);
			
			/* 
				增強陰影：
				更大的模糊半徑和偏移量
				更深的陰影透明度
				增加懸停時的立體感
			*/
			box-shadow:0 8px 25px rgba(0,0,0,0.2);
		}
		
		/* 
			=== 小說標題樣式 ===
			詳情頁的主標題
		*/
		.novel-title{
			/* 
				大字體：2.3rem（約36.8px）
				在詳情頁中作為視覺焦點
			*/
			font-size:2.3rem;
			
			/* 與下方內容保持標準間距 */
			margin-bottom:var(--sp);
			
			/* 使用主文字顏色 */
			color:var(--text);
		}
		
		/* 
			=== 小說元數據區域 ===
			作者、類型、原連結等信息
		*/
		.novel-metadata{
			/* 與下方內容保持間距 */
			margin-bottom:var(--sp);
			
			/* 使用主文字顏色 */
			color:var(--text);
		}
		
		/* 
			=== 小說描述文字 ===
			支持Markdown格式的描述內容
		*/
		.novel-description{
			/* 與上方內容保持間距 */
			margin-top:var(--sp);
			
			/* 
				行高1.8：
				比默認行高更大，提供舒適的閱讀體驗
				適合長篇文字內容
			*/
			line-height:1.8;
			
			/* 
				保留換行符：
				white-space: pre-line 保留文本中的換行符
				允許Markdown文本正確顯示段落結構
			*/
			white-space:pre-line;
		}
		
		/* 
			=== 原文連結按鈕 ===
			指向原始網站的連結樣式
		*/
		.source-link{
			/* 行內塊級元素，允許設置padding */
			display:inline-block;
			
			/* 緊湊的內邊距，適合小按鈕 */
			padding:0.25rem 0.75rem;
			
			/* 左邊距，與前面的文字保持距離 */
			margin-left:0.5rem;
			
			/* 圓角邊框 */
			border-radius:var(--br);
			
			/* 使用主文字顏色 */
			color:var(--text);
			
			/* 次要背景色，低調但可識別 */
			background:var(--secondary);
			
			/* 移除連結的默認下劃線 */
			text-decoration:none;
			
			/* 快速過渡效果，提供即時反饋 */
			transition:var(--transition-fast);
		}
		
		/* 
			=== 原文連結懸停效果 ===
			明顯的顏色變化，增加可點擊性
		*/
		.source-link:hover{
			/* 使用主色調的懸停變體 */
			background:var(--primary-hover);
			
			/* 白色文字，確保在深色背景上的可讀性 */
			color:#fff;
		}
		
		/* 
			===============================================
			=== 章節列表組件 ===
			===============================================
		*/
		
		/* 
			=== 章節網格佈局 ===
			顯示所有可用章節的響應式網格
		*/
		.chapter-list{
			/* CSS Grid 佈局，適合章節卡片的排列 */
			display:grid;
			
			/* 
				響應式章節列：
				repeat(auto-fill, minmax(150px, 1fr))
				- 每個章節卡片最小150px寬
				- 自動填充可用空間
				- 根據容器寬度調整列數
			*/
			grid-template-columns:repeat(auto-fill,minmax(150px,1fr));
			
			/* 章節間的間隔 */
			gap:var(--sp);
			
			/* 與上方小說信息保持2rem間距 */
			margin-top:2rem;
		}
		
		/* 
			=== 章節項目樣式 ===
			每個章節的卡片設計
		*/
		.chapter-item{
			/* 次要背景色，與主背景形成微妙對比 */
			background:var(--secondary);
			
			/* 標準內邊距 */
			padding:var(--sp);
			
			/* 統一圓角 */
			border-radius:var(--br);
			
			/* 指針游標，表示可點擊 */
			cursor:pointer;
			
			/* 快速過渡效果，提供即時反饋 */
			transition:var(--transition-fast);
			
			/* Flexbox 垂直佈局 */
			display:flex;
			flex-direction:column;
			
			/* 章節標題和日期之間的間隔 */
			gap:0.5rem;
		}
		
		/* 
			=== 章節項目懸停效果 ===
			適用於普通章節和已讀章節的懸停狀態
		*/
		.chapter-item:hover,.chapter-item.read:hover{
			/* 懸停時使用主色調背景 */
			background:var(--primary);
			
			/* 白色文字，確保可讀性 */
			color:#fff;
			
			/* 
				向上浮動效果：
				translateY(-2px) 比卡片的-5px更微妙
				適合較小的章節項目
			*/
			transform:translateY(-2px);
		}
		
		/* 
			=== 已讀章節標記 ===
			用戶已經閱讀過的章節外觀
		*/
		.chapter-item.read{
			/* 
				半透明效果：
				opacity: 0.5 讓已讀章節顯得不那麼突出
				引導用戶關注未讀內容
			*/
			opacity:0.5;
			
			/* 
				微妙邊框：
				淺灰色半透明邊框
				進一步區分已讀和未讀狀態
			*/
			border:1px solid rgba(128,128,128,0.3);
		}
		
		/* 
			=== 章節標題樣式 ===
			章節名稱的顯示設置
		*/
		.chapter-title{
			/* 
				中等字重：
				font-weight: 500 介於普通(400)和粗體(700)之間
				提供適度的視覺重量
			*/
			font-weight:500;
			
			/* 
				彈性增長：
				flex-grow: 1 讓標題佔據大部分空間
				將日期推到底部
			*/
			flex-grow:1;
		}
		
		/* 
			=== 章節日期樣式 ===
			章節更新日期的顯示
		*/
		.chapter-date{
			/* 較小字體，降低視覺重要性 */
			font-size:0.85rem;
			
			/* 次要文字顏色，進一步弱化 */
			color:var(--text-muted);
		}
		
		/* 
			===============================================
			=== 閱讀器核心樣式 ===
			===============================================
		*/
		
		/* 
			=== 閱讀器主容器 ===
			包含章節內容的主要閱讀區域
		*/
		.reader-container{
			/* 
				響應式寬度：
				使用CSS變量 --content-width（默認80%）
				用戶可以在設置中調整，實現個性化閱讀體驗
			*/
			width:var(--content-width);
			
			/* 
				居中佈局並設置邊距：
				4rem 頂部邊距：為固定導航欄預留足夠空間
				auto 左右邊距：水平居中
				5rem 底部邊距：為底部控制欄預留空間
			*/
			margin:4rem auto 5rem;
			
			/* 內邊距，為文字內容提供呼吸空間 */
			padding:2rem;
			
			/* 主背景色，創建閱讀卡片效果 */
			background:var(--bg);
			
			/* 圓角邊框，柔化容器邊緣 */
			border-radius:var(--br);
			
			/* 陰影效果，增加容器的立體感 */
			box-shadow:var(--shadow);
			
			/* 
				響應式字體大小：
				使用CSS變量 --fs（clamp函數實現）
				根據螢幕大小自動調整字體
			*/
			font-size:var(--fs);
		}
		
		/* 
			=== 小說內容區域 ===
			顯示經過Markdown解析的章節內容
		*/
		.novel-content{
			/* 與下方控制元件保持間距 */
			margin-bottom:2rem;
			
			/* 
				響應式行高：
				使用CSS變量 --lh（clamp函數實現）
				提供舒適的閱讀間距，用戶可調整
			*/
			line-height:var(--lh);
		}
		
		/* 
			=== 段落間距 ===
			為文章段落提供適當的視覺分隔
		*/
		.novel-content p{
			/* 段落底部間距，改善閱讀流暢性 */
			margin-bottom:var(--sp);
		}
		
		/* 
			=== 內容圖片樣式 ===
			章節中插入的圖片顯示設置
		*/
		.novel-content img{
			/* 
				響應式圖片寬度：
				max-width: 100% 確保圖片不會超出容器
				在小螢幕上自動縮小
			*/
			max-width:100%;
			
			/* 
				自動高度：
				height: auto 保持圖片原始長寬比
				防止圖片變形
			*/
			height:auto;
			
			/* 
				塊級顯示：
				display: block 讓圖片佔據整行
				便於使用margin居中
			*/
			display:block;
			
			/* 
				居中顯示：
				上下邊距使用標準間距，左右auto實現居中
			*/
			margin:var(--sp) auto;
			
			/* 指針游標，表示可點擊查看大圖 */
			cursor:pointer;
			
			/* 圓角邊框，與整體設計保持一致 */
			border-radius:var(--br);
		}
		
		/* 
			===============================================
			=== 閱讀器控制元件 ===
			===============================================
		*/
		
		/* 
			=== 底部控制欄 ===
			包含導航按鈕和功能按鈕的固定欄
		*/
		.reader-controls{
			/* 固定在底部（通過.fixed-header類實現） */
			bottom:0;
			
			/* Flexbox 水平佈局 */
			display:flex;
			
			/* 按鈕居中排列 */
			justify-content:center;
			
			/* 按鈕之間的間隔 */
			gap:var(--sp);
		}
		
		/* 
			=== 隱藏狀態的控制欄 ===
			滾動時自動隱藏的效果
		*/
		.reader-controls.hidden{
			/* 
				向下平移100%高度：
				完全隱藏在螢幕底部之外
				提供更沉浸的閱讀體驗
			*/
			transform:translateY(100%);
		}
		
		/* 
			=== 閱讀器標題 ===
			顯示當前章節標題的區域
		*/
		.reader-title{
			/* 文字居中對齊 */
			text-align:center;
			
			/* 
				彈性增長：
				flex-grow: 1 讓標題區域佔據可用空間
				在導航按鈕之間居中顯示
			*/
			flex-grow:1;
		}
		
		/* 
			===============================================
			=== 模態框系統 (Modal) ===
			===============================================
			
			模態框是一種常見的UI組件，用於顯示重要信息或進行交互
			通常從底部滑入，覆蓋在主內容之上
			提供專注的用戶體驗，避免分散注意力
		*/
		.modal{
			/* 
				=== 定位系統 ===
				position: fixed - 相對於視窗定位，不隨頁面滾動
				這確保模態框始終保持在視窗中的固定位置
			*/
			position:fixed;
			
			/* 
				=== 垂直定位 ===
				bottom: 60px - 距離底部60px
				為底部控制欄留出空間，避免重疊
				確保模態框不會被其他UI元素遮擋
			*/
			bottom:60px;
			
			/* 
				=== 水平居中定位 ===
				left: 50% - 左邊界定位在視窗中央
				配合 transform: translateX(-50%) 實現精確居中
				這是CSS中居中固定定位元素的標準技巧
			*/
			left:50%;
			
			/* 
				=== 變換效果 ===
				transform: translate(-50%, 200%)
				- translateX(-50%): 水平居中對齊
				- translateY(200%): 初始狀態下移到視窗外（隱藏）
				200% 確保模態框完全移出可見區域
			*/
			transform:translate(-50%,200%);
			
			/* 
				=== 尺寸設置 ===
				width: 300px - 固定寬度，適合桌面端
				在移動端會被響應式樣式覆蓋
			*/
			width:300px;
			
			/* 
				=== 外觀設計 ===
				使用CSS變量確保與主題保持一致
			*/
			background:var(--bg);
			border:1px solid var(--border);
			border-radius:var(--br);
			
			/* 
				=== 內邊距與間距 ===
				padding: 1.5rem（24px）- 舒適的內部間距
				讓內容不會緊貼邊緣
			*/
			padding:1.5rem;
			
			/* 文字顏色使用主題變量 */
			color:var(--text);
			
			/* 
				=== 層級控制 ===
				z-index: 1001 - 高層級
				確保模態框顯示在大部分內容之上
				但低於載入動畫（9999）和燈箱（2000）
			*/
			z-index:1001;
			
			/* 
				=== 動畫過渡 ===
				transition: transform 0.3s
				變換屬性的過渡動畫，實現平滑的滑入滑出效果
				0.3秒的持續時間提供流暢但不緩慢的動畫
			*/
			transition:transform 0.3s;
			
			/* 
				=== 內容限制 ===
				max-height: 60vh - 最大高度為視窗高度的60%
				防止模態框在小屏幕上佔據過多空間
				保持其他UI元素的可見性
			*/
			max-height:60vh;
			
			/* 
				=== Flexbox 佈局 ===
				display: flex - 啟用彈性盒子佈局
				flex-direction: column - 垂直排列子元素
				這為模態框內容提供靈活的佈局控制
			*/
			display:flex;
			flex-direction:column;
			
			/* 
				=== 陰影效果 ===
				box-shadow: var(--shadow) - 使用主題陰影變量
				為模態框添加深度感，讓它浮在內容之上
			*/
			box-shadow:var(--shadow);
			
			/* 
				=== 文本排版 ===
				line-height: 1.5 - 適中的行高
				提升文本可讀性，特別是多行內容
			*/
			line-height:1.5;
		}
		
		/* 
			=== 模態框激活狀態 ===
			當模態框需要顯示時，添加 .active 類
		*/
		.modal.active{
			/* 
				transform: translate(-50%, 0)
				- translateX(-50%): 保持水平居中
				- translateY(0): 回到正常位置（不再下移）
				配合 transition 屬性，實現從底部滑入的動畫效果
			*/
			transform:translate(-50%,0);
		}
		/* 
			=== 模態框標題區域 ===
			模態框頂部的標題顯示區域
		*/
		.modal-header{
			/* 
				內邊距設置：
				- 上: 0, 右: 0, 下: var(--sp), 左: 0
				- 只在底部留出間距，與內容區分隔
			*/
			padding:0 0 var(--sp) 0;
			
			/* 
				底部邊框：
				- 1px solid：細實線邊框
				- var(--border)：使用主題邊框顏色
				- 視覺上分隔標題和內容區域
			*/
			border-bottom:1px solid var(--border);
			
			/* 粗體字重，突出標題重要性 */
			font-weight:bold;
			
			/* 文字居中對齊，提供平衡的視覺效果 */
			text-align:center;
		}
		
		/* 
			=== 模態框內容組 ===
			模態框主要內容區域，支持滾動
		*/
		.modal-group{
			/* 
				垂直滾動：
				- overflow-y: auto：內容超出時顯示滾動條
				- 確保長列表（如章節列表）可以完全訪問
			*/
			overflow-y:auto;
			
			/* 
				彈性增長：
				- flex: 1：佔據模態框的剩餘空間
				- 讓內容區域最大化利用可用空間
			*/
			flex:1;
			
			/* 移除默認外邊距 */
			margin:0;
			
			/* 上下內邊距，提供內容呼吸空間 */
			padding:var(--sp) 0;
		}
		
		/* 
			=== 模態框表單標籤 ===
			設置相關的標籤樣式
		*/
		.modal-group label{
			/* 
				塊級顯示：
				- display: block：標籤獨佔一行
				- 為表單元素提供清晰的標識
			*/
			display:block;
			
			/* 底部間距，與輸入元素保持距離 */
			margin-bottom:0.5rem;
			
			/* 使用主文字顏色 */
			color:var(--text);
		}
		
		/* 
			=== 範圍輸入滑桿樣式 ===
			用於字體大小、行高等數值設置
		*/
		.modal-group input[type="range"]{
			/* 佔滿容器寬度 */
			width:100%;
			
			/* 
				主題色：
				- accent-color：CSS新屬性，設置表單控件的主色調
				- 讓滑桿顏色與應用主題保持一致
			*/
			accent-color:var(--primary);
		}
		
		/* 
			=== 複選框樣式 ===
			用於深色模式等開關設置
		*/
		.modal-group input[type="checkbox"]{
			/* 右邊距，與標籤文字保持距離 */
			margin-right:0.5rem;
			
			/* 使用主題色 */
			accent-color:var(--primary);
		}
		
		/* 
			=== 當前章節高亮顯示（淺色主題） ===
			在章節選擇模態框中突出顯示當前正在閱讀的章節
		*/
		.modal .chapter-item.current{
			/* 
				淺藍色背景：
				- #bbdefb：Material Design 淺藍色
				- 溫和的背景色，不會過於突兀
			*/
			background:#bbdefb;
			
			/* 黑色文字確保在淺色背景上的可讀性 */
			color:#000;
		}
		
		/* 
			=== 深色主題下的當前章節高亮 ===
			針對深色主題優化的當前章節顯示
		*/
		[data-theme="dark"] .modal .chapter-item.current{
			/* 
				深藍色背景：
				- #1976d2：較深的藍色，適合深色主題
				- 與深色背景形成足夠對比，但不會過於刺眼
			*/
			background:#1976d2;
			
			/* 白色文字確保在深色背景上的清晰可讀性 */
			color:#fff;
		}
		
		/* 
			===============================================
			=== 圖片燈箱系統 (Lightbox) ===
			===============================================
			
			燈箱（Lightbox）是一種流行的圖片查看模式
			當用戶點擊縮略圖時，會在當前頁面上彈出大圖
			不需要跳轉到新頁面，提供流暢的瀏覽體驗
		*/
		.lightbox{
			/* 
				=== 全屏覆蓋層設置 ===
				position: fixed - 相對於視窗定位，不隨頁面滾動
				這確保燈箱始終覆蓋整個可見區域
			*/
			position:fixed;
			
			/* 
				inset: 0 是 top/right/bottom/left: 0 的簡寫
				讓元素完全覆蓋視窗的所有四個邊
				等同於：
				top: 0;
				right: 0;
				bottom: 0;
				left: 0;
			*/
			inset:0;
			
			/* 
				半透明黑色背景：
				rgba(0,0,0,0.9) - 90% 不透明度的黑色
				這創建了一個深色遮罩，突出顯示圖片內容
				同時仍能隱約看到背後的頁面內容
			*/
			background:rgba(0,0,0,0.9);
			
			/* 
				初始狀態設為 display: none
				燈箱默認是隱藏的，只在需要時顯示
			*/
			display:none;
			
			/* 
				Flexbox 居中對齊：
				justify-content: center - 水平居中
				align-items: center - 垂直居中
				這確保圖片始終在視窗中央顯示
			*/
			justify-content:center;
			align-items:center;
			
			/* 
				z-index: 2000 - 非常高的層級
				確保燈箱顯示在所有其他內容之上
				通常：
				- 普通內容：1-10
				- 下拉菜單：100-500
				- 模態框：1000-1500
				- 燈箱：2000+
			*/
			z-index:2000;
			
			/* 
				初始透明度為 0
				配合 transition 實現淡入效果
			*/
			opacity:0;
			
			/* 
				透明度過渡動畫：
				0.3秒的淡入淡出效果
				提供平滑的視覺過渡
			*/
			transition:opacity 0.3s;
		}
		
		/* 
			=== 燈箱激活狀態 ===
			當添加 .active 類時，燈箱變為可見
		*/
		.lightbox.active{
			/* 改為 flex 顯示，激活 Flexbox 佈局 */
			display:flex;
			
			/* 完全不透明，配合過渡動畫實現淡入效果 */
			opacity:1;
		}
		
		/* 
			=== 燈箱內容容器 ===
			包裹實際圖片內容的容器
		*/
		.lightbox-content{
			/* 
				position: relative - 為關閉按鈕提供定位參考
				子元素的 position: absolute 會相對於此容器定位
			*/
			position:relative;
			
			/* 
				最大寬度限制：95%
				留出 5% 的邊距，防止圖片貼邊
				提供視覺呼吸空間
			*/
			max-width:95%;
			
			/* 
				最大高度限制：85vh（視窗高度的85%）
				確保圖片不會超出螢幕
				留出空間顯示關閉按鈕
			*/
			max-height:85vh;
		}
		
		/* 
			=== 燈箱圖片樣式 ===
			控制燈箱中圖片的顯示方式
		*/
		.lightbox img{
			/* 圖片最大寬度不超過容器 */
			max-width:100%;
			
			/* 圖片最大高度不超過視窗的85% */
			max-height:85vh;
			
			/* 
				object-fit: contain - 保持圖片比例的同時完整顯示
				- contain：完整顯示圖片，可能有留白
				- cover：填滿容器，可能裁切圖片
				- fill：拉伸圖片填滿容器，可能變形
				這裡選擇 contain 確保用戶能看到完整圖片
			*/
			object-fit:contain;
		}
		
		/* 
			=== 燈箱關閉按鈕 ===
			右上角的 X 關閉按鈕
		*/
		.close-lightbox{
			/* 絕對定位相對於 .lightbox-content */
			position:absolute;
			
			/* 
				top: -40px - 負值定位
				將按鈕放置在內容容器的上方
				避免遮擋圖片內容
			*/
			top:-40px;
			
			/* 右對齊 */
			right:0;
			
			/* 白色文字，在深色背景上清晰可見 */
			color:white;
			
			/* 較大的字體，便於點擊 */
			font-size:24px;
			
			/* 手型游標，表示可點擊 */
			cursor:pointer;
			
			/* 移除按鈕的默認樣式 */
			background:none;
			border:none;
			
			/* 適當的內邊距，增加點擊區域 */
			padding:8px;
		}
		
		/* 
			===============================================
			=== 載入動畫系統 (Loading Overlay) ===
			===============================================
			
			載入動畫用於異步操作時提供視覺反饋
			告訴用戶系統正在處理請求，避免用戶重複操作
			提升用戶體驗的重要組件
		*/
		.loading-overlay{
			/* 
				=== 全屏覆蓋層 ===
				與燈箱類似的全屏覆蓋設置
			*/
			position:fixed;
			
			/* 覆蓋整個視窗 */
			inset:0;
			
			/* 
				半透明黑色背景：
				rgba(0,0,0,0.7) - 70% 不透明度
				比燈箱稍微透明一些，讓用戶仍能看到背景內容
				暗示操作仍在當前頁面進行
			*/
			background:rgba(0,0,0,0.7);
			
			/* 默認隱藏 */
			display:none;
			
			/* Flexbox 居中對齊載入動畫 */
			justify-content:center;
			align-items:center;
			
			/* 
				z-index: 9999 - 最高層級
				載入動畫應該顯示在所有內容之上
				包括模態框和燈箱
				防止用戶在載入時進行其他操作
			*/
			z-index:9999;
		}
		
		/* 
			=== 載入覆蓋層顯示狀態 ===
			通過添加 .show 類來顯示載入動畫
		*/
		.loading-overlay.show{
			/* 激活 Flexbox 佈局，使內容居中 */
			display:flex;
		}
		
		/* 
			=== 旋轉載入動畫 (Spinner) ===
			經典的圓形旋轉載入指示器
		*/
		.loading-spinner{
			/* 
				=== 尺寸設置 ===
				50x50 像素的正方形
				適中的大小，既醒目又不會過於突兀
			*/
			width:50px;
			height:50px;
			
			/* 
				=== 邊框設計 ===
				使用邊框創建圓環效果：
				- 整體邊框：4px 寬，半透明白色（30% 不透明度）
				- 這創建了一個淺色的圓環背景
			*/
			border:4px solid rgba(255,255,255,0.3);
			
			/* 
				頂部邊框：純白色
				這創建了旋轉時的視覺焦點
				看起來像是一個缺口的圓環在旋轉
			*/
			border-top:4px solid white;
			
			/* 
				border-radius: 50% - 創建完美的圓形
				將正方形轉換為圓形
			*/
			border-radius:50%;
			
			/* 
				=== 動畫設置 ===
				animation: spin 1s linear infinite
				- spin：動畫名稱（在下面定義）
				- 1s：動畫持續時間（1秒完成一圈）
				- linear：線性動畫，勻速旋轉
				- infinite：無限循環
			*/
			animation:spin 1s linear infinite;
		}
		
		/* 
			=== 旋轉動畫關鍵幀 ===
			@keyframes 定義動畫的關鍵幀
			這裡定義了一個360度旋轉動畫
		*/
		@keyframes spin{
			/* 起始狀態：0度旋轉 */
			0%{transform:rotate(0deg)}
			
			/* 結束狀態：360度旋轉（完整一圈） */
			100%{transform:rotate(360deg)}
			
			/* 
				瀏覽器會自動在這兩個關鍵幀之間插值
				創建平滑的旋轉動畫
				配合 linear 時間函數，實現勻速旋轉
			*/
		}
		
		/* 
			===============================================
			=== 頁腳組件 (Footer) ===
			===============================================
			
			頁腳通常包含版權信息、聯繫方式或其他補充信息
			是網頁的標準組成部分，提供頁面的完整性
		*/
		.footer{
			/* 
				=== 背景顏色 ===
				var(--bg) - 使用CSS變量定義的背景色
				與頁面主體背景保持一致
				支持深色/淺色主題切換
			*/
			background:var(--bg);
			
			/* 
				=== 頂部邊框 ===
				1px 實線邊框，使用變量顏色
				視覺上將頁腳與主內容區分開
				創建清晰的區域劃分
			*/
			border-top:1px solid var(--border);
			
			/* 
				=== 內邊距設置 ===
				padding: 2rem 0 - 上下各2rem（32px）
				提供充足的垂直空間
				讓頁腳內容不會顯得擁擠
			*/
			padding:2rem 0;
			
			/* 
				=== 外邊距設置 ===
				margin-top: 3rem - 頂部外邊距48px
				與主內容保持適當距離
				創建視覺呼吸空間
			*/
			margin-top:3rem;
			
			/* 
				文本居中對齊
				頁腳信息通常居中顯示
				符合常見的設計慣例
			*/
			text-align:center;
			
			/* 
				=== 文字顏色 ===
				var(--text-muted) - 淡化的文字顏色
				頁腳文字通常使用較淡的顏色
				表示這是次要信息
			*/
			color:var(--text-muted);
		}
		
		/* 
			=== 頁腳內容容器 ===
			限制頁腳內容的最大寬度
			與主內容區域保持一致
		*/
		.footer-content{
			/* 
				最大寬度：1200px
				與主容器 .container 保持一致
				確保視覺對齊
			*/
			max-width:1200px;
			
			/* 
				水平居中：
				margin: 0 auto - 上下0，左右自動
				這是CSS中水平居中塊級元素的標準方法
			*/
			margin:0 auto;
			
			/* 
				水平內邊距：
				var(--sp) - 使用全局間距變量
				保持與其他容器一致的邊距
			*/
			padding:0 var(--sp);
		}
		
		/* 
			=== 頁腳文字樣式 ===
			設置頁腳文字的排版
		*/
		.footer-text{
			/* 
				字體大小：0.9rem（14.4px）
				比正文稍小，符合頁腳信息的次要地位
				但仍保持良好的可讀性
			*/
			font-size:0.9rem;
			
			/* 
				行高：1.6
				適當的行距，提升多行文本的可讀性
				特別是當頁腳包含多行信息時
			*/
			line-height:1.6;
		}
		/* 
			=== 桌面端專用元素 ===
			.desktop-only 類用於標記只在桌面端顯示的元素
		*/
		.desktop-only{
			/* 默認在桌面端顯示 */
			display:block;
		}
		
		/* 
			===============================================
			=== 響應式設計 - 移動端適配 ===
			===============================================
			
			@media 媒體查詢是響應式設計的核心技術
			它允許我們根據設備特性（如螢幕寬度）應用不同的CSS樣式
			
			這個媒體查詢針對最大寬度為 768px 的設備（平板和手機）
			768px 是一個常用的斷點，區分桌面端和移動端
		*/
		@media (max-width:768px){
			/* 
				=== 隱藏桌面端專用元素 ===
				在小螢幕設備上隱藏不必要的元素，節省空間
			*/
			.desktop-only{
				display:none;
			}
			
			/* 
				=== 導航欄移動端適配 ===
				使用 clamp() 函數實現流體內邊距
			*/
			.navbar{
				/* 
					響應式內邊距：
					- 最小值：0.5rem（8px）- 確保在最小設備上有基本間距
					- 首選值：2vw（視窗寬度的2%）- 隨螢幕大小動態調整
					- 最大值：0.8rem（12.8px）- 防止在大平板上過大
				*/
				padding:clamp(0.5rem,2vw,0.8rem);
			}
			
			/* 
				=== 導航標題移動端適配 ===
				根據螢幕寬度動態調整標題大小
			*/
			.nav-title{
				/* 
					響應式字體大小：
					- 最小值：1rem（16px）- 保證可讀性
					- 首選值：4vw（視窗寬度的4%）- 動態縮放
					- 最大值：1.3rem（20.8px）- 與桌面端保持一致
				*/
				font-size:clamp(1rem,4vw,1.3rem);
			}
			
			/* 
				=== 主容器移動端適配 ===
				減少內邊距以最大化內容顯示空間
			*/
			.container{
				/* 
					極小的響應式內邊距：
					- 最小值：8px - 確保內容不會緊貼螢幕邊緣
					- 首選值：2vw - 隨螢幕寬度調整
					- 最大值：16px - 適中的間距
				*/
				padding:clamp(8px,2vw,16px);
			}
			
			/* 
				=== 內容網格移動端適配 ===
				CSS Grid 佈局的移動端優化
			*/
			.content-grid{
				/* 
					響應式網格列：
					- repeat(auto-fit, ...) - 自動適配列數
					- minmax() - 每列的最小和最大寬度
					- clamp(140px,35vw,180px) - 響應式列寬
						* 最小：140px - 確保卡片有足夠寬度顯示內容
						* 首選：35vw - 視窗寬度的35%
						* 最大：180px - 防止卡片過大
				*/
				grid-template-columns:repeat(auto-fit,minmax(clamp(140px,35vw,180px),1fr));
				
				/* 
					響應式網格間隔：
					- 最小：18px - 保證卡片之間有清晰分隔
					- 首選：4.5vw - 隨螢幕大小動態調整
					- 最大：36px - 防止間隔過大
				*/
				gap:clamp(18px,4.5vw,36px);
				
				/* 
					容器內邊距：
					為網格提供額外的邊距，防止內容觸碰邊緣
				*/
				padding:0 clamp(4px,1vw,12px);
			}
			
			/* 
				=== 卡片標題移動端適配 ===
				調整卡片標題的字體大小以適應小螢幕
			*/
			.card-title{
				/* 響應式標題字體：保持可讀性的同時節省空間 */
				font-size:clamp(0.9rem,3vw,1.1rem);
			}
			
			/* 
				=== 卡片頁腳移動端適配 ===
				減小次要信息的字體大小
			*/
			.card-footer{
				/* 
					小字體響應式設計：
					- 0.7rem（11.2px）- 最小可讀字體大小
					- 2vw - 視窗寬度的2%
					- 0.8rem（12.8px）- 桌面端較大字體
				*/
				font-size:clamp(0.7rem,2vw,0.8rem);
			}
			
			/* 
				=== 小說信息佈局移動端適配 ===
				調整小說詳情頁面的佈局結構
			*/
			.novel-info{
				/* 
					響應式兩列佈局：
					- 第一列（封面）：clamp(120px,30vw,200px) - 響應式封面寬度
					- 第二列（信息）：1fr - 佔據剩餘空間
				*/
				grid-template-columns:clamp(120px,30vw,200px) 1fr;
				
				/* 響應式列間隔 */
				gap:clamp(0.8rem,2vw,1.5rem);
			}
			
			/* 
				=== 小說封面移動端適配 ===
				確保封面圖片不會超出容器
			*/
			.novel-cover{
				/* 最大寬度100%，防止圖片溢出 */
				max-width:100%;
			}
			
			/* 
				=== 小說標題移動端適配 ===
				大標題的響應式字體設計
			*/
			.novel-title{
				/* 
					大標題響應式字體：
					- 1.2rem（19.2px）- 移動端最小標題大小
					- 5vw - 視窗寬度的5%，提供顯著的視覺層次
					- 2rem（32px）- 與桌面端保持一致的最大值
				*/
				font-size:clamp(1.2rem,5vw,2rem);
			}
			
			/* 
				=== 章節列表移動端適配 ===
				優化章節選擇的觸控體驗
			*/
			.chapter-list{
				/* 
					更密集的章節網格：
					- 每個章節項目的最小寬度更小，適合手機螢幕
					- clamp(80px,20vw,140px) - 響應式章節卡片寬度
				*/
				grid-template-columns:repeat(auto-fill,minmax(clamp(80px,20vw,140px),1fr));
			}
			
			/* 
				=== 章節標題移動端適配 ===
				保持章節標題的可讀性
			*/
			.chapter-title{
				/* 適中的響應式字體大小，平衡可讀性和空間利用 */
				font-size:clamp(0.8rem,2.5vw,1rem);
			}
			
			/* 
				=== 移動端閱讀器容器樣式 ===
				針對小螢幕設備優化的閱讀器佈局
			*/
			.reader-container{
				/* 
					全寬度設計：
					width:100% 充分利用小螢幕空間
					移除桌面端的寬度限制，提供更大閱讀區域
				*/
				width:100%;
				
				/* 
					響應式邊距設計：
					margin:clamp(4px,1vw,8px) 0 clamp(60px,15vw,80px)
					- 頂部邊距：最小4px，理想1vw，最大8px
					- 左右邊距：0（全寬度設計）
					- 底部邊距：最小60px，理想15vw，最大80px
					- vw單位：視窗寬度的百分比，實現真正的響應式
				*/
				margin:clamp(4px,1vw,8px) 0 clamp(60px,15vw,80px);
				
				/* 
					響應式內邊距：
					clamp(0.5rem,2vw,1rem) 確保內容不會緊貼邊緣
					在不同設備上提供舒適的閱讀空間
				*/
				padding:clamp(0.5rem,2vw,1rem);
				
				/* 
					移除裝飾效果：
					border-radius:0 移除圓角，適合全寬度設計
					box-shadow:none 移除陰影，減少視覺複雜度
				*/
				border-radius:0;
				box-shadow:none;
			}
			
			/* 
				=== 移動端閱讀器控制欄樣式 ===
				針對小螢幕設備優化的閱讀控制面板
			*/
			.reader-controls{
				/* 
					固定底部定位：
					bottom:0 將控制欄固定在螢幕底部
					配合原有的 position:fixed，確保始終可見
				*/
				bottom:0;
				
				/* 
					響應式內邊距：
					clamp(0.5rem,2vw,1rem) 在不同設備上提供舒適的觸控空間
					- 最小0.5rem：確保基本的操作空間
					- 理想2vw：根據視窗寬度動態調整
					- 最大1rem：避免佔用過多螢幕空間
				*/
				padding:clamp(0.5rem,2vw,1rem);
			}
			
			/* 
				=== 移動端主要按鈕樣式 ===
				針對觸控設備優化的按鈕尺寸和間距
			*/
			.btn-primary{
				/* 
					響應式內邊距：
					padding:clamp(0.3rem,1vw,0.5rem) clamp(0.5rem,2vw,1rem)
					- 垂直內邊距：最小0.3rem，理想1vw，最大0.5rem
					- 水平內邊距：最小0.5rem，理想2vw，最大1rem
					- 確保按鈕在小螢幕上有足夠的觸控面積
				*/
				padding:clamp(0.3rem,1vw,0.5rem) clamp(0.5rem,2vw,1rem);
				
				/* 
					響應式字體大小：
					clamp(0.8rem,2.5vw,1rem) 確保文字在不同設備上清晰可讀
					- 最小0.8rem：保證最小可讀性
					- 理想2.5vw：根據視窗寬度調整
					- 最大1rem：避免文字過大
				*/
				font-size:clamp(0.8rem,2.5vw,1rem);
				
				/* 
					響應式最小寬度：
					clamp(60px,15vw,80px) 適應移動端的觸控需求
					- 最小60px：符合觸控設計指南
					- 理想15vw：根據設備寬度調整
					- 最大80px：與桌面端保持一致
				*/
				min-width:clamp(60px,15vw,80px);
			}
			
			/* 
				=== 模態框移動端適配 ===
				注意：這裡引用了 .modal 類，但主要的模態框樣式可能在其他地方定義
				這是針對移動端的響應式調整
			*/
			.modal{
				/* 
					響應式寬度設置：
					clamp(280px, 85vw, 350px)
					- 最小寬度：280px - 確保在小屏幕上有足夠的內容空間
					- 首選寬度：85vw - 視窗寬度的85%
					- 最大寬度：350px - 防止在平板上過寬
					
					這確保模態框在各種設備上都有合適的尺寸
				*/
				width:clamp(280px,85vw,350px);
				
				/* 
					額外的最大寬度限制：90vw
					作為安全措施，確保模態框永遠不會超出視窗
					留出兩側各5%的邊距
				*/
				max-width:90vw;
			}
			
			/* 
				=== 頁腳移動端適配 ===
				調整頁腳在移動設備上的間距
			*/
			.footer{
				/* 
					響應式垂直內邊距：
					clamp(1rem, 4vw, 2rem)
					- 最小：1rem（16px）- 移動端較小的內邊距
					- 首選：4vw - 視窗寬度的4%
					- 最大：2rem（32px）- 桌面端的標準內邊距
					
					在小屏幕上減少內邊距，節省垂直空間
				*/
				padding:clamp(1rem,4vw,2rem) 0;
				
				/* 
					響應式頂部外邊距：
					clamp(1.5rem, 4vw, 3rem)
					- 最小：1.5rem（24px）- 移動端較小的間距
					- 首選：4vw
					- 最大：3rem（48px）- 桌面端的標準間距
					
					減少與主內容的距離，優化移動端的垂直空間使用
				*/
				margin-top:clamp(1.5rem,4vw,3rem);
			}
			
			/* 
				=== 頁腳文字移動端適配 ===
				確保頁腳文字在小屏幕上的可讀性
			*/
			.footer-text{
				/* 
					響應式字體大小：
					clamp(0.8rem, 2.5vw, 0.9rem)
					- 最小：0.8rem（12.8px）- 仍然可讀的最小字體
					- 首選：2.5vw - 視窗寬度的2.5%
					- 最大：0.9rem（14.4px）- 桌面端的標準大小
					
					在保持可讀性的前提下，適當縮小字體
					為移動端優化顯示效果
				*/
				font-size:clamp(0.8rem,2.5vw,0.9rem);
			}
		}
	</style>
</head>
<!-- 
	=== HTML 主體開始 ===
	<body> 標籤包含網頁的所有可見內容
	Vue.js 應用程式將掛載到這個區域內的元素上
-->
<body>
	<!-- 
		===============================================
		=== Vue.js 應用程式根容器 ===
		===============================================
		
		這個 div 是 Vue.js 應用程式的掛載點
		id="app" 是 Vue 實例掛載的目標元素
		Vue.js 會接管這個元素及其所有子元素
	-->
	<div id="app" :class="'page-'+currentPage">
		<!-- 
			=== 動態 CSS 類別綁定 ===
			:class 是 v-bind:class 的縮寫
			這裡使用 JavaScript 表達式 'page-'+currentPage
			根據 currentPage 的值動態添加 CSS 類別：
			- currentPage='list' → class="page-list"
			- currentPage='detail' → class="page-detail"  
			- currentPage='reader' → class="page-reader"
			這允許每個頁面有不同的樣式設置
		-->
		
		<!-- 
			===============================================
			=== 主導航欄組件 ===
			===============================================
		-->
		<nav class="navbar fixed-header" v-show="currentPage!=='reader'">
			<!-- 
				=== 條件顯示指令 ===
				v-show="currentPage!=='reader'" 是 Vue.js 的條件顯示指令
				- 當條件為 true 時：元素正常顯示（display: block）
				- 當條件為 false 時：元素隱藏（display: none）
				這裡的邏輯是：在閱讀器頁面隱藏導航欄，其他頁面顯示
				
				v-show vs v-if 的區別：
				- v-show：元素始終渲染到 DOM，只是切換 CSS 顯示狀態
				- v-if：條件為 false 時，元素完全不渲染到 DOM
				v-show 適合頻繁切換的場景
			-->
			
			<div class="nav-container">
				<div class="nav-left">
					<!-- 
						=== 條件渲染指令 ===
						v-if="currentPage==='detail'" 是 Vue.js 的條件渲染指令
						只有當條件為 true 時，這個按鈕才會被渲染到 DOM
						這是一個返回按鈕，只在詳情頁面顯示
					-->
					<button v-if="currentPage==='detail'" class="btn-base btn-transparent" @click="goToHome">
						<!-- 
							=== SVG 圖標 ===
							使用內聯 SVG 創建返回箭頭圖標
							SVG 的優勢：
							1. 矢量圖形，在任何分辨率下都清晰
							2. 可以通過 CSS 控制顏色（stroke="currentColor"）
							3. 文件大小小，加載快速
							4. 易於自定義和動畫
						-->
						<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
							<path d="M19 12H5M12 19l-7-7 7-7"/>
						</svg>
					</button>
					
					<!-- 
						=== 反向條件渲染 ===
						v-if="currentPage!=='detail'" 當不在詳情頁面時顯示標題
						這確保返回按鈕和標題不會同時出現
					-->
					<a v-if="currentPage!=='detail'" class="nav-title" @click="goToHome">輕小說翻譯</a>
					<!-- 
						=== 事件監聽器 ===
						@click="goToHome" 是 v-on:click 的縮寫
						當用戶點擊標題時，會執行 goToHome 方法
						這實現了點擊標題返回首頁的功能
					-->
				</div>
				
				<div class="nav-right">
					<!-- 
						===============================================
						=== 下拉菜單組件 ===
						===============================================
					-->
					<div class="dropdown" v-show="currentPage==='list'" @mouseenter="handleDropdownMouseEnter" @mouseleave="handleDropdownMouseLeave">
						<!-- 
							=== 多重事件監聽 ===
							@mouseenter 和 @mouseleave 處理滑鼠懸停事件
							這實現了滑鼠懸停時自動展開下拉菜單的功能
							提升用戶體驗：不需要點擊就能預覽菜單內容
						-->
						
						<!-- 
							=== 模板引用 ===
							ref="dropdownToggle" 創建對這個元素的引用
							在 JavaScript 中可以通過 this.$refs.dropdownToggle 訪問這個元素
							用於計算下拉菜單的定位
						-->
						<button ref="dropdownToggle" class="dropdown-toggle" @click="toggleSortDropdown" :class="{active:activeDropdown==='sort'}">
							<!-- 
								=== 對象式類別綁定 ===
								:class="{active:activeDropdown==='sort'}" 
								這是對象語法的類別綁定：
								- 鍵：CSS 類別名稱（active）
								- 值：布林表達式（activeDropdown==='sort'）
								- 當表達式為 true 時，添加 active 類別
								- 當表達式為 false 時，移除 active 類別
							-->
							
							<!-- SVG 排序圖標 -->
							<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
								<path d="M4 7h10M4 12h8M4 17h6"></path>
								<path d="M17 13l3 3l3-3"></path>
								<path d="M20 8v8"></path>
							</svg>
							
							<!-- 
								=== 插值表達式 ===
								{{currentSortLabel}} 是 Vue.js 的插值語法
								雙大括號內的內容會被替換為 currentSortLabel 的值
								這是響應式的：當 currentSortLabel 改變時，顯示會自動更新
							-->
							<span>{{currentSortLabel}}</span>
						</button>
						
						<!-- 
							=== 下拉菜單內容 ===
						-->
						<div class="dropdown-menu" :class="{show:activeDropdown==='sort'}">
							<!-- 
								===============================================
								=== 列表渲染指令 ===
								===============================================
								
								v-for="option in sortOptions" 是 Vue.js 的列表渲染指令
								遍歷 sortOptions 數組，為每個元素創建一個 <a> 標籤
								
								:key="option.value" 提供唯一鍵值
								Vue.js 使用 key 來追蹤每個節點的身份
								這對於高效的 DOM 更新很重要
								
								當列表項目順序改變時，Vue 可以：
								1. 重複使用現有的 DOM 元素
								2. 只更新改變的部分
								3. 避免不必要的重新渲染
							-->
							<a v-for="option in sortOptions" :key="option.value" @click="handleSortChange(option)" :class="{active:currentSort===option.value}">
								<!-- 
									=== 事件處理器傳參 ===
									@click="handleSortChange(option)"
									在事件處理器中傳遞參數
									option 是當前循環項目的數據
								-->
								
								<span>{{option.label}}</span>
								
								<!-- 
									=== 條件渲染 ===
									v-if="currentSort===option.value"
									只有當當前選項被選中時才顯示勾選標記
									這提供了視覺反饋，讓用戶知道當前的排序方式
								-->
								<span v-if="currentSort===option.value" class="checkmark">✓</span>
							</a>
						</div>
					</div>
					
					<!-- 
						===============================================
						=== 主題切換按鈕 ===
						===============================================
					-->
					<button class="theme-toggle" @click="isDarkMode=!isDarkMode">
						<!-- 
							=== 三元運算符 ===
							{{isDarkMode?'🌜':'🌞'}} 使用 JavaScript 三元運算符
							語法：條件 ? 值1 : 值2
							- 如果 isDarkMode 為 true，顯示月亮 emoji 🌜
							- 如果 isDarkMode 為 false，顯示太陽 emoji 🌞
							這提供了直觀的視覺指示器
						-->
						{{isDarkMode?'🌜':'🌞'}}
					</button>
					<!-- 
						=== 事件處理器中的表達式 ===
						@click="isDarkMode=!isDarkMode"
						直接在事件處理器中寫 JavaScript 表達式
						!isDarkMode 是邏輯取反，實現開關切換效果
						Vue.js 會自動檢測這個賦值並觸發響應式更新
					-->
				</div>
			</div>
		</nav>
		<!-- 
			=== 小說列表頁面 ===
			顯示所有可用小說的網格佈局
			v-show 條件渲染：只在 currentPage === 'list' 時顯示
		-->
		<div class="container" v-show="currentPage==='list'">
			<!-- 
				響應式網格容器：
				使用 CSS Grid 實現自適應的卡片佈局
			-->
			<div class="content-grid">
				<!-- 
					=== 小說卡片循環渲染 ===
					v-for: 遍歷 sortedNovelList 數組
					:key: 使用 item.title 作為唯一標識符
					@click: 點擊卡片時調用 goToDetail 方法
				-->
				<div v-for="item in sortedNovelList" :key="item.title" class="card" @click="goToDetail(item)">
					<!-- 
						=== 小說封面圖片 ===
						:src: 動態綁定圖片源地址
						:alt: 無障礙訪問的替代文字
						@error: 圖片加載失敗時的錯誤處理
					-->
					<img :src="item.coverUrl" :alt="item.title" @error="handleImageError">
					
					<!-- 卡片信息區域 -->
					<div class="card-info">
						<!-- 
							小說標題顯示：
							{{item.title}}: 文本插值，顯示小說名稱
						-->
						<div class="card-title">{{item.title}}</div>
						
						<!-- 卡片底部信息 -->
						<div class="card-footer">
							<!-- 作者名稱 -->
							<span>{{item.author}}</span>
							<!-- 
								最後更新時間：
								formatDate: 自定義方法格式化日期
								'list': 傳遞格式參數，用於列表頁的簡化顯示
							-->
							<span>{{formatDate(item.lastUpdated,'list')}}</span>
						</div>
					</div>
				</div>
			</div>
		</div>
		
		<!-- 
			=== 小說詳情頁面容器 ===
			使用 Vue.js 條件顯示指令 v-show，當 currentPage === 'detail' 時顯示
			
			v-show vs v-if 的區別：
			- v-show: 元素始終被渲染，只是控制 CSS display 屬性
			- v-if: 根據條件決定是否渲染元素到 DOM
			- v-show 適合頻繁切換的場景，性能更好
			
			條件表達式解析：
			- currentPage: Vue 響應式數據，追蹤當前頁面狀態
			- === 'detail': 嚴格相等比較，確保類型和值都匹配
			- 只有在小說詳情頁面時才顯示此容器
		-->
		<div class="container" v-show="currentPage==='detail'">
			<!-- 
				=== 小說詳情主容器 ===
				包含小說信息和章節列表的完整詳情頁面
			-->
			<div class="novel-detail">
				<!-- 
					=== 小說基本信息區域 ===
					顯示封面、標題、作者等基本資料
				-->
				<div class="novel-info">
					<!-- 
						=== 小說封面圖片 ===
						Vue.js 動態屬性綁定和事件處理的綜合應用
						
						:src="getCoverUrl()": 動態綁定圖片來源
						- 調用方法獲取封面URL
						- 支持自動回退到預設圖片
						
						:alt="selectedNovel?.title": 可選鏈操作符
						- 安全訪問嵌套屬性，避免 undefined 錯誤
						- 提供無障礙支援的替代文字
						
						@click="openLightbox(getCoverUrl())": 點擊事件處理
						- 點擊圖片開啟全屏燈箱效果
						- 傳遞圖片URL參數給燈箱功能
						
						@error="handleImageError": 圖片加載錯誤處理
						- 當圖片無法加載時的回退機制
						- 自動替換為預設圖片，提升用戶體驗
					-->
					<img :src="getCoverUrl()" :alt="selectedNovel?.title" class="novel-cover" @click="openLightbox(getCoverUrl())" @error="handleImageError">
					<div>
						<!-- 
							=== 小說標題 ===
							{{selectedNovel?.title}}: Vue.js 文字插值
							- 使用可選鏈操作符安全訪問屬性
							- 響應式更新：當 selectedNovel 變化時自動重新渲染
						-->
						<h2 class="novel-title">{{selectedNovel?.title}}</h2>
						<!-- 
							=== 小說元數據區域 ===
							包含作者、類型、原始連結等詳細信息
						-->
						<div class="novel-metadata">
							<!-- 作者信息：使用 strong 標籤突出顯示標籤 -->
							<p><strong>作者：</strong>{{selectedNovel?.author}}</p>
							
							<!-- 類型信息：顯示小說分類 -->
							<p><strong>類型：</strong>{{selectedNovel?.genres}}</p>
							
							<!-- 
								=== 原始來源連結區域 ===
								條件渲染：只有當存在來源連結時才顯示
								
								v-if 條件解析：
								selectedNovel?.sourceLinks: 檢查是否有來源連結對象
								&& Object.keys(selectedNovel.sourceLinks).length: 確保對象不為空
								- 雙重驗證：既檢查屬性存在，又檢查內容不為空
								- 避免顯示空的連結區域
							-->
							<p class="source-links" v-if="selectedNovel?.sourceLinks&&Object.keys(selectedNovel.sourceLinks).length">
								<strong>原連結：</strong>
								<!-- 
									=== 動態連結列表 ===
									v-for="(link,key) in selectedNovel.sourceLinks": 遍歷連結對象
									- link: 連結URL值
									- key: 連結類型鍵名（如 'syosetu', 'kakuyomu'）
									- :key="key": Vue.js 列表渲染的唯一標識符
									
									:href="link": 動態綁定連結地址
									target="_blank": 在新視窗開啟外部連結
									{{getSourceLinkName(key)}}: 顯示連結的友好名稱
								-->
								<a v-for="(link,key) in selectedNovel.sourceLinks" :key="key" :href="link" target="_blank" class="source-link">{{getSourceLinkName(key)}}</a>
							</p>
						</div>
						
						<!-- 
							=== 小說描述區域 ===
							v-if="parsedDescription": 條件渲染，只有解析後的描述存在時才顯示
							v-html="parsedDescription": 危險的 HTML 插值
							- 將 Markdown 解析後的 HTML 直接插入到 DOM
							- 注意：v-html 會覆蓋元素的所有子節點
							- 安全性：確保內容已經過適當的清理和驗證
						-->
						<div class="novel-description" v-if="parsedDescription" v-html="parsedDescription"></div>
					</div>
				</div>
				
				<!-- 
					=== 章節列表區域 ===
					顯示小說所有章節的可點擊列表
				-->
				<div class="chapter-list">
					<!-- 
						=== 章節項目循環渲染 ===
						Vue.js 列表渲染和條件類別的綜合應用
						
						v-for="chapter in chaptersWithDates": 遍歷章節數組
						- chaptersWithDates: 包含日期信息的章節數據
						- chapter: 當前遍歷的章節對象
						
						:key="chapter.number": Vue.js 渲染優化
						- 使用章節編號作為唯一標識符
						- 提升列表更新性能，避免不必要的重新渲染
						
						:class="{read:isChapterRead(chapter.number)}": 動態類別
						- 條件類別：當章節已讀時添加 'read' 類
						- isChapterRead(): 檢查章節是否已被閱讀
						- 視覺反饋：已讀章節會有不同的外觀
						
						@click="goToChapter(chapter.number,false)": 點擊事件
						- 點擊章節項目跳轉到閱讀頁面
						- 傳遞章節編號和 autoScroll 參數（false）
					-->
					<div v-for="chapter in chaptersWithDates" :key="chapter.number" class="chapter-item" :class="{read:isChapterRead(chapter.number)}" @click="goToChapter(chapter.number,false)">
						<!-- 
							=== 章節標題 ===
							{{chapter.title}}: 顯示章節名稱
						-->
						<div class="chapter-title">{{chapter.title}}</div>
						
						<!-- 
							=== 章節日期 ===
							{{formatDate(chapter.date)}}: 格式化顯示章節日期
							- formatDate(): 日期格式化方法
							- 提供一致的日期顯示格式
						-->
						<div class="chapter-date">{{formatDate(chapter.date)}}</div>
					</div>
				</div>
			</div>
		</div>
		<!-- 
			=== 頁腳區域 ===
			條件顯示：只在非閱讀器頁面顯示
			
			v-show="currentPage!=='reader'": 條件顯示邏輯
			- 當不在閱讀器頁面時才顯示頁腳
			- !== 嚴格不等比較，確保類型和值都不相等
			- 在閱讀器模式下隱藏，提供沉浸式閱讀體驗
		-->
		<footer class="footer" v-show="currentPage!=='reader'">
			<!-- 頁腳內容容器 -->
			<div class="footer-content">
				<!-- 頁腳文字區域 -->
				<div class="footer-text">
					<!-- 版權聲明文字 -->
					<p>所有作品版權歸原作者所有，本站僅供學習交流使用</p>
				</div>
			</div>
		</footer>
		
		<!-- 
			=== 閱讀器頁面容器 ===
			閱讀模式的完整界面，包含導航欄、內容區、控制欄和模態框
			
			v-show="currentPage==='reader'": 條件顯示
			- 只在閱讀器頁面時顯示
			- 包含完整的閱讀界面組件
		-->
		<div v-show="currentPage==='reader'">
			<!-- 
				=== 閱讀器導航欄 ===
				固定在頂部的導航工具欄，包含返回按鈕和章節標題
				
				:class="{hidden:hideControls}": 動態隱藏邏輯
				- 根據 hideControls 狀態控制導航欄顯示
				- 提供沉浸式閱讀體驗（可隱藏界面元素）
				- fixed-header: 固定定位樣式類
			-->
			<div class="navbar fixed-header" :class="{hidden:hideControls}">
				<!-- 導航容器 -->
				<div class="nav-container">
					<!-- 
						=== 返回按鈕 ===
						透明樣式的返回按鈕，包含 SVG 圖標
						
						@click="goBackToDetail": 點擊返回詳情頁面
						btn-transparent: 透明背景樣式，適合頂部導航欄
					-->
					<button class="btn-base btn-transparent" @click="goBackToDetail">
						<!-- 
							=== SVG 左箭頭圖標 ===
							使用 SVG 繪製的返回箭頭圖標
							- viewBox="0 0 24 24": 定義 SVG 座標系統
							- stroke="currentColor": 使用當前文字顏色
							- stroke-width="2": 線條粗細
							- path: 定義箭頭路徑（水平線 + 箭頭）
						-->
						<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
							<path d="M19 12H5M12 19l-7-7 7-7"/>
						</svg>
					</button>
					
					<!-- 
						=== 閱讀器標題顯示 ===
						顯示當前章節的標題
						{{currentChapter?.title}}: 安全訪問當前章節標題
						- 使用可選鏈避免 undefined 錯誤
						- 響應式更新：章節切換時自動更新標題
					-->
					<div class="reader-title">{{currentChapter?.title}}</div>
				</div>
			</div>
			
			<!-- 
				=== 閱讀器內容容器 ===
				包含章節內容的主要閱讀區域
			-->
			<div class="reader-container">
				<!-- 
					=== 小說內容顯示區域 ===
					ref="novelContent": Vue.js 模板引用
					- 創建對 DOM 元素的直接引用
					- 允許在 JavaScript 中直接操作此元素
					- 用於滾動位置控制、圖片處理等功能
					
					v-html="parsedContent": 危險的 HTML 插值
					- 將解析後的 Markdown 內容直接插入 DOM
					- parsedContent: 經過 Marked.js 處理的 HTML 字符串
					- 注意：v-html 會覆蓋所有子節點
					- 安全性：確保內容已經過清理
				-->
				<div ref="novelContent" class="novel-content" v-html="parsedContent"></div>
			</div>
			
			<!-- 
				=== 閱讀器控制欄 ===
				固定在底部的操作按鈕欄，包含導航和設置功能
				
				:class="{hidden:hideControls}": 與導航欄同步隱藏
				- 提供一致的沉浸式閱讀體驗
				- fixed-header: 固定定位（實際是底部固定）
			-->
			<div class="reader-controls fixed-header" :class="{hidden:hideControls}">
				<!-- 
					=== 上一話按鈕 ===
					:disabled="!hasPrevious||isLoading": 複合禁用條件
					- !hasPrevious: 沒有上一章時禁用
					- isLoading: 加載中時禁用
					- || 邏輯或：任一條件為真即禁用按鈕
				-->
				<button class="btn-base btn-primary" @click="navigateChapter('prev')" :disabled="!hasPrevious||isLoading">上一話</button>
				
				<!-- 
					=== 目錄按鈕 ===
					toggleModal('showChapterMenu'): 切換章節目錄模態框
					:disabled="isLoading": 加載中時禁用所有操作
				-->
				<button class="btn-base btn-primary" @click="toggleModal('showChapterMenu')" :disabled="isLoading">目錄</button>
				
				<!-- 
					=== 設置按鈕 ===
					toggleModal('showSettings'): 切換閱讀設置模態框
				-->
				<button class="btn-base btn-primary" @click="toggleModal('showSettings')" :disabled="isLoading">設置</button>
				
				<!-- 
					=== 下一話按鈕 ===
					:disabled="!hasNext||isLoading": 與上一話按鈕相似的禁用邏輯
					- !hasNext: 沒有下一章時禁用
					- 確保用戶不會嘗試超出章節範圍的導航
				-->
				<button class="btn-base btn-primary" @click="navigateChapter('next')" :disabled="!hasNext||isLoading">下一話</button>
			</div>
			
			<!-- 
				=== 多功能模態框 ===
				用於顯示設置面板或章節目錄的彈出窗口
				
				:class="{active:showModal}": 動態顯示控制
				- showModal: 模態框顯示狀態的響應式數據
				- active 類觸發顯示動畫和 z-index 層級
			-->
			<div class="modal" :class="{active:showModal}">
				<!-- 
					=== 模態框標題欄 ===
					使用三元運算符根據內容類型顯示不同標題
					{{showSettings?'閱讀設置':'章節目錄'}}
					- showSettings 為 true: 顯示 "閱讀設置"
					- showSettings 為 false: 顯示 "章節目錄"
					- 動態標題提供清晰的上下文信息
				-->
				<div class="modal-header">{{showSettings?'閱讀設置':'章節目錄'}}</div>
				
				<!-- 
					=== 閱讀設置面板 ===
					v-if="showSettings": 條件渲染設置選項
					只有在設置模式下才渲染這些控制項
				-->
				<div class="modal-group" v-if="showSettings">
					<!-- 
						=== 字體大小設置 ===
						雙向數據綁定和事件處理的綜合應用
					-->
					<label>字體大小: {{fontSize}}px</label>
					<!-- 
						字體大小滑動條：
						v-model="fontSize": 雙向數據綁定
						- 自動同步滑動條值和 Vue 數據
						- 實時更新字體大小和標籤顯示
						
						範圍設置：min="14" max="24" step="1"
						- 合理的字體大小範圍（14-24px）
						- 1px 的精確調整步長
						
						事件處理：@mousedown/@mouseup, @touchstart/@touchend
						- 支持桌面和移動設備
						- onSettingsInputStart/End: 防止設置調整時的意外導航
					-->
					<input type="range" v-model="fontSize" min="14" max="24" step="1" @mousedown="onSettingsInputStart" @mouseup="onSettingsInputEnd" @touchstart="onSettingsInputStart" @touchend="onSettingsInputEnd">
					
					<!-- === 行距設置 === -->
					<label>行距: {{lineHeight}}</label>
					<!-- 
						行距滑動條：
						min="1.5" max="2.5" step="0.1"
						- 舒適的行距範圍（1.5-2.5倍）
						- 0.1 的細微調整，提供精確控制
					-->
					<input type="range" v-model="lineHeight" min="1.5" max="2.5" step="0.1" @mousedown="onSettingsInputStart" @mouseup="onSettingsInputEnd" @touchstart="onSettingsInputStart" @touchend="onSettingsInputEnd">
					
					<!-- 
						=== 桌面端專用設置 ===
						desktop-only 類：只在桌面端顯示的設置項
						移動端因螢幕限制不提供寬度調整
					-->
					<div class="desktop-only">
						<label>內容寬度: {{contentWidth}}%</label>
						<!-- 
							內容寬度滑動條：
							min="50" max="100" step="5"
							- 50%-100% 的寬度範圍
							- 5% 的調整步長，提供合理的布局選項
						-->
						<input type="range" v-model="contentWidth" min="50" max="100" step="5" @mousedown="onSettingsInputStart" @mouseup="onSettingsInputEnd" @touchstart="onSettingsInputStart" @touchend="onSettingsInputEnd">
					</div>
					
					<!-- 
						=== 夜間模式切換 ===
						checkbox 類型的雙向綁定
						v-model="isDarkMode": 直接綁定布爾值
						- 勾選狀態與 isDarkMode 數據同步
						- 自動觸發主題切換功能
					-->
					<label><input type="checkbox" v-model="isDarkMode">夜間模式</label>
				</div>
				
				<!-- 
					=== 章節目錄面板 ===
					v-if="showChapterMenu": 條件渲染章節列表
					與設置面板互斥顯示
				-->
				<div class="modal-group" v-if="showChapterMenu">
					<!-- 
						=== 章節列表項目 ===
						v-for="chapter in allChapters": 遍歷所有章節
						
						:class="{current:..., read:...}": 多重條件類別
						- current: 當前章節高亮顯示
						- read: 已讀章節的視覺標記
						- chapter.number===currentChapter?.number: 精確匹配當前章節
						
						@click="goToChapter(chapter.number,true)": 章節跳轉
						- 傳遞 true 參數啟用自動滾動
					-->
					<div v-for="chapter in allChapters" :key="chapter.number" class="chapter-item" :class="{current:chapter.number===currentChapter?.number,read:isChapterRead(chapter.number)}" @click="goToChapter(chapter.number,true)">
						<div>{{chapter.title}}</div>
					</div>
				</div>
			</div>
		</div>
		
		<!-- 
			=== 圖片燈箱覆蓋層 ===
			用於全屏顯示圖片的模態窗口組件
			
			Vue.js 動態類別綁定：
			:class="{active:isLightboxActive}"
			- 對象語法：當 isLightboxActive 為 true 時，添加 'active' 類
			- 響應式更新：當數據變化時，類別會自動更新
			- CSS 控制：active 類觸發顯示動畫和 z-index 層級
			
			事件處理機制：
			@click="isLightboxActive=false"
			- 點擊背景關閉燈箱的用戶體驗設計
			- 事件綁定：監聽 click 事件
			- 狀態更新：將 isLightboxActive 設為 false，觸發關閉動畫
		-->
		<div class="lightbox" :class="{active:isLightboxActive}" @click="isLightboxActive=false">
			<div class="lightbox-content">
				<button class="close-lightbox" @click.stop="isLightboxActive=false">✕</button>
				<img :src="lightboxImage" alt="" @click.stop>
			</div>
		</div>
		<!-- 
			=== 全屏載入動畫覆蓋層 ===
			在數據加載或章節切換時顯示的全屏載入指示器
			:class="{show:isLoading}": 根據 isLoading 狀態動態添加 show 類
		-->
		<div class="loading-overlay" :class="{show:isLoading}">
			<!-- 
				載入動畫容器：
				使用內聯樣式實現文字居中對齊
			-->
			<div style="text-align:center">
				<!-- 
					旋轉載入指示器：
					使用 CSS 動畫實現的圓形旋轉效果
				-->
				<div class="loading-spinner"></div>
				
				<!-- 
					載入文字提示：
					- color:white: 白色文字確保在深色覆蓋層上可見
					- margin-top:var(--sp): 與旋轉動畫保持標準間距
					- font-size:1.1rem: 略大於正常文字，增加可見性
				-->
				<div style="color:white;margin-top:var(--sp);font-size:1.1rem">載入中...</div>
			</div>
		</div>
	</div>
	
	<!-- 
		===============================================
		=== JavaScript 程式邏輯開始 ===
		===============================================
		
		<script> 標籤包含所有的 JavaScript 代碼
		這裡實現了 Vue.js 應用程式的完整邏輯
	-->
	<script>
		/* 
			===============================================
			=== Vue.js 應用程式初始化 ===
			===============================================
		*/
		
		/* 
			=== ES6 解構賦值 ===
			從 Vue 全局對象中提取 createApp 函數
			等同於：const createApp = Vue.createApp
			
			createApp 是 Vue 3 中創建應用程式實例的函數
			Vue 3 使用 createApp() 替代了 Vue 2 的 new Vue()
			這提供了更好的 TypeScript 支持和多應用程式實例能力
		*/
		const {createApp}=Vue;
		
		/* 
			===============================================
			=== 常量定義 - 本地存儲鍵值 ===
			===============================================
			
			使用常量對象統一管理 localStorage 的鍵名
			這種做法的優勢：
			1. 避免硬編碼字符串散落在代碼各處
			2. 防止鍵名拼寫錯誤
			3. 便於統一修改和維護
			4. 提供代碼補全和類型檢查
		*/
		const STORAGE_KEYS={
			/* 主題設置：亮色/暗色模式 */
			THEME:'theme',
			
			/* 排序方式：最新更新/章節數/文字數 */
			SORT:'content_sort',
			
			/* 閱讀器字體大小設置 */
			FONT_SIZE:'font_size',
			
			/* 閱讀器行高設置 */
			LINE_HEIGHT:'line_height',
			
			/* 閱讀器內容寬度設置 */
			CONTENT_WIDTH:'content_width',
			
			/* 已讀章節記錄 */
			READ_CHAPTERS:'read_chapters',
			
			/* 當前閱讀的小說 */
			CURRENT_NOVEL:'currentNovel'
		};
		
		/* 
			===============================================
			=== 本地存儲工具類 ===
			===============================================
			
			StorageUtil 是一個封裝 localStorage 操作的工具對象
			提供了類型安全和錯誤處理的存儲方法
		*/
		const StorageUtil={
			/* 
				=== 讀取存儲數據方法 ===
				從 localStorage 讀取並解析 JSON 數據
				
				參數：
				- key: 存儲鍵名
				- defaultValue: 默認值（當鍵不存在或解析失敗時返回）
			*/
			get(key,defaultValue=null){
				try{
					return JSON.parse(localStorage.getItem(key))||defaultValue;
				}catch{
					return defaultValue;
				}
			},
			
			/* 
				=== 設置存儲數據方法 ===
				將數據序列化為 JSON 並存儲到 localStorage
				
				參數：
				- key: 存儲鍵名（字符串）
				- value: 要存儲的數據（任何可序列化的 JavaScript 值）
				
				錯誤處理：
				- 使用 try-catch 處理存儲配額超出等異常
				- 靜默失敗，不會拋出錯誤到用戶界面
				
				應用場景：
				- 存儲複雜的對象數據（如設置、狀態）
				- 數據會自動進行 JSON 序列化
			*/
			set(key,value){
				try{
					localStorage.setItem(key,JSON.stringify(value));
				}catch{}
			},
			
			/* 
				=== 讀取字符串數據方法 ===
				直接從 localStorage 讀取字符串數據，無需 JSON 解析
				
				參數：
				- key: 存儲鍵名
				- defaultValue: 默認值（當鍵不存在時返回，默認為空字符串）
				
				返回值：字符串類型
				
				適用場景：
				- 存儲簡單的字符串值（如主題名稱、用戶設置）
				- 避免不必要的 JSON 解析開銷
				- 適合存儲不需要復雜數據結構的配置項
			*/
			getString(key,defaultValue=''){
				return localStorage.getItem(key)||defaultValue;
			},
			
			/* 
				=== 設置字符串數據方法 ===
				直接將字符串值存儲到 localStorage，無需 JSON 序列化
				
				參數：
				- key: 存儲鍵名
				- value: 要存儲的字符串值
				
				性能優勢：
				- 無 JSON 序列化開銷，性能更優
				- 適合頻繁更新的字符串數據
				
				使用注意：
				- 僅適用於字符串類型數據
				- 如需存儲對象，請使用 set() 方法
			*/
			setString(key,value){
				localStorage.setItem(key,value);
			}
		};
		
		/* 
			===============================================
			=== Vue.js 應用程式實例創建 ===
			===============================================
			
			createApp() 創建一個新的 Vue 應用程式實例
			接受一個配置對象，包含 data、methods、computed 等選項
		*/
		createApp({
			/* 
				===============================================
				=== 響應式數據定義 (data) ===
				===============================================
				
				data() 函數返回應用程式的響應式數據
				Vue.js 會將返回的對象中的所有屬性轉換為響應式屬性
				當這些數據改變時，相關的 DOM 會自動更新
				
				這就是 Vue.js 的核心特性：數據驅動的響應式更新
			*/
			data(){
				return{
					/* 
						=== 頁面狀態管理 ===
						currentPage 控制當前顯示的頁面
					*/
					
					/* 
						當前頁面：'list'（列表頁）、'detail'（詳情頁）、'reader'（閱讀器）
						默認為 'list'，即小說列表頁面
					*/
					currentPage:'list',
					
					/* 
						=== 小說數據管理 ===
						管理小說列表和當前選中的小說信息
					*/
					
					/* 小說列表：存儲從 novels.json 載入的所有小說數據 */
					novelList:[],
					
					/* 當前選中的小說：用戶點擊查看的小說信息 */
					selectedNovel:null,
					
					/* 選中小說的原始數據：包含章節列表等詳細信息 */
					selectedNovelData:null,
					
					/* 當前小說的所有章節：經過處理的章節列表 */
					allChapters:[],
					
					/* 當前正在閱讀的章節：包含章節號、標題等信息 */
					currentChapter:null,
					
					/* 當前章節的內容：Markdown 格式的文本 */
					chapterContent:'',
					
					/* 
						=== 用戶設置管理 ===
						這些設置會保存到 localStorage，下次訪問時恢復
					*/
					
					/* 
						暗色模式開關：
						從 localStorage 讀取，如果是 'dark' 則為 true
						使用邏輯運算符 === 進行嚴格比較
					*/
					isDarkMode:StorageUtil.getString(STORAGE_KEYS.THEME)==='dark',
					
					/* 
						字體大小設置：
						parseInt() 將字符串轉換為整數
						|| 18 提供默認值（如果存儲中沒有值或轉換失敗）
					*/
					fontSize:parseInt(StorageUtil.getString(STORAGE_KEYS.FONT_SIZE))||18,
					
					/* 
						行高設置：
						parseFloat() 將字符串轉換為浮點數
						|| 1.8 提供默認的行高值
					*/
					lineHeight:parseFloat(StorageUtil.getString(STORAGE_KEYS.LINE_HEIGHT))||1.8,
					
					/* 內容寬度設置：閱讀器內容區域的寬度百分比 */
					contentWidth:parseInt(StorageUtil.getString(STORAGE_KEYS.CONTENT_WIDTH))||80,
					
					/* 
						=== 排序和篩選狀態 ===
					*/
					
					/* 當前排序方式：默認為按最新更新時間排序 */
					currentSort:StorageUtil.getString(STORAGE_KEYS.SORT)||'lastUpdated',
					
					/* 
						排序選項配置：
						這是一個對象數組，每個對象包含：
						- value: 內部使用的值
						- label: 用戶看到的顯示文本
					*/
					sortOptions:[
						{value:'lastUpdated',label:'最新更新'},
						{value:'chapterCount',label:'章節數'},
						{value:'wordCount',label:'文字數'}
					],
					
					/* 
						=== UI 狀態管理 ===
						控制各種界面元素的顯示/隱藏狀態
					*/
					
					/* 當前激活的下拉菜單：null 表示沒有下拉菜單展開 */
					activeDropdown:null,
					
					/* 載入狀態：true 時顯示載入動畫 */
					isLoading:false,
					
					/* 控制元件隱藏狀態：在閱讀器中滾動時隱藏導航欄和控制按鈕 */
					hideControls:false,
					
					/* 設置模態框顯示狀態 */
					showSettings:false,
					
					/* 章節選擇模態框顯示狀態 */
					showChapterMenu:false,
					
					/* 
						=== 燈箱（圖片全屏顯示）活動狀態 ===
						控制燈箱模態框的顯示和隱藏
						- false：燈箱隱藏（預設狀態）
						- true：燈箱顯示，全屏顯示圖片
						- 響應式數據：變化時會自動觸發 CSS 類別更新
					*/
					isLightboxActive:false,
					
					/* 
						=== 燈箱顯示的圖片 URL ===
						存儲當前在燈箱中顯示的圖片來源地址
						- null：預設值，表示沒有圖片被選中
						- string：圖片的完整 URL 路徑
						- 用途：當用戶點擊圖片時，存儲該圖片 URL 並在燈箱中顯示
						- 數據流：點擊圖片 → 設置 lightboxImage → 開啟 isLightboxActive
					*/
					lightboxImage:null,
				}
			},
			/* 
				=== Vue.js Computed 計算屬性 ===
				計算屬性是 Vue.js 的核心特性之一，具有以下特點：
				1. 基於響應式依賴進行緩存：只有當依賴的數據發生變化時才會重新計算
				2. 具有 getter 和 setter：可讀取和設置值
				3. 自動追蹤依賴：Vue 會自動判斷計算屬性依賴哪些響應式數據
				4. 性能優化：避免重複計算，比 methods 中的函數更高效
				5. 聲明式：描述結果是什麼，而不是如何計算
			*/
			computed:{
				/* 
					=== 小說唯一標識符計算 ===
					用途：生成小說的唯一標識符，用於localStorage存儲等場景
					原理：從小說標題中移除書名號《》
				*/
				novelKey(){
					/* 
						使用可選鏈操作符 (?.) 安全訪問屬性：
						- this.selectedNovel?.title：如果 selectedNovel 為 null/undefined，返回 undefined
						- ?.replace()：如果 title 存在才執行 replace 方法
						- replace(/[《》]/g,'')：使用正則表達式全局替換書名號為空字符串
						- ||''：如果前面的結果為 falsy 值，返回空字符串作為默認值
					*/
					return this.selectedNovel?.title?.replace(/[《》]/g,'')||'';
				},
				
				/* 
					=== 模態框顯示狀態計算 ===
					用途：統一管理多個模態框的顯示狀態
					原理：只要有任一模態框需要顯示，就返回 true
				*/
				showModal(){
					/* 
						邏輯或操作符 (||)：
						- 如果 showSettings 為 true，直接返回 true
						- 否則檢查 showChapterMenu 的值
						- 這樣可以簡潔地處理多個模態框的顯示邏輯
					*/
					return this.showSettings||this.showChapterMenu;
				},
				
				/* 
					=== 當前排序選項標籤計算 ===
					用途：根據當前排序值找到對應的顯示標籤
					原理：在排序選項數組中查找匹配的選項
				*/
				currentSortLabel(){
					/* 
						Array.find() 方法：
						- 在 sortOptions 數組中查找第一個符合條件的元素
						- opt => opt.value === this.currentSort：箭頭函數作為查找條件
						- ?.label：可選鏈操作符獲取找到元素的 label 屬性
						- ||'排序'：如果沒找到匹配項，返回默認文字 '排序'
					*/
					return this.sortOptions.find(opt=>opt.value===this.currentSort)?.label||'排序';
				},
				
				/* 
					=== 排序後的小說列表計算 ===
					用途：根據用戶選擇的排序方式對小說列表進行排序
					原理：使用展開運算符創建副本，然後根據排序條件進行排序
				*/
				sortedNovelList(){
					/* 
						展開運算符 (...) 創建數組副本：
						- [...this.novelList]：創建 novelList 的淺拷貝
						- 避免直接修改原數組，保持數據的不可變性
						- 這是函數式編程的最佳實踐
					*/
					return[...this.novelList].sort((a,b)=>{
						/* 
							Array.sort() 方法：
							- 接受比較函數 (a, b) => number
							- 返回值 < 0：a 排在 b 前面
							- 返回值 > 0：a 排在 b 後面  
							- 返回值 = 0：a 和 b 位置不變
						*/
						switch(this.currentSort){
							/* 按最後更新時間排序（降序：最新的在前） */
							case'lastUpdated':
								/* 
									Date 對象減法：
									- new Date() 將字符串轉換為日期對象
									- 兩個日期對象相減得到毫秒差值
									- b - a 實現降序排列（新日期 - 舊日期 > 0）
								*/
								return new Date(b.lastUpdated)-new Date(a.lastUpdated);
							
							/* 按章節數量排序（降序：章節多的在前） */
							case'chapterCount':
								/* 
									可選鏈與默認值：
									- (b.chapters||[])：如果 chapters 不存在，使用空數組
									- .length：獲取數組長度
									- 相減得到數量差值實現排序
								*/
								return(b.chapters||[]).length-(a.chapters||[]).length;
							
							/* 按總字數排序（降序：字數多的在前） */
							case'wordCount':
								/* 
									邏輯或默認值：
									- (b.totalWordCount||0)：如果字數不存在，默認為 0
									- 避免 undefined 參與數學運算
								*/
								return(b.totalWordCount||0)-(a.totalWordCount||0);
							
							/* 默認情況：不改變順序 */
							default:
								return 0;
						}
					});
				},
				
				/* 
					=== 帶日期的章節列表計算 ===
					用途：對所有章節按編號降序排列，最新章節在前
					原理：創建副本後按章節編號進行排序
				*/
				chaptersWithDates(){
					/* 
						降序排序：
						- [...this.allChapters]：創建章節數組副本
						- (a,b) => b.number - a.number：按 number 屬性降序排列
						- 數字越大的章節排在前面
					*/
					return [...this.allChapters].sort((a,b)=>b.number-a.number);
				},
				
				/* 
					=== 解析後的小說描述計算 ===
					用途：將 Markdown 格式的描述轉換為 HTML
					原理：使用 marked 庫解析 Markdown 語法
				*/
				parsedDescription(){
					/* 
						條件運算符與 Markdown 解析：
						- this.selectedNovel?.description：安全獲取描述文字
						- marked.parse()：marked.js 庫的解析方法，將 Markdown 轉換為 HTML
						- 三元運算符：有描述就解析，沒有返回空字符串
					*/
					return this.selectedNovel?.description?marked.parse(this.selectedNovel.description):'';
				},
				
				/* 
					=== 解析後的章節內容計算 ===
					用途：將 Markdown 格式的章節內容轉換為 HTML 用於顯示
					原理：同樣使用 marked 庫進行解析
				*/
				parsedContent(){
					/* 
						章節內容 Markdown 解析：
						- this.chapterContent：當前章節的原始內容
						- marked.parse()：轉換為帶格式的 HTML
						- 支持標題、粗體、斜體、列表等 Markdown 語法
					*/
					return this.chapterContent?marked.parse(this.chapterContent):'';
				},
				
				/* 
					=== 是否有下一章計算 ===
					用途：判斷當前章節後是否還有更多章節
					原理：檢查是否存在編號更大的章節
				*/
				hasNext(){
					/* 
						Array.some() 方法：
						- 檢查數組中是否至少有一個元素滿足條件
						- chapter => chapter.number > this.currentChapter?.number
						- 只要有一個章節編號大於當前章節，就返回 true
						- 用於控制「下一章」按鈕的顯示和啟用狀態
					*/
					return this.allChapters.some(chapter=>chapter.number>this.currentChapter?.number);
				},
				
				/* 
					=== 是否有上一章計算 ===
					用途：判斷當前章節前是否還有章節
					原理：檢查是否存在編號更小的章節
				*/
				hasPrevious(){
					/* 
						同 hasNext 的邏輯：
						- 檢查是否有章節編號小於當前章節
						- 用於控制「上一章」按鈕的顯示和啟用狀態
						- 提供完整的章節導航功能
					*/
					return this.allChapters.some(chapter=>chapter.number<this.currentChapter?.number);
				}
			},
			/* 
				=== Vue.js Watch 監聽器 ===
				監聽器(watchers)是 Vue.js 用於響應數據變化的機制：
				1. 深度監聽：可以監聽嵌套對象和數組的變化
				2. 立即執行：可以在組件創建時立即執行一次
				3. 副作用處理：適合執行異步操作、外部API調用、DOM操作等
				4. 細粒度控制：相比computed更適合需要執行複雜邏輯的場景
				5. 清理機制：可以返回清理函數，在組件銷毀時執行清理操作
			*/
			watch:{
				/* 
					=== 深色模式變化監聽 ===
					當用戶切換深色/淺色模式時執行相應操作
					用途：同步更新DOM主題屬性和本地存儲
				*/
				isDarkMode(newValue){
					/* 
						三元運算符決定主題名稱：
						- newValue 為 true：使用 'dark' 主題
						- newValue 為 false：使用 'light' 主題
					*/
					const theme=newValue?'dark':'light';
					
					/* 
						設置 HTML 根元素的 data-theme 屬性：
						- document.documentElement 指向 <html> 元素
						- setAttribute() 設置自定義屬性
						- CSS 可以通過 [data-theme="dark"] 選擇器應用對應樣式
					*/
					document.documentElement.setAttribute('data-theme',theme);
					
					/* 
						持久化主題設置到本地存儲：
						- StorageUtil.setString() 自定義存儲工具函數
						- STORAGE_KEYS.THEME 預定義的存儲鍵名
						- 確保用戶下次訪問時保持相同主題
					*/
					StorageUtil.setString(STORAGE_KEYS.THEME,theme);
				},
				
				/* 
					=== 字體大小變化監聽 ===
					當用戶調整字體大小滑桿時自動更新樣式和存儲
					用途：實時響應字體大小設置的變化
				*/
				fontSize(newValue){
					/* 
						調用統一的設置更新方法：
						- '--fs'：CSS 自定義屬性名稱
						- `${newValue}px`：模板字符串，將數值轉換為像素單位
						- STORAGE_KEYS.FONT_SIZE：本地存儲鍵名
						- newValue：存儲的原始數值
					*/
					this.updateSetting('--fs',`${newValue}px`,STORAGE_KEYS.FONT_SIZE,newValue);
				},
				
				/* 
					=== 行高變化監聽 ===
					監聽行高設置的變化，更新CSS變量和本地存儲
					用途：實時調整文本的行間距
				*/
				lineHeight(newValue){
					/* 
						行高設置更新：
						- '--lh'：行高CSS變量名
						- newValue：行高倍數值（如 1.5, 1.8 等）
						- 無需單位，CSS中行高可以是無單位數值
					*/
					this.updateSetting('--lh',newValue,STORAGE_KEYS.LINE_HEIGHT,newValue);
				},
				
				/* 
					=== 內容寬度變化監聽 ===
					監聽閱讀器內容寬度設置的變化
					用途：調整閱讀區域的寬度比例
				*/
				contentWidth(newValue){
					/* 
						內容寬度設置更新：
						- '--content-width'：內容寬度CSS變量名
						- `${newValue}%`：將數值轉換為百分比單位
						- 控制閱讀器內容區域相對於視窗的寬度
					*/
					this.updateSetting('--content-width',`${newValue}%`,STORAGE_KEYS.CONTENT_WIDTH,newValue);
				},
				
				/* 
					=== 當前頁面變化監聽 ===
					監聽頁面路由變化，設置或清理頁面特定的事件監聽器
					用途：管理不同頁面的交互行為
				*/
				currentPage(newValue){
					/* 檢查是否切換到閱讀器頁面 */
					if(newValue==='reader'){
						/* 
							使用 $nextTick 確保DOM更新完成：
							- Vue的響應式更新是異步的
							- $nextTick 保證在下一個DOM更新周期執行
							- 確保閱讀器相關元素已經渲染完成
						*/
						this.$nextTick(()=>{
							/* 
								添加滾動事件監聽器：
								- window.addEventListener() 在全局視窗上監聽滾動
								- 'scroll'：滾動事件類型
								- this.handleScroll：處理滾動的方法
								- 用於實現滾動時隱藏/顯示控制欄的功能
							*/
							window.addEventListener('scroll',this.handleScroll);
							
							/* 
								設置圖片查看器：
								- this.setupImageViewer()：初始化圖片點擊放大功能
								- 為文章中的圖片添加點擊事件監聽器
								- 實現燈箱效果
							*/
							this.setupImageViewer();
						});
					}else{
						/* 
							離開閱讀器頁面時的清理操作：
							- removeEventListener() 移除滾動監聽器
							- 防止內存洩漏和不必要的事件處理
						*/
						window.removeEventListener('scroll',this.handleScroll);
						
						/* 
							重置控制欄顯示狀態：
							- hideControls = false：確保控制欄在其他頁面正常顯示
							- 避免在非閱讀器頁面出現異常的UI狀態
						*/
						this.hideControls=false;
					}
				}
			},
			/* 
				=== Vue.js Methods 方法定義 ===
				Methods 是 Vue.js 組件中定義自定義方法的區域：
				1. 事件處理：處理用戶交互事件（點擊、輸入、鍵盤等）
				2. 業務邏輯：實現應用的核心功能邏輯
				3. 數據操作：修改組件狀態、調用API、處理數據
				4. DOM操作：直接操作DOM元素（謹慎使用）
				5. 生命週期相關：配合生命週期鉤子執行特定操作
			*/
			methods:{
				/* 
					=== 統一設置更新方法 ===
					用途：統一處理用戶設置的更新，包括CSS變量和本地存儲
					參數：cssVar(CSS變量名), cssValue(CSS值), storageKey(存儲鍵), storageValue(存儲值)
				*/
				updateSetting(cssVar,cssValue,storageKey,storageValue){
					/* 
						設置調整狀態標誌：
						- this._adjustingSettings = true：標記正在調整設置
						- 防止在調整過程中觸發其他副作用（如滾動監聽）
						- 避免設置更新過程中的意外行為
					*/
					this._adjustingSettings=true;
					
					/* 
						更新CSS自定義屬性：
						- document.documentElement：獲取根元素（<html>）
						- style.setProperty()：設置CSS自定義屬性
						- cssVar：CSS變量名稱（如 '--fs', '--lh'）
						- cssValue：對應的CSS值（如 '16px', '1.5'）
					*/
					document.documentElement.style.setProperty(cssVar,cssValue);
					
					/* 
						保存設置到本地存儲：
						- StorageUtil.setString()：自定義存儲工具方法
						- storageKey：存儲鍵名（來自 STORAGE_KEYS 常量）
						- storageValue：要存儲的值
					*/
					StorageUtil.setString(storageKey,storageValue);
					
					/* 
						防抖機制：
						- clearTimeout()：清除之前的計時器
						- setTimeout()：設置新的延遲執行
						- 500ms 後重置 _adjustingSettings 標誌
						- 避免用戶連續調整時頻繁觸發副作用
					*/
					clearTimeout(this._adjustingTimer);
					this._adjustingTimer=setTimeout(()=>this._adjustingSettings=false,500);
				},
				/* 
					=== 異步獲取小說列表方法 ===
					用途：從服務器獲取小說數據並格式化為應用可用的格式
					異步操作：使用 async/await 處理網絡請求
				*/
				async fetchNovelList(){
					/* 
						try-catch 錯誤處理：
						- 網絡請求可能失敗，需要妥善處理異常
						- 確保應用在數據獲取失敗時不會崩潰
					*/
					try{
						/* 
							Fetch API 發起網絡請求：
							- await fetch()：等待網絡請求完成
							- 'novels.json'：相對路徑指向小說數據文件
							- response 對象包含響應狀態和數據
						*/
						const response=await fetch('輕小說翻譯/novels.json');
						
						/* 
							解析 JSON 數據：
							- await response.json()：等待JSON解析完成
							- 將響應體轉換為JavaScript對象
						*/
						const data=await response.json();
						
						/* 
							數據格式化和映射：
							- data.novels.map()：遍歷每個小說項目
							- 將原始數據轉換為應用內部使用的標準格式
						*/
						this.novelList=data.novels.map(novel=>{
							/* 
								標題格式化：
								- match(/^《.*》$/)：檢查是否已有書名號
								- 正則表達式匹配完整的書名號格式
								- 如果沒有書名號，自動添加
							*/
							const titleWithBrackets=novel.title.match(/^《.*》$/)?novel.title:`《${novel.title}》`;
							
							/* 
								返回標準化的小說對象：
								- 統一數據格式，確保每個屬性都有默認值
								- 便於後續處理和顯示
							*/
							return{
								/* 格式化後的標題（含書名號） */
								title:titleWithBrackets,
								
								/* 
									封面圖片URL：
									- encodeURIComponent()：編碼標題中的特殊字符
									- 確保URL路徑的正確性
								*/
								coverUrl:`輕小說翻譯/${encodeURIComponent(titleWithBrackets)}/cover.jpg`,
								
								/* 最後更新時間（默認為當前時間） */
								lastUpdated:novel.lastUpdated||new Date().toISOString(),
								
								/* 作者名稱（默認為'未知作者'） */
								author:novel.author||'未知作者',
								
								/* 章節列表（默認為空數組） */
								chapters:novel.chapters||[],
								
								/* 總字數（默認為0） */
								totalWordCount:novel.totalWordCount||0,
								
								/* 保留原始數據供後續使用 */
								originalData:novel
							};
						});
					}catch(error){
						/* 
							錯誤處理：
							- console.error()：在控制台輸出錯誤信息
							- 便於開發時調試和問題排查
						*/
						console.error('讀取小說列表失敗:',error);
					}
				},
				/* 
					=== URL更新方法 ===
					用途：更新瀏覽器地址欄和頁面標題，實現SPA路由功能
					參數：page(頁面類型), params(URL參數對象)
				*/
				updateUrl(page,params={}){
					/* 
						創建URL搜索參數對象：
						- URLSearchParams：現代瀏覽器提供的URL參數處理API
						- 自動處理參數編碼和格式化
						- 比手動字符串拼接更安全可靠
					*/
					const searchParams=new URLSearchParams();
					
					/* 
						根據頁面類型設置不同的URL參數：
						- 詳情頁：只需要小說標題參數
						- 閱讀器頁：需要小說標題和章節編號
					*/
					if(page==='detail'&&params.title){
						/* 
							設置小說標題參數：
							- 'title'：參數名稱
							- params.title：小說標題值
						*/
						searchParams.set('title',params.title);
					}else if(page==='reader'&&params.title&&params.chapter){
						/* 閱讀器頁面需要兩個參數 */
						searchParams.set('title',params.title);
						
						/* 
							章節編號轉字符串：
							- .toString()：確保數字轉換為字符串
							- URL參數都是字符串類型
						*/
						searchParams.set('chapter',params.chapter.toString());
					}
					
					/* 
						生成查詢字符串：
						- searchParams.toString()：自動格式化為 ?key1=value1&key2=value2
						- 處理特殊字符的URL編碼
					*/
					const queryString=searchParams.toString();
					
					/* 
						構建完整URL：
						- window.location.pathname：當前頁面路徑（不含參數）
						- 三元運算符：有參數就添加?前綴，沒有就保持原路徑
						- 保持基礎路徑不變，只更新查詢參數
					*/
					const newUrl=queryString?`${window.location.pathname}?${queryString}`:window.location.pathname;
					
					/* 
						更新瀏覽器歷史記錄：
						- window.history.pushState()：添加新的歷史條目
						- {page,params}：保存狀態對象，用於前進/後退時恢復
						- ''：標題參數（已棄用，傳空字符串）
						- newUrl：新的URL地址
						
						這樣做的好處：
						- 用戶可以使用瀏覽器前進/後退按鈕
						- URL可以被收藏和分享
						- 刷新頁面後能恢復到正確狀態
					*/
					window.history.pushState({page,params},'',newUrl);
					
					/* 
						更新頁面標題：
						- 提供有意義的標題便於識別和SEO
						- 顯示在瀏覽器標籤和收藏夾中
					*/
					let title='輕小說翻譯';
					
					/* 詳情頁標題格式：《小說名》 - 輕小說翻譯 */
					if(page==='detail'&&params.title){
						title=`${params.title} - 輕小說翻譯`;
					}
					/* 閱讀器頁標題格式：章節名 - 《小說名》 - 輕小說翻譯 */
					else if(page==='reader'&&params.title&&this.currentChapter){
						title=`${this.currentChapter.title} - ${params.title} - 輕小說翻譯`;
					}
					
					/* 
						設置文檔標題：
						- document.title：更新瀏覽器標籤顯示的標題
						- 提供清晰的頁面標識
					*/
					document.title=title;
				},
				/* 
					=== URL參數處理方法 ===
					用途：解析URL參數並設置對應的應用狀態
					處理場景：頁面刷新、直接訪問、瀏覽器前進後退
					異步方法：需要等待數據加載完成
				*/
				async handleUrlParams(){
					/* 
						解析當前URL的查詢參數：
						- window.location.search：獲取 ?key=value&key2=value2 部分
						- URLSearchParams：解析查詢字符串為鍵值對
						- 自動處理URL解碼
					*/
					const urlParams=new URLSearchParams(window.location.search);
					
					/* 
						提取關鍵參數：
						- get('title')：獲取小說標題參數
						- get('chapter')：獲取章節編號參數
						- 如果參數不存在，返回 null
					*/
					const titleParam=urlParams.get('title');
					const chapterParam=urlParams.get('chapter');
					
					/* 
						無標題參數的處理：
						- 沒有 title 參數表示用戶訪問首頁
						- 設置為列表頁面並提前返回
						- 避免後續不必要的處理
					*/
					if(!titleParam){
						this.currentPage='list';
						return;
					}
					
					/* 
						確保小說數據已加載：
						- 檢查 novelList 是否為空
						- 如果為空，先異步加載小說列表
						- await 確保數據加載完成再繼續
					*/
					if(this.novelList.length===0){
						await this.fetchNovelList();
					}
					
					/* 
						查找對應的小說：
						- find()：在小說列表中搜索匹配的標題
						- n => n.title === titleParam：比較函數
						- 返回第一個匹配的小說對象，沒找到返回 undefined
					*/
					const novel=this.novelList.find(n=>n.title===titleParam);
					
					/* 
						小說不存在的錯誤處理：
						- 可能是URL參數錯誤或小說已被刪除
						- 重定向到首頁避免出現空白頁面
						- 提供良好的用戶體驗
					*/
					if(!novel){
						this.goToHome();
						return;
					}
					
					/* 
						設置當前小說：
						- 更新應用狀態為選中的小說
						- 加載小說的詳細信息和章節列表
						- 保存到本地存儲以便下次訪問
					*/
					this.setCurrentNovel(novel);
					
					/* 處理章節參數 */
					if(chapterParam){
						/* 
							章節編號解析：
							- parseFloat()：將字符串轉換為數字
							- 支持小數章節編號（如 1.5, 2.1 等）
							- 比 parseInt() 更靈活
						*/
						const chapterNumber=parseFloat(chapterParam);
						
						/* 
							查找對應章節：
							- findChapter()：在當前小說的章節列表中搜索
							- 根據章節編號匹配
						*/
						this.currentChapter=this.findChapter(chapterNumber);
						
						/* 章節存在：進入閱讀器模式 */
						if(this.currentChapter){
							/* 設置頁面為閱讀器 */
							this.currentPage='reader';
							
							/* 
								加載章節內容：
								- await 等待內容加載完成
								- 確保用戶看到完整內容而不是加載狀態
							*/
							await this.loadChapterContent();
						}else{
							/* 
								章節不存在的降級處理：
								- 章節可能已被刪除或編號錯誤
								- 回到小說詳情頁
								- 更新URL移除錯誤的章節參數
							*/
							this.currentPage='detail';
							this.updateUrl('detail',{title:titleParam});
						}
					}else{
						/* 
							只有小說標題沒有章節參數：
							- 顯示小說詳情頁
							- 用戶可以選擇要閱讀的章節
						*/
						this.currentPage='detail';
					}
				},
				/* 
					=== 返回首頁導航方法 ===
					用途：清理當前狀態並返回小說列表頁
					場景：點擊首頁按鈕、錯誤處理時的重定向
				*/
				goToHome(){
					/* 設置頁面為列表模式 */
					this.currentPage='list';
					
					/* 
						清理當前選中狀態：
						- selectedNovel = null：清除選中的小說
						- currentChapter = null：清除當前章節
						- 確保返回首頁時狀態完全重置
					*/
					this.selectedNovel=null;
					this.currentChapter=null;
					
					/* 
						更新URL為首頁：
						- 移除所有查詢參數
						- 確保URL反映當前狀態
					*/
					this.updateUrl('list');
					
					/* 
						滾動到頁面頂部：
						- window.scrollTo(0,0)：回到最頂部
						- 提供一致的導航體驗
						- 避免用戶停留在頁面中間位置
					*/
					window.scrollTo(0,0);
				},
				
				/* 
					=== 設置當前小說方法 ===
					用途：將選中的小說設為當前活躍小說
					參數：novel - 小說對象
					功能：更新狀態、設置詳情、保存到本地存儲
				*/
				setCurrentNovel(novel){
					/* 設置當前選中的小說 */
					this.selectedNovel=novel;
					
					/* 
						保存原始數據：
						- originalData：包含完整的小說信息
						- 用於後續的詳細信息處理
					*/
					this.selectedNovelData=novel.originalData;
					
					/* 
						設置小說詳情：
						- 解析章節列表、來源鏈接等
						- 準備詳情頁所需的所有數據
					*/
					this.setupNovelDetail();
					
					/* 
						保存到本地存儲：
						- 記住用戶最後選擇的小說
						- 下次訪問時可以快速恢復
						- STORAGE_KEYS.CURRENT_NOVEL：預定義的存儲鍵
					*/
					StorageUtil.setString(STORAGE_KEYS.CURRENT_NOVEL,novel.title);
				},
				
				/* 
					=== 進入小說詳情頁方法 ===
					用途：從列表頁點擊小說卡片時的導航
					參數：novel - 要查看的小說對象
				*/
				goToDetail(novel){
					/* 
						設置當前小說：
						- 調用 setCurrentNovel 完成狀態設置
						- 包括數據準備和本地存儲
					*/
					this.setCurrentNovel(novel);
					
					/* 切換到詳情頁面 */
					this.currentPage='detail';
					
					/* 
						更新URL：
						- 添加 title 參數
						- 使URL可以被收藏和分享
					*/
					this.updateUrl('detail',{title:novel.title});
					
					/* 滾動到頁面頂部 */
					window.scrollTo(0,0);
				},
				
				/* 
					=== 章節導航方法 ===
					用途：跳轉到指定章節
					參數：chapterNumber(章節編號), fromReader(是否來自閱讀器)
					支持：詳情頁選擇章節、閱讀器內切換章節
				*/
				goToChapter(chapterNumber,fromReader=false){
					/* 
						閱讀器內重複點擊處理：
						- 如果用戶在閱讀器中點擊當前章節
						- 只關閉章節選擇模態框，不重新加載
						- 避免不必要的網絡請求和頁面重置
					*/
					if(fromReader&&chapterNumber===this.currentChapter?.number){
						this.closeAllModals();
						return;
					}
					
					/* 
						保存閱讀位置：
						- 如果來自閱讀器，保存當前滾動位置
						- 確保用戶可以回到之前的閱讀位置
					*/
					if(fromReader)this.saveScrollPosition();
					
					/* 
						設置目標章節：
						- findChapter()：根據編號查找章節對象
						- 更新 currentChapter 狀態
					*/
					this.currentChapter=this.findChapter(chapterNumber);
					
					/* 
						加載章節內容：
						- 異步加載章節文件內容
						- 更新閱讀器顯示
					*/
					this.loadChapterContent();
					
					/* 
						頁面模式設置：
						- 如果不是來自閱讀器（即來自詳情頁），設置為閱讀器模式
						- 如果來自閱讀器，保持當前模式
					*/
					if(!fromReader){
						this.currentPage='reader';
					}
					
					/* 關閉所有模態框（如章節選擇菜單） */
					this.closeAllModals();
					
					/* 
						更新URL：
						- 添加章節參數
						- 支持直接訪問特定章節
					*/
					this.updateUrl('reader',{title:this.selectedNovel.title,chapter:chapterNumber});
				},
				
				/* 
					=== 返回詳情頁方法 ===
					用途：從閱讀器返回到小說詳情頁
					場景：點擊返回按鈕
				*/
				goBackToDetail(){
					/* 保存當前閱讀位置 */
					this.saveScrollPosition();
					
					/* 切換到詳情頁面 */
					this.currentPage='detail';
					
					/* 
						重置控制欄狀態：
						- hideControls = false：確保在詳情頁顯示導航欄
						- 避免從閱讀器帶來的隱藏狀態
					*/
					this.hideControls=false;
					
					/* 關閉所有模態框 */
					this.closeAllModals();
					
					/* 更新URL移除章節參數 */
					this.updateUrl('detail',{title:this.selectedNovel.title});
					
					/* 滾動到頁面頂部 */
					window.scrollTo(0,0);
				},
				/* 
					=== 小說詳情設置方法 ===
					用途：處理和格式化小說的詳細信息
					功能：解析來源鏈接、標籤、章節列表等
				*/
				setupNovelDetail(){
					/* 
						前置條件檢查：
						- 確保有選中的小說數據
						- 避免在無數據時出錯
					*/
					if(!this.selectedNovelData)return;
					
					/* 
						初始化來源鏈接對象：
						用於存儲不同來源網站的鏈接
					*/
					const sourceLinks={};
					
					/* 處理原始URL鏈接 */
					if(this.selectedNovelData.originalUrl){
						/* 
							分割多個URL：
							- split('、')：以中文頓號分割
							- 支持一個小說有多個來源鏈接
						*/
						const urls=this.selectedNovelData.originalUrl.split('、');
						
						/* 
							分類處理每個URL：
							根據域名判斷來源網站類型
						*/
						urls.forEach(url=>{
							/* カクヨム 網站檢測 */
							if(url.includes('kakuyomu.jp')){
								sourceLinks.kakuyomu=url;
							}
							/* 小説家になろう 網站檢測 */
							else if(url.includes('syosetu.com')){
								sourceLinks.syosetu=url;
							}
							/* 其他日文原文網站 */
							else{
								sourceLinks.japanese=url;
							}
						});
					}
					
					/* 
						更新選中小說的詳細信息：
						使用展開運算符保留現有屬性，添加新的詳情
					*/
					this.selectedNovel={
						/* 保留現有小說基本信息 */
						...this.selectedNovel,
						
						/* 
							標籤處理：
							- tags?.join(', ')：將標籤數組轉換為逗號分隔的字符串
							- 可選鏈操作符處理 tags 不存在的情況
							- ||''：默認為空字符串
						*/
						genres:this.selectedNovelData.tags?.join(', ')||'',
						
						/* 描述信息（支持Markdown格式） */
						description:this.selectedNovelData.description||'',
						
						/* 處理後的來源鏈接對象 */
						sourceLinks:sourceLinks
					};
					
					/* 
						處理章節列表：
						將原始章節數據轉換為應用內使用的格式
					*/
					this.allChapters=this.selectedNovelData.chapters
						/* 
							過濾有效章節：
							- filter(chapter => chapter.id >= 0)：只保留ID非負的章節
							- 排除可能的無效數據或特殊條目
						*/
						.filter(chapter=>chapter.id>=0)
						/* 
							轉換章節格式：
							將原始數據結構轉換為統一的章節對象
						*/
						.map(chapter=>({
							/* 章節編號：使用原始ID */
							number:chapter.id,
							
							/* 章節標題：保持原標題 */
							title:chapter.title,
							
							/* 
								文件名生成：
								- 格式：${編號} ${處理後的標題}.md
								- replace(/^第\d+\.?\d*話\s+/,'')：移除標題開頭的"第X話"格式
								- 簡化文件名，避免重複信息
							*/
							filename:`${chapter.id} ${chapter.title.replace(/^第\d+\.?\d*話\s+/,'')}.md`,
							
							/* 
								日期格式化：
								- new Date(chapter.lastUpdated)：轉換為Date對象
								- .toISOString()：轉換為ISO標準格式
								- .split('T')[0]：只取日期部分，去除時間
								- 統一日期格式為 YYYY-MM-DD
							*/
							date:new Date(chapter.lastUpdated).toISOString().split('T')[0]
						}))
						/* 
							章節排序：
							- (a,b) => a.number - b.number：按章節編號升序排列
							- 確保章節按正確順序顯示
						*/
						.sort((a,b)=>a.number-b.number);
				},
				
				/* 
					=== 獲取封面圖片URL方法 ===
					用途：動態生成小說封面的完整路徑
					返回：封面圖片的URL或空字符串
				*/
				getCoverUrl(){
					/* 
						條件返回：
						- 如果有選中小說，構建封面URL
						- encodeURIComponent()：編碼小說標題中的特殊字符
						- 確保URL路徑的正確性
					*/
					return this.selectedNovel?`輕小說翻譯/${encodeURIComponent(this.selectedNovel.title)}/cover.jpg`:'';
				},
				
				/* 
					=== 獲取來源鏈接顯示名稱方法 ===
					用途：將來源鏈接的鍵名轉換為用戶友好的顯示名稱
					參數：key - 來源類型的鍵名
				*/
				getSourceLinkName(key){
					/* 
						名稱映射對象：
						定義各種來源類型對應的顯示名稱
					*/
					const names={
						kakuyomu:'カクヨム',
						syosetu:'小説家になろう',
						japanese:'日文原文'
					};
					
					/* 返回對應名稱，如果找不到則返回原始鍵名 */
					return names[key]||key;
				},
				
				/* 
					=== 日期格式化方法 ===
					用途：將日期字符串格式化為用戶友好的顯示格式
					參數：dateStr(日期字符串), format(格式類型，默認'detail')
				*/
				formatDate(dateStr,format='detail'){
					/* 空值檢查 */
					if(!dateStr)return'';
					
					/* 創建Date對象 */
					const date=new Date(dateStr);
					
					/* 
						根據格式類型返回不同的日期格式：
						- 'list'：簡化格式，用於列表頁
						- 其他：詳細格式，用於詳情頁
					*/
					return format==='list'?
						/* 
							簡化格式：
							- toLocaleDateString()：本地日期格式
							- 通常顯示為 M/D/YYYY 或類似格式
						*/
						date.toLocaleDateString():
						/* 
							詳細格式：
							- 'zh-TW'：繁體中文地區設置
							- year:'numeric'：四位數年份
							- month:'2-digit'：兩位數月份
							- day:'2-digit'：兩位數日期
							- replace(/\//g,'-')：將斜線替換為連字符
							- 最終格式：YYYY-MM-DD
						*/
						date.toLocaleDateString('zh-TW',{year:'numeric',month:'2-digit',day:'2-digit'}).replace(/\//g,'-');
				},
				/**
				 * === 異步章節內容加載方法 ===
				 * @description 從服務器獲取指定章節的Markdown內容並進行後續處理
				 * @async
				 * @throws {Error} 當網絡請求失敗或文件不存在時拋出錯誤
				 * 
				 * 功能流程：
				 * 1. 設置加載狀態標誌
				 * 2. 構建章節文件路徑
				 * 3. 發起網絡請求獲取內容
				 * 4. 處理響應並更新UI
				 * 5. 執行後續初始化操作
				 * 
				 * 錯誤處理：
				 * - 網絡錯誤：顯示錯誤訊息
				 * - 文件不存在：HTTP 404錯誤處理
				 * - 服務器錯誤：HTTP 5xx錯誤處理
				 */
				async loadChapterContent(){
					/* 
						=== 設置加載狀態標誌 ===
						雙重標誌確保正確的狀態管理
					*/
					/* 全局加載狀態：控制載入動畫的顯示 */
					this.isLoading=true;
					
					/* 
						內容加載標誌：
						- 防止在加載期間保存滾動位置
						- 避免位置被意外重置
					*/
					this._loadingContent=true;
					
					/* 
						=== 異常處理包裝 ===
						使用 try-catch-finally 確保狀態正確重置
					*/
					try{
						/* 
							=== 構建章節文件路徑 ===
							處理文件名中的特殊字符，確保URL安全
						*/
						/* 
							小說文件夾路徑編碼：
							- encodeURIComponent()：編碼特殊字符（空格、中文、符號等）
							- 確保路徑在URL中的正確性
						*/
						const folderPath=encodeURIComponent(this.selectedNovel.title);
						
						/* 
							章節文件名編碼：
							- 同樣處理文件名中的特殊字符
							- 防止路徑解析錯誤
						*/
						const encodedFilename=encodeURIComponent(this.currentChapter.filename);
						
						/* 
							完整文件路徑構建：
							- 格式：輕小說翻譯/${小說名}/${章節文件名}
							- 使用模板字符串拼接路徑
						*/
						const filename=`輕小說翻譯/${folderPath}/${encodedFilename}`;
						
						/* 
							=== 發起網絡請求 ===
							使用現代 Fetch API 獲取文件內容
						*/
						/* 
							await fetch()：
							- 異步網絡請求，等待響應
							- 返回 Response 對象包含狀態和數據
						*/
						const response=await fetch(filename);
						
						/* 
							=== HTTP 響應狀態檢查 ===
							驗證請求是否成功
						*/
						if(!response.ok){
							/* 
								拋出詳細錯誤信息：
								- response.status：HTTP狀態碼（404, 500等）
								- response.statusText：狀態描述文字
								- 提供有用的調試信息
							*/
							throw new Error(`HTTP ${response.status}: ${response.statusText}`);
						}
						
						/* 
							=== 提取文本內容 ===
							將響應體轉換為純文本字符串
						*/
						/* 
							await response.text()：
							- 異步讀取響應體為文本
							- 支持UTF-8編碼的中文內容
						*/
						this.chapterContent=await response.text();
						
						/* 
							=== DOM 更新後的操作 ===
							使用 Vue 的 nextTick 確保DOM完全更新
						*/
						this.$nextTick(()=>{
							/* 
								滾動到頁面頂部：
								- 每次載入新章節都從頂部開始閱讀
								- 提供一致的閱讀體驗
							*/
							window.scrollTo(0,0);
							
							/* 
								設置圖片查看器：
								- 為新載入的圖片添加點擊事件
								- 支持圖片放大查看功能
							*/
							this.setupImageViewer();
							
							/* 
								標記章節為已讀：
								- 自動記錄用戶的閱讀進度
								- 更新已讀狀態到本地存儲
							*/
							this.markAsRead();
							
							/* 調試信息：方便開發時追蹤執行流程 */
							console.log('準備恢復滾動位置...');
							
							/* 
								恢復閱讀位置：
								- 如果用戶之前讀過這一章，恢復到上次位置
								- 提供連續的閱讀體驗
							*/
							this.restoreScrollPosition();
							
							/* 
								重置內容加載標誌：
								- 表示內容加載和初始化完成
								- 允許重新保存滾動位置
							*/
							this._loadingContent=false;
						});
					}catch(error){
						/* 
							=== 錯誤處理 ===
							捕獲並處理各種可能的錯誤
						*/
						/* 開發調試：在控制台輸出詳細錯誤信息 */
						console.error('讀取章節內容失敗:',error);
						
						/* 
							用戶提示：
							- 顯示友好的錯誤訊息
							- 包含具體的錯誤原因
						*/
						alert(`讀取章節內容失敗: ${error.message}`);
						
						/* 
							狀態重置：
							- 確保在錯誤情況下也能正確重置狀態
							- 防止界面卡在加載狀態
						*/
						this._loadingContent=false;
					}finally{
						/* 
							=== 最終清理 ===
							無論成功或失敗都執行的清理操作
						*/
						/* 
							關閉加載指示器：
							- finally 塊確保加載狀態一定會被重置
							- 避免界面永遠顯示加載動畫
						*/
						this.isLoading=false;
					}
				},
				/**
				 * === 圖片查看器設置方法 ===
				 * @description 為章節內容中的圖片設置點擊事件監聽器
				 * 
				 * 技術原理：
				 * - 使用事件委託模式：在父容器上監聽點擊事件
				 * - 避免為每張圖片單獨添加事件監聽器
				 * - 支持動態載入的圖片內容
				 * 
				 * 事件管理：
				 * - 移除舊的事件監聽器防止重複綁定
				 * - 添加新的事件監聽器處理圖片點擊
				 * 
				 * 調用時機：
				 * - 章節內容載入完成後
				 * - 確保所有圖片都能響應點擊事件
				 */
				setupImageViewer(){
					/* 
						=== 獲取內容容器引用 ===
						使用 Vue 的 ref 機制獲取DOM元素
					*/
					/* 
						this.$refs.novelContent：
						- Vue 的 ref 系統提供的DOM引用
						- 指向包含章節內容的容器元素
						- 確保在正確的元素上設置事件監聽
					*/
					const content=this.$refs.novelContent;
					
					/* 
						=== 安全性檢查和事件設置 ===
						確保容器存在後再進行事件操作
					*/
					if(content){
						/* 
							移除舊的事件監聽器：
							- removeEventListener()：移除之前綁定的點擊事件
							- 防止重複綁定導致的多次觸發
							- 確保事件處理的唯一性
						*/
						content.removeEventListener('click',this.handleContentClick);
						
						/* 
							添加新的事件監聽器：
							- addEventListener()：綁定點擊事件到內容容器
							- 'click'：監聽點擊事件類型
							- this.handleContentClick：事件處理函數
							
							事件委託的優勢：
							- 性能更好：只需一個監聽器而不是每張圖片一個
							- 動態支持：新加載的圖片自動支持點擊功能
							- 內存效率：減少事件監聽器的數量
						*/
						content.addEventListener('click',this.handleContentClick);
					}
				},
				
				/**
				 * === 內容點擊事件處理方法 ===
				 * @description 處理章節內容區域的點擊事件，特別是圖片點擊
				 * @param {Event} e - DOM點擊事件對象
				 * 
				 * 事件委託原理：
				 * - 在父容器上監聽點擊事件
				 * - 通過事件冒泡機制捕獲子元素的點擊
				 * - 根據點擊目標的類型執行不同操作
				 * 
				 * 圖片處理流程：
				 * 1. 檢測點擊目標是否為圖片元素
				 * 2. 獲取圖片源地址
				 * 3. 激活燈箱顯示
				 * 4. 關閉其他模態框避免衝突
				 */
				handleContentClick(e){
					/* 
						=== 圖片點擊檢測 ===
						判斷用戶點擊的是否為圖片元素
					*/
					if(e.target.tagName==='IMG'){
						/* 
							e.target：
							- 事件的實際觸發元素
							- 在事件委託中，指向被點擊的具體元素
							
							tagName === 'IMG'：
							- 檢查元素的標籤名是否為 IMG
							- 確保只有圖片點擊才觸發燈箱
							- tagName 屬性返回大寫的標籤名
						*/
						
						/* 
							=== 設置燈箱圖片源 ===
							獲取被點擊圖片的完整URL
						*/
						/* 
							e.target.src：
							- 獲取 img 元素的 src 屬性值
							- 包含圖片的完整URL路徑
							- 用於在燈箱中顯示相同圖片
						*/
						this.lightboxImage=e.target.src;
						
						/* 
							=== 激活燈箱顯示 ===
							設置燈箱為活躍狀態
						*/
						/* 
							isLightboxActive = true：
							- 觸發燈箱的顯示
							- CSS 會根據此狀態添加相應樣式
							- 實現圖片的全屏查看效果
						*/
						this.isLightboxActive=true;
						
						/* 
							=== 清理其他界面元素 ===
							確保燈箱顯示時界面簡潔
						*/
						/* 
							關閉所有模態框：
							- 避免燈箱與設置面板、章節菜單等衝突
							- 提供專注的圖片查看體驗
							- 確保燈箱具有最高的視覺優先級
						*/
						this.closeAllModals();
					}
				},
				/* 
					=== 滾動事件處理方法 ===
					用途：監聽頁面滾動，實現自動隱藏/顯示控制欄功能
					功能：提升閱讀體驗，減少界面干擾
				*/
				handleScroll(){
					/* 
						跳過設置調整期間的滾動處理：
						- _adjustingSettings 標誌防止在用戶調整設置時觸發滾動邏輯
						- 避免設置更新過程中的意外行為
					*/
					if(this._adjustingSettings)return;
					
					/* 
						獲取當前滾動位置：
						- window.pageYOffset：現代瀏覽器的滾動位置
						- document.documentElement.scrollTop：兼容舊瀏覽器
						- 邏輯或操作符確保跨瀏覽器兼容性
					*/
					const st=window.pageYOffset||document.documentElement.scrollTop;
					
					/* 
						檢測是否到達頁面底部：
						- window.innerHeight：視窗高度
						- window.pageYOffset：當前滾動位置
						- document.body.offsetHeight：頁面總高度
						- -100：提前100px觸發，提供更好的用戶體驗
					*/
					const isAtBottom=window.innerHeight+window.pageYOffset>=document.body.offsetHeight-100;
					
					/* 
						上次滾動位置：
						- _lastScrollTop：私有屬性記錄上次位置
						- ||0：如果未定義則默認為0
					*/
					const lastScrollTop=this._lastScrollTop||0;
					
					/* 
						計算滾動距離：
						- Math.abs()：取絕對值，忽略方向
						- 用於判斷滾動幅度是否足夠觸發邏輯
					*/
					const scrollDelta=Math.abs(st-lastScrollTop);
					
					/* 
						忽略微小的滾動：
						- 小於10px的滾動可能是意外觸發
						- 避免過於敏感的控制欄隱藏/顯示
					*/
					if(scrollDelta<10)return;
					
					/* 
						判斷滾動方向：
						- st > lastScrollTop：向下滾動
						- st < lastScrollTop：向上滾動
					*/
					const isScrollingDown=st>lastScrollTop;
					
					/* 
						控制欄隱藏邏輯：
						- isScrollingDown：向下滾動
						- !isAtBottom：未到達底部
						- st > 100：滾動超過100px
						
						同時滿足這些條件時隱藏控制欄
					*/
					if(isScrollingDown&&!isAtBottom&&st>100){
						/* 隱藏導航控制欄 */
						this.hideControls=true;
						
						/* 關閉所有模態框，清理界面 */
						this.closeAllModals();
					}
					/* 
						控制欄顯示邏輯：
						- !isScrollingDown：向上滾動
						- isAtBottom：到達頁面底部
						- st <= 50：接近頁面頂部
						
						任一條件滿足時顯示控制欄
					*/
					else if(!isScrollingDown||isAtBottom||st<=50){
						this.hideControls=false;
					}
					
					/* 更新上次滾動位置 */
					this._lastScrollTop=st;
					
					/* 保存當前閱讀位置 */
					this.saveScrollPosition();
				},
				
				/* 
					=== 滾動位置保存方法 ===
					用途：將用戶的閱讀位置保存到瀏覽器存儲
					功能：支持章節間的位置記憶
				*/
				saveScrollPosition(){
					/* 
						前置條件檢查：
						- 必須有選中的小說和當前章節
						- 確保有有效的上下文進行位置保存
					*/
					if(!this.selectedNovel||!this.currentChapter)return;
					
					/* 
						跳過內容加載期間的保存：
						- _loadingContent 標誌防止在加載新內容時覆蓋位置
						- 避免位置被重置到頂部
					*/
					if(this._loadingContent){
						console.log('內容加載中，跳過保存滾動位置');
						return;
					}
					
					/* 
						異常處理：
						- sessionStorage 操作可能失敗（隱私模式、存儲滿等）
						- 使用 try-catch 確保不影響其他功能
					*/
					try{
						/* 
							獲取現有滾動位置數據：
							- sessionStorage.getItem()：獲取會話存儲的數據
							- JSON.parse()：解析JSON字符串為對象
							- ||{}：如果不存在則使用空對象
						*/
						const scrollPositions=JSON.parse(sessionStorage.getItem('novel_scroll_position'))||{};
						
						/* 
							獲取當前小說的位置記錄：
							- this.novelKey：小說的唯一標識符
							- ||{}：如果該小說沒有記錄則使用空對象
						*/
						const novelPositions=scrollPositions[this.novelKey]||{};
						
						/* 獲取當前滾動位置 */
						const currentPosition=window.pageYOffset;
						
						/* 
							保存章節位置：
							- 以章節編號為鍵，滾動位置為值
							- 支持每個章節獨立的位置記憶
						*/
						novelPositions[this.currentChapter.number]=currentPosition;
						
						/* 更新小說的位置記錄 */
						scrollPositions[this.novelKey]=novelPositions;
						
						/* 
							保存到會話存儲：
							- JSON.stringify()：將對象序列化為字符串
							- sessionStorage：會話級存儲，關閉瀏覽器後清除
						*/
						sessionStorage.setItem('novel_scroll_position',JSON.stringify(scrollPositions));
						
						/* 調試信息輸出 */
						console.log(`保存滾動位置: ${this.novelKey} 章節${this.currentChapter.number} 位置${currentPosition}`);
					}catch{
						/* 
							靜默處理異常：
							- 滾動位置保存失敗不應影響閱讀體驗
							- 使用空 catch 塊避免控制台錯誤
						*/
					}
				},
				
				/* 
					=== 滾動位置恢復方法 ===
					用途：從存儲中恢復用戶之前的閱讀位置
					場景：切換章節後、重新進入閱讀器時
				*/
				restoreScrollPosition(){
					/* 
						前置條件檢查：
						- 必須有小說和章節信息才能恢復位置
					*/
					if(!this.selectedNovel||!this.currentChapter){
						console.log('恢復滾動位置：缺少小說或章節信息');
						return;
					}
					
					/* 異常處理 */
					try{
						/* 獲取存儲的滾動位置數據 */
						const scrollPositions=JSON.parse(sessionStorage.getItem('novel_scroll_position'))||{};
						
						/* 獲取當前小說的位置記錄 */
						const novelPositions=scrollPositions[this.novelKey]||{};
						
						/* 獲取當前章節的保存位置 */
						const savedPosition=novelPositions[this.currentChapter.number];
						
						/* 調試信息 */
						console.log(`檢查滾動位置: ${this.novelKey} 章節${this.currentChapter.number}, 保存位置: ${savedPosition}`);
						
						/* 如果有有效的保存位置 */
						if(savedPosition!==undefined&&savedPosition>0){
							/* 
								延遲恢復位置：
								- setTimeout 100ms 確保頁面完全渲染
								- 避免在DOM未完成時嘗試滾動
							*/
							setTimeout(()=>{
								/* 
									滾動到保存的位置：
									- parseInt()：確保位置是整數
									- window.scrollTo(0, y)：垂直滾動到指定位置
								*/
								window.scrollTo(0,parseInt(savedPosition));
								console.log(`✅ 恢復滾動位置: ${this.novelKey} 章節${this.currentChapter.number} 位置${savedPosition}`);
							},100);
						}else{
							/* 新章節提示 */
							console.log(`ℹ️ 新章節，保持在頂部: ${this.novelKey} 章節${this.currentChapter.number}`);
						}
					}catch(error){
						/* 錯誤處理 */
						console.log('❌ 恢復滾動位置時出錯:', error);
					}
				},
				/* 
					=== 章節導航方法 ===
					用途：通過方向鍵或導航按鈕切換到上一章或下一章
					參數：direction - 'next'(下一章) 或 'prev'(上一章)
				*/
				navigateChapter(direction){
					/* 
						加載狀態檢查：
						- 如果正在加載章節內容，忽略導航請求
						- 防止用戶快速點擊導致的重複請求
					*/
					if(this.isLoading)return;
					
					/* 
						查找當前章節在列表中的索引：
						- findIndex()：返回符合條件的第一個元素索引
						- ch => ch.number === this.currentChapter.number：比較章節編號
					*/
					const currentIndex=this.allChapters.findIndex(ch=>ch.number===this.currentChapter.number);
					
					/* 
						計算目標章節索引：
						- direction === 'next'：下一章索引 = 當前索引 + 1
						- 否則：上一章索引 = 當前索引 - 1
						- 三元運算符簡潔處理兩種情況
					*/
					const targetIndex=direction==='next'?currentIndex+1:currentIndex-1;
					
					/* 根據索引獲取目標章節對象 */
					const targetChapter=this.allChapters[targetIndex];
					
					/* 
						執行章節跳轉：
						- 確保目標章節存在（防止越界）
						- true 參數表示來自閱讀器內部導航
					*/
					if(targetChapter){
						this.goToChapter(targetChapter.number,true);
					}
				},
				
				/* 
					=== 排序下拉菜單切換方法 ===
					用途：切換排序下拉菜單的顯示/隱藏狀態
				*/
				toggleSortDropdown(){
					/* 
						下拉菜單狀態切換：
						- 如果當前有活躍的下拉菜單，設為 null（隱藏）
						- 否則設為 'sort'（顯示排序菜單）
						- 三元運算符實現狀態切換
					*/
					this.setDropdown(this.activeDropdown?null:'sort');
				},
				
				/* 
					=== 模態框切換方法 ===
					用途：切換指定模態框的顯示/隱藏狀態
					參數：type - 模態框類型（'showSettings' 或 'showChapterMenu'）
				*/
				toggleModal(type){
					/* 檢查指定模態框是否已顯示 */
					if(this[type]){
						/* 如果已顯示，隱藏該模態框 */
						this[type]=false;
					}else{
						/* 
							如果未顯示：
							1. 先關閉所有其他模態框
							2. 顯示指定的模態框
						*/
						this.closeAllModals();
						this[type]=true;
						
						/* 
							章節菜單的特殊處理：
							自動滾動到當前正在閱讀的章節
						*/
						if(type==='showChapterMenu'){
							/* 
								使用 $nextTick 確保DOM更新完成：
								- Vue的響應式更新是異步的
								- 確保模態框完全顯示後再執行滾動
							*/
							this.$nextTick(()=>{
								/* 
									查找並滾動到當前章節：
									- querySelector()：查找帶有 .current 類的章節元素
									- ?.scrollIntoView()：可選鏈調用滾動方法
									- behavior:'smooth'：平滑滾動動畫
									- block:'center'：將元素滾動到視窗中心
								*/
								const currentElement=document.querySelector('.modal .chapter-item.current');
								currentElement?.scrollIntoView({behavior:'smooth',block:'center'});
							});
						}
					}
				},
				
				/* 
					=== 燈箱圖片查看器開啟方法 ===
					用途：顯示圖片的全屏燈箱效果
					參數：imageUrl - 要顯示的圖片URL
				*/
				openLightbox(imageUrl){
					/* 設置燈箱要顯示的圖片 */
					this.lightboxImage=imageUrl;
					
					/* 激活燈箱顯示 */
					this.isLightboxActive=true;
				},
				
				/* 
					=== 圖片加載錯誤處理方法 ===
					用途：當圖片無法加載時顯示錯誤圖片
					參數：event - 圖片錯誤事件對象
				*/
				handleImageError(event){
					/* 
						替換錯誤圖片：
						- event.target：觸發錯誤的圖片元素
						- 設置 src 為錯誤提示圖片
						- 提供更好的用戶體驗，避免顯示破碎圖片圖標
					*/
					event.target.src='images/ImageError.png';
				},
				
				/* 
					=== 排序選項變更處理方法 ===
					用途：用戶選擇新的排序方式時的處理
					參數：sortOption - 選中的排序選項對象
				*/
				handleSortChange(sortOption){
					/* 更新當前排序方式 */
					this.currentSort=sortOption.value;
					
					/* 保存用戶選擇到本地存儲 */
					StorageUtil.setString(STORAGE_KEYS.SORT,sortOption.value);
					
					/* 關閉下拉菜單 */
					this.activeDropdown=null;
				},
				
				/* 
					=== 標記章節為已讀方法 ===
					用途：記錄用戶已經閱讀過的章節
					功能：支持閱讀進度跟蹤
				*/
				markAsRead(){
					/* 前置條件檢查 */
					if(!this.selectedNovel||!this.currentChapter)return;
					
					/* 
						獲取已讀章節記錄：
						- StorageUtil.get()：從本地存儲獲取數據
						- STORAGE_KEYS.READ_CHAPTERS：已讀章節的存儲鍵
						- {}：默認為空對象
					*/
					const readChapters=StorageUtil.get(STORAGE_KEYS.READ_CHAPTERS,{});
					
					/* 
						初始化小說的已讀記錄：
						如果該小說還沒有已讀記錄，創建空數組
					*/
					if(!readChapters[this.novelKey]){
						readChapters[this.novelKey]=[];
					}
					
					/* 
						添加已讀章節：
						- includes()：檢查章節是否已在已讀列表中
						- 避免重複添加相同章節
					*/
					if(!readChapters[this.novelKey].includes(this.currentChapter.number)){
						/* 
							=== 添加新的已讀章節 ===
							將當前章節編號添加到該小說的已讀章節數組中
							- push()：在數組末尾添加新元素
							- this.currentChapter.number：當前章節的編號
						*/
						readChapters[this.novelKey].push(this.currentChapter.number);
						
						/* 
							=== 持久化存儲已讀記錄 ===
							將更新後的已讀章節記錄保存到瀏覽器本地存儲
							- StorageUtil.set()：使用工具類進行 JSON 序列化存儲
							- STORAGE_KEYS.READ_CHAPTERS：預定義的存儲鍵名
							- readChapters：包含所有小說已讀記錄的完整對象
							- 確保用戶的閱讀進度在頁面刷新後仍然保持
						*/
						StorageUtil.set(STORAGE_KEYS.READ_CHAPTERS,readChapters);
					}
				},
				
				/* 
					=== 檢查章節是否已讀方法 ===
					用途：判斷指定章節是否已被用戶閱讀
					參數：chapterNumber - 要檢查的章節編號
					返回：boolean - true表示已讀，false表示未讀
				*/
				isChapterRead(chapterNumber){
					/* 前置條件檢查 */
					if(!this.selectedNovel)return false;
					
					/* 獲取已讀章節記錄 */
					const readChapters=StorageUtil.get(STORAGE_KEYS.READ_CHAPTERS,{});
					
					/* 
						檢查指定章節是否已讀：
						- 可選鏈操作符安全訪問數組
						- includes()：檢查章節編號是否在已讀列表中
						- ||false：默認為未讀狀態
					*/
					return readChapters[this.novelKey]?.includes(chapterNumber)||false;
				},
				
				/* 
					=== 關閉所有模態框方法 ===
					用途：一次性隱藏所有顯示中的模態框
					場景：用戶點擊其他區域、切換頁面等
				*/
				closeAllModals(){
					/* 關閉設置模態框 */
					this.showSettings=false;
					
					/* 關閉章節選擇模態框 */
					this.showChapterMenu=false;
				},
				
				/* 
					=== 查找章節方法 ===
					用途：根據章節編號查找對應的章節對象
					參數：chapterNumber - 要查找的章節編號
					返回：章節對象或 undefined
				*/
				findChapter(chapterNumber){
					/* 
						使用 find() 方法搜索：
						- ch => ch.number === chapterNumber：比較函數
						- 返回第一個匹配的章節對象
					*/
					return this.allChapters.find(ch=>ch.number===chapterNumber);
				},
				
				/* 
					=== 設置調整開始處理方法 ===
					用途：用戶開始調整設置時的狀態管理
					場景：滑桿拖動開始時調用
				*/
				onSettingsInputStart(){
					/* 
						設置調整狀態標誌：
						- 防止在設置調整期間觸發其他邏輯
						- 特別是滾動事件處理
					*/
					this._adjustingSettings=true;
					
					/* 清除之前的計時器 */
					clearTimeout(this._adjustingTimer);
				},
				
				/* 
					=== 設置調整結束處理方法 ===
					用途：用戶完成設置調整時的狀態重置
					場景：滑桿拖動結束時調用
				*/
				onSettingsInputEnd(){
					/* 清除舊的計時器 */
					clearTimeout(this._adjustingTimer);
					
					/* 
						延遲重置調整狀態：
						- 500ms 延遲確保所有設置更新完成
						- 避免過早重置狀態標誌
					*/
					this._adjustingTimer=setTimeout(()=>this._adjustingSettings=false,500);
				},
				
				/* 
					=== 下拉菜單滑鼠進入處理方法 ===
					用途：滑鼠懸停在下拉菜單觸發器上時顯示菜單
				*/
				handleDropdownMouseEnter(){
					/* 立即顯示排序下拉菜單 */
					this.setDropdown('sort');
				},
				
				/* 
					=== 下拉菜單滑鼠離開處理方法 ===
					用途：滑鼠離開下拉菜單區域時隱藏菜單
				*/
				handleDropdownMouseLeave(){
					/* 
						延遲隱藏菜單：
						- 150ms 延遲給用戶時間移動到下拉菜單
						- 防止意外的快速隱藏/顯示
					*/
					this.setDropdown(null,150);
				},
				
				/* 
					=== 下拉菜單狀態設置方法 ===
					用途：統一管理下拉菜單的顯示/隱藏邏輯
					參數：value(菜單狀態), delay(延遲時間，默認0)
				*/
				setDropdown(value,delay=0){
					/* 清除之前設置的計時器，避免衝突 */
					clearTimeout(this._dropdownTimer);
					
					/* 根據是否有延遲決定執行方式 */
					if(delay){
						/* 
							延遲執行：
							- 用於滑鼠離開時的延遲隱藏
							- 提供更好的用戶體驗
						*/
						this._dropdownTimer=setTimeout(()=>this.activeDropdown=value,delay);
					}else{
						/* 立即執行：用於滑鼠進入時的立即顯示 */
						this.activeDropdown=value;
					}
				}
			},
			/* 
				=== Vue.js Mounted 生命週期鉤子 ===
				mounted() 在組件掛載到DOM後立即執行：
				1. DOM已完全構建：可以安全地訪問和操作DOM元素
				2. 初始化設置：恢復用戶偏好設置和應用狀態
				3. 事件監聽：註冊全局事件監聽器
				4. 數據加載：發起初始數據請求
				5. 第三方庫初始化：配置外部庫和插件
			*/
			mounted(){
				/* 
					=== 初始化主題設置 ===
					從本地存儲恢復用戶的主題偏好
				*/
				/* 
					獲取保存的主題設置：
					- StorageUtil.getString()：從本地存儲獲取主題
					- STORAGE_KEYS.THEME：預定義的存儲鍵
					- ||'light'：默認使用淺色主題
				*/
				const theme=StorageUtil.getString(STORAGE_KEYS.THEME)||'light';
				
				/* 
					應用主題到DOM：
					- document.documentElement：根元素（<html>）
					- setAttribute()：設置 data-theme 屬性
					- CSS 選擇器 [data-theme] 根據此屬性應用對應樣式
				*/
				document.documentElement.setAttribute('data-theme',theme);
				
				/* 
					=== 初始化CSS自定義屬性 ===
					將Vue數據中的設置值同步到CSS變量
				*/
				/* 字體大小CSS變量設置 */
				document.documentElement.style.setProperty('--fs',`${this.fontSize}px`);
				
				/* 行高CSS變量設置 */
				document.documentElement.style.setProperty('--lh',this.lineHeight);
				
				/* 內容寬度CSS變量設置 */
				document.documentElement.style.setProperty('--content-width',`${this.contentWidth}%`);
				
				/* 
					=== 初始化應用數據 ===
					獲取小說列表並處理URL參數路由
				*/
				/* 
					Promise鏈式調用：
					- this.fetchNovelList()：異步獲取小說數據
					- .then()：數據獲取完成後處理URL路由
					- this.handleUrlParams()：根據URL參數設置初始頁面狀態
				*/
				this.fetchNovelList().then(()=>this.handleUrlParams());
				
				/* 
					=== 瀏覽器歷史記錄事件處理 ===
					監聽用戶使用瀏覽器前進/後退按鈕
				*/
				/* 
					箭頭函數簡化事件處理：
					- ()=>this.handleUrlParams()：瀏覽器歷史變化時重新解析URL
					- 保持this指向Vue實例
				*/
				const handlePopstate=()=>this.handleUrlParams();
				
				/* 
					=== 鍵盤事件處理器定義 ===
					處理全局鍵盤快捷鍵
				*/
				const handleKeydown=(e)=>{
					/* 
						ESC鍵處理：
						- 優先級：燈箱 > 閱讀器模態框
						- 提供直觀的退出方式
					*/
					if(e.key==='Escape'){
						/* 如果燈箱激活，關閉燈箱 */
						if(this.isLightboxActive){
							this.isLightboxActive=false;
						}
						/* 如果在閱讀器頁面，關閉所有模態框 */
						else if(this.currentPage==='reader'){
							this.closeAllModals();
						}
					}
					/* 
						方向鍵章節導航：
						- 只在閱讀器頁面且無模態框時生效
						- 左鍵/上鍵：上一章
						- 右鍵/下鍵：下一章
					*/
					else if(this.currentPage==='reader'&&!this.showSettings&&!this.showChapterMenu&&!this.isLightboxActive){
						/* 
							上一章導航：
							- (e.key==='ArrowLeft'||e.key==='ArrowUp')：左鍵或上鍵
							- &&this.hasPrevious：確保有上一章可用
						*/
						if((e.key==='ArrowLeft'||e.key==='ArrowUp')&&this.hasPrevious){
							this.navigateChapter('prev');
						}
						/* 
							下一章導航：
							- (e.key==='ArrowRight'||e.key==='ArrowDown')：右鍵或下鍵
							- &&this.hasNext：確保有下一章可用
						*/
						else if((e.key==='ArrowRight'||e.key==='ArrowDown')&&this.hasNext){
							this.navigateChapter('next');
						}
					}
				};
				
				/* 
					=== 文檔點擊事件處理器定義 ===
					處理全局點擊事件，實現模態框和下拉菜單的自動關閉
				*/
				const handleDocumentClick=(e)=>{
					/* 
						閱讀器頁面點擊處理：
						- 點擊非模態框和非按鈕區域時關閉模態框
						- e.target.closest()：檢查點擊目標是否在指定元素內
					*/
					if(this.currentPage==='reader'&&!e.target.closest('.modal')&&!e.target.closest('.btn-primary')){
						/* 關閉所有模態框 */
						this.closeAllModals();
						
						/* 
							顯示隱藏的控制欄：
							- 用戶點擊後重新顯示導航控制
							- 提供良好的用戶體驗
						*/
						if(this.hideControls){
							this.hideControls=false;
						}
					}
					
					/* 
						下拉菜單外部點擊關閉：
						- !e.target.closest('.dropdown')：點擊不在下拉菜單內
						- 自動關閉展開的下拉菜單
					*/
					if(!e.target.closest('.dropdown')){
						this.activeDropdown=null;
					}
				};
				
				/* 
					=== 註冊全局事件監聽器 ===
					將定義的事件處理器註冊到對應的DOM元素
				*/
				/* 
					瀏覽器歷史記錄變化監聽：
					- window：全局對象
					- 'popstate'：歷史記錄變化事件
					- handlePopstate：處理函數
				*/
				window.addEventListener('popstate',handlePopstate);
				
				/* 
					文檔點擊事件監聽：
					- document：整個文檔
					- 'click'：點擊事件
					- handleDocumentClick：處理函數
				*/
				document.addEventListener('click',handleDocumentClick);
				
				/* 
					鍵盤事件監聽：
					- document：整個文檔
					- 'keydown'：按鍵按下事件
					- handleKeydown：處理函數
				*/
				document.addEventListener('keydown',handleKeydown);
			}
		}).mount('#app');
	</script>
</body>
</html>
